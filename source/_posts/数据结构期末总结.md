---
title: 数据结构期末总结
tags: []
categories:
  - 数据结构
date: 2020-05-31 16:02:00
---
# 各类型存储结构

![image-20200531145418964](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200531145418964.png)

## 顺序表

![image-20200529171311253](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171311253.png)

```c
#define MAXSIZE 100	//顺序表可能达到的最大长度
typedef struct
{
    ElemType *elem;	//存储空间的基地址(例如用L.elem[0]取元素)
    int length;	//当前长度
}SqList;
```

L.elem[i]取值 	//L.length-1=>i>=0，如元素为1,2,3，L.length=3，i=0,1,2

## 单链表

![image-20200529170658268](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170625502.png)

```c
typedef struct LNode
{
    ElemType data;	//结点的数据域
    struct LNode *next;	//结点的指针域，指向下一结点
}LNode,*LinkList;	//LinkList为指向结构体LNode的指针类型(相当于LNode *)
```

若带头结点，空表条件为L->next==NULL（L为头指针指向头结点永不为空）

若不带头结点，空表条件为L==NULL

## 双向链表

![image-20200529170625502](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529170658268.png)

```c
typedef struct DuLNode
{
    ElemType data;	//结点的数据域
    struct DuLNode *prior;	//指向直接前驱
    struct DuLNode *next;	//指向直接后继
}DuLNode,*DuLinkList;	
```

## 顺序栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171934385.png" alt="image-20200529172642776" style="zoom: 60%;" />

```c
#define MAXSIZE 100	//顺序栈存储空间的初始分配量
typedef struct
{
    SElemType *base;	//栈底指针
    SElemType *top;		//栈顶指针
    int stacksize;		//栈可用的最大容量
}SqStack;
```

栈空：S.top==S.base	//首尾指针相同

栈满：S.top-S.base==S.stacksize	//尾-首等于最大容量即为满

## 链栈

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529171646363.png" alt="image-20200529171934385" style="zoom: 50%;" />

```c
//定义类似，类似操作受限的单链表
typedef struct StackNode
{
    ElemType data;	//数据域
    struct StackNode *next;	//指向下一结点
}StackNode,*LinkStack;
```

链栈一定是没有头结点，所以栈空的条件为：S==NULL

## 循环队列

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172331805.png" alt="image-20200529171646363" style="zoom: 50%;" />

```c
#define MAXSIZE 100 //队列可能达到的最大长度
typedef struct
{
    QElemType *base;	//存储空间的基地址
    int front;	//头指针（只是有指针的作用,例如用Q.base[Q.front]取元素）
    int rear;	//尾指针
}SqQueue;
```

队空：Q.front==Q.rear	//首尾指针相同

//尾指针指向的为最后一个元素的下一个地址(永远为空)，所以+1

队满：(Q.rear+1)%MAXSIZE==Q.front	

## 链队

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200529172642776.png" alt="image-20200529172331805" style="zoom:50%;" />

```c
//只看第一个定义和单链表类似，不同的是第二个设了队头和队尾指针
typedef struct QNode
{
    QElemType data;	//数据域
    struct QNode *next;	//指向下一结点
}QNode,*QueuePtr;
typedef struct
{
    QueuePtr front;	//队头指针(相等于QNode *front)
    QueuePtr rear;	//队尾指针
}LinkQueue;
```

队空：Q.front=Q.rear

由于串、数组、广义表的存储结构不是重点在这里就不再列出其存储结构

## 小结

有==头尾指针==的有：==顺序栈和队列==(顺序和链式)

- 顺序栈（栈顶和栈底）
- 循环队列
- 链队

# 1.绪论

1.逻辑结构：数据之间的相互关系。

- 集合 结构中的数据元素除了同属于一种类型外，别无其它关系。
- 线性结构 数据元素之间一对一的关系
- 树形结构 数据元素之间一对多的关系
- 图状结构或网状结构 结构中的数据元素之间存在多对多的关系

也可分为线性结构(可理解成一条直线能串起来)和非线性结构

2.存储结构分为顺序存储结构和链式存储结构

3.算法**五个特性**： 有穷性、确定性、可行性、输入、输出

4.算法设计要求：正确性、可读性、健壮性、高效性。(好的算法)

5.typedef可以理解成给现有数据类型起个别名

例如：typedef struct{.....}SqList，即给struct{......}起了个名字叫SqList

也用于类似于typedef int ElemType; 给int 起个别名叫ElemType即ElemType a;等价于int a;

这样做的好处是代码中用ElemType定义变量，如果想修改变量类型只需修改typedef ** ElemType即可，而不用一一修改。

> 我们注意到有时候会有typedef struct LNode{...}LNode，即struct后有个LNode,这是因为如果结构体内部有指向结构体的指针则必须在struct后面加上LNode(单链表里有next指针struct LNode *next)

6.时间复杂度：可以理解成就看执行了多少次

7.研究数据结构就是研究数据的逻辑结构、存储结构及其基本操作

8.抽象数据类型的三个组成部分为数据对象、数据关系、基本操作。



# 2.线性表

**1.线性表和有序表合并的时间复杂度**

线性表的合并时间复杂度为O(m*n)

A=(7,5,3,11)，B=(2,6,3)，结果为A=(7,5,3,11,2,6)

算法需要循环遍历B(O(n))且LocateElem(A)(判断是否与B重复为O(m))所以为O(m*n)

有序表的合并时间复杂度为O(m+n)

A=(3,5,8,11)，B=(2,6,8)，结果为A=(2,3,5,6,8,11)

算法只需同时遍历A和B，然后将还没遍历完的那个直接插到最后就行，所以是相加

2.顺序表插入平均移动n+1/2，删除平均移动n-1/2

# 4.串、数组和广义表

## 数组

### 求next数组和nextval数组

![image-20200530144018875](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530144018875.png)

当j=1(即第一个字符)时为特殊情况next和nextval均为0

### next数组：其值为当前字母前方的最大前后缀+1

例如：j=3(A)，前面有A，B。没有前后缀即为0，0+1=1

j=4(B)，前面有ABA，有前缀和后缀A，即前后缀为1，1+1=2

j=5(A)，前面有ABAB，前后缀为AB，2+1=3	//ABA和BAB不等，所以AB为最大前后缀

### nextval数组：两种情况

J对应的字母与next[j]的值转换为j对应的字母==不等==时，nextval值为next[j]

J对应的字母与next[j]的值转换为j对应的字母==相等==时，nextval值为nextval[next[j]]

> 由此可看出要想求nextval，必须正确的求出next

例如：j=2，j对应的字母为B，next[j]即next[2]=1，也就是j=1对应的字母为A，B与A不等则nextval值为next[2]=1

j=3，j对应的字母为A，next[j]即next[3]=1，也就是j=1对应的字母为A，A与A相等则nextval值为nextval[next[j]]=nextval[1]=0

### 行优先和列优先

![image-20200530152310875](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530152310875.png)

其实就是行优先就是先一行一行的存，列优先就是一列一列的存

无论是哪个其元素位置如a\[2][3]位置不变，行优先就是先存上面2行再到它，列优先就是先存左面3列再存它

## 广义表

广义表是线性表的推广(非线性)，也称列表（暂时理解成python里的列表）

广义表元素可为原子或子表

广义表长度：即元素个数(最外层括号里的小括号算一个元素)

广义表深度：就看有多少对括号就行(注意要将里面的子表全部展开)

表头(Head)和表尾(Tail)：当表非空时，第一个元素为表头其余均为表尾

> 注意表头是第一个元素不带最外层的那个括号，表尾带最外层的括号

例如A=((a,b),c)，表头为(a,b)而表尾为(c)

## 串

串的子串个数为n(n+1)/2+1（空串也算所以加1）

## 习题

![image-20200530201544055](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200530201544055.png)

