---
title: 计算机组成原理期末总结
tags:
  - 计算机专业课
categories:
  - 计算机专业课
date: 2020-06-09 22:32:00
---
# 计算机系统概论

## 知识点

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608144821042.png" alt="image-20200608144821042" style="zoom: 67%;" />

1.时钟周期是计算机中最基本的、最小的时间单位。在一个时钟周期内，CPU仅完成一个最基本的动作。

2.主频(时钟频率)：每秒钟含有多少个时钟周期(1.2GHz即每秒钟含有1.2x10^9个时钟周期)。

3.CPI：一条指令所需要的时钟周期个数。

4.MIPS：每秒钟能执行多少个==100万==条指令。
![](https://img-blog.csdnimg.cn/2020021912112010.png)

5.MFLOPS：每秒百万次浮点操作次数。

6.CPU执行时间：TCPU=In×CPI×TC (指令条数\*一条指令需要几个时钟周期\*时钟周期长度)

>In：执行程序中==指令==的==总数==<br>
>CPI(Clock Cycle Per Instruction)：执行每条==指令所需==的平均时钟==周期个数==<br>
>TC：时钟==周期时间==的长度

7.吞吐量：计算机某一时间间隔内能够处理的信息量(能吞多少)

8.响应时间：从事件开始到事件结束的时间,也称执行时间.

7.冯●诺依曼型计算机设计思想主要有两项:

- 将十进制改为二进制,从而太太简化了计算机的结构和运算过程;
- 存储程序的思想，将程序与数据一起存储在计算机内，使得计算机的全部运算成为真正的自动过程。

8.用嘴(一句一句最后生成目标程序)来解释，用手(一步到位最后不生成目标程序)来编译

编译程序将高级语言转换为机器代码再执行，解释程序用源程序直接解释，解释一句执行一句不用转换成机器代码。所以编译要比解释速度快

9.控制器可根据==不同的周期==(取指周期或者执行周期)来区分该地址的存储单元存储的是数据还是指令。

## 习题

1.假定机器M的时钟频率为200MHz，程序P在机器M上的执行时间为12s。对P优化，将所有乘4指令都换成了一条左移两位的指令，得到优化后的程序P'。若在M上乘法指令的CPI为102，左移指令的CPI为2，P的执行时间是P’执行时间的1.2倍，则P中的乘法指令条数为_______4x10^6^________

答：P'的执行时间为10s,比12少了2s，由时钟频率得每秒有2x10^8^个时钟周期，即少了4x10^8^个时钟周期

每条左移指令比乘法指令少了100个时钟周期，那么乘法指令个数即总共少的时钟周期/每条指令时钟周期

2.此题MIPS为400

![image-20200608152105898](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200608152105898.png)

答：平均CPI=2x0.5+ 3x0.2+4x0.1+5x0.2=3，即执行一个指令平均需要3个周期

MIPS为每秒可执行的百万条指令数，1.2GHZ为1200MHZ，1200/3=400（M=10^6^,G=10^9^）

3.程序P在机器M上的执行时间是20s，编译优化后，P执行的指令数减少到原来的70%，而CPI增加到原来的1.2倍，则P在M.上的执行时间是_______16.8s____

答：CPI即执行一条指令所需的时钟周期数。假设M机器原时钟周期为x,原CPI为y, P程序的指令数为z，可得P程序执行时间为xyz= 20s。

编译优化后M机器的CPI变为1.2y, P程序的指令数变为0.7z,则P程序执行时间为1.2*0.7xyz,故其执行时间为
16.8s。

# 运算方法和运算器

## 知识点

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609143207561.png" alt="image-20200609143207561" style="zoom: 80%;" />1.数字0在原码反码补码的表示

[+0]原码=0000 0000，  [-0]原码=1000 0000

[+0]反码=0000 0000，  [-0]反码=1111 1111

[+0]补码=0000 0000，  [-0]补码=0000 0000   （补码中是唯一的）

0的移码也是唯一的1000 0000

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609151740827.png" alt="image-20200609151740827" style="zoom:67%;" />

由于补码0是唯一的所以补码范围要多一个负数

2.对于规格化的浮点数，尾数有三种形式：（小数点左边的是符号位）

- 0.1xx……x(原码、补码、反码都是正数的形式)
- 1.0XX……X(补码、反码是负数的形式)
- 1.1xx……X(原码是负数的形式)尾数用原码表示，B是不符合规格化的形式

3.余3码就是8421码加3所得

4.奇偶校验码：加上校验码后1的个数为奇数就是奇校验。不具备纠错能力。

5.海明码：设有k个数据位，则应设r个校验位，r满足2^r^-1 ≥ k + r 。具有一位纠错能力。

6.循环冗余检验码(CRC)：k位校验位拼接在n位数据位后面，即为n+k，如何生成检验码见下面习题

7.A的ascii码：65            a的ascii码：97

8.已知[x]补，求[-x]补：将[x]补连同符号位求反+1

9.移码就是补码的符号位求反

> 由于负数的补码如-21(101011)看着好像大于21(010101)，实际正好是21更大，所以浮点数的阶码用移码表示能

10.-1的补码永远是全1(可理解为全1加1等于全0)

11.由于补码溢出无法看出是上溢(大于最大数)还是下溢，因此引入变形补码

- 两个符号位不同时表溢出(01为正溢出)
- 最高位那个数代表真正的符号位
- 两个符号位均参与运算，若进位舍去

12.



## 习题

1.写出D=101101的海明码

答：:one:首先确定检验位的个数：k=6，2^r^-1 ≥ k + r即2^r^ ≥7+r，所以r=4

:two:确定检验码的位置：检验码P~i~(i=1,2...)的位置为2^i-1^

注意从M10到M1，从大到小且没有0

![image-20200609150117418](https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609150117418.png)

:three:求出检验码的值：校验位Pi的值即为所有需要Pi校验的数据位求异或。

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@latest/images/image-20200609150430484.png" alt="image-20200609150430484" style="zoom:80%;" />

如P2对应M2，需要它的有D1即M3(2+1)、D3即M6(2+4)、D4即M7(2+4+1)......

所以最后的海明码为1011100100

2.已知x=11011，y=-10101，用变形补码计算x+y

<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609154616627.png" alt="image-20200609154616627" style="zoom:70%;" />

> 注意一定要先转换成补码再添符号位运算

3.假设M(x)=x^3^+1(发送信息的多项式)，G(x)=x^3^+x+1(生成多项式，代表校验位信息)。

:one: 那么M(x)代表的二进制码为: 1001(1*x^3^+1\*x^0^)，G(x)代表的二进制码为: 1011

:two:将M(x)的多项式左移G(x)的最高次数，变为1001 000

:three:将1001000对1011做模2除法得到余数为110,将其与被除数1001合并得到CRC码1001110

> 这里要注意第三步的模2除法和普通除法不同，模2除法不会向上一位借位也不比较被除数和除数的大小，如图中第三位商数(1101>1000但仍可做减操作)<img src="https://cdn.jsdelivr.net/gh/zss192/Typora-notes@master/images/image-20200609195155116.png" alt="image-20200609195155116" style="zoom:80%;" />

